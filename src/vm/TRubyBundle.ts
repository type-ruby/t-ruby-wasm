/**
 * T-Ruby Bundle - Auto-generated
 *
 * This file contains bundled T-Ruby source files for WASM environment.
 * Generated at build time from vendor/t-ruby directory.
 *
 * DO NOT EDIT MANUALLY - This file is auto-generated by scripts/bundle-t-ruby.mjs
 *
 * @internal
 */

/** Bundled T-Ruby source files */
export const T_RUBY_BUNDLE: Record<string, string> = {
  "build/allow_any.rb": `def process(x)
  x * 2
end
`,
  "build/defaults.rb": `def greet(name, greeting = "Hello")
  "#{greeting}, #{name}!"
end

puts greet("Alice")              # "Hello, Alice!"
puts greet("Bob", "Hi")          # "Hi, Bob!"
`,
  "build/empty.rb": ``,
  "build/error.rb": `def foo(: String); end`,
  "build/examples/default_parameters.rb": `# default_parameters.trb - 기본값이 있는 파라미터 예제

# 기본 사용: 문자열 기본값
def greet(name, greeting = "Hello")
  "#{greeting}, #{name}!"
end

puts greet("Alice")           # "Hello, Alice!"
puts greet("Bob", "Hi")       # "Hi, Bob!"

# 숫자 기본값
def add(a, b = 0)
  a + b
end

puts add(5)                   # 5
puts add(5, 3)                # 8

# nil 기본값
def find_user(id, fallback = nil)
  if fallback
    "User #{id} or #{fallback}"
  else
    "User #{id}"
  end
end

puts find_user(1)             # "User 1"
puts find_user(1, "guest")    # "User 1 or guest"

# 여러 기본값
def connect(host = "localhost", port = 8080)
  "#{host}:#{port}"
end

puts connect()                        # "localhost:8080"
puts connect("example.com")           # "example.com:8080"
puts connect("example.com", 443)      # "example.com:443"
`,
  "build/file1.rb": `# content of file1.trb`,
  "build/file2.rb": `# content of file2.trb`,
  "build/file3.rb": `# content of file3.trb`,
  "build/file_0.rb": `def method_0(value)
  value * 0
end
`,
  "build/file_1.rb": `def method_1(value)
  value * 1
end
`,
  "build/file_2.rb": `def method_2(value)
  value * 2
end
`,
  "build/file_3.rb": `def method_3(value)
  value * 3
end
`,
  "build/file_4.rb": `def method_4(value)
  value * 4
end
`,
  "build/file_5.rb": `def method_5(value)
  value * 5
end
`,
  "build/file_6.rb": `def method_6(value)
  value * 6
end
`,
  "build/file_7.rb": `def method_7(value)
  value * 7
end
`,
  "build/file_8.rb": `def method_8(value)
  value * 8
end
`,
  "build/file_9.rb": `def method_9(value)
  value * 9
end
`,
  "build/flexible.rb": `def greet(name)
  "Hello, #{name}"
end
`,
  "build/hello.rb": `puts 'test'`,
  "build/large.rb": `puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
puts 'line'
`,
  "build/loose.rb": `def process(x)
  x
end
`,
  "build/my-script.rb": `puts 'test'`,
  "build/my_script.rb": `puts 'test'`,
  "build/parallel_0.rb": `# Test file 0

def method_0_0(arg)
  arg.length
end

def method_0_1(arg)
  arg.length
end

def method_0_2(arg)
  arg.length
end

def method_0_3(arg)
  arg.length
end

def method_0_4(arg)
  arg.length
end

def method_0_5(arg)
  arg.length
end

def method_0_6(arg)
  arg.length
end

def method_0_7(arg)
  arg.length
end

def method_0_8(arg)
  arg.length
end

def method_0_9(arg)
  arg.length
end

def method_0_10(arg)
  arg.length
end

def method_0_11(arg)
  arg.length
end

def method_0_12(arg)
  arg.length
end

def method_0_13(arg)
  arg.length
end

def method_0_14(arg)
  arg.length
end

def method_0_15(arg)
  arg.length
end

def method_0_16(arg)
  arg.length
end

def method_0_17(arg)
  arg.length
end

def method_0_18(arg)
  arg.length
end

def method_0_19(arg)
  arg.length
end

def method_0_20(arg)
  arg.length
end

def method_0_21(arg)
  arg.length
end

def method_0_22(arg)
  arg.length
end

def method_0_23(arg)
  arg.length
end

def method_0_24(arg)
  arg.length
end

def method_0_25(arg)
  arg.length
end

def method_0_26(arg)
  arg.length
end

def method_0_27(arg)
  arg.length
end

def method_0_28(arg)
  arg.length
end

def method_0_29(arg)
  arg.length
end

def method_0_30(arg)
  arg.length
end

def method_0_31(arg)
  arg.length
end

def method_0_32(arg)
  arg.length
end

def method_0_33(arg)
  arg.length
end

def method_0_34(arg)
  arg.length
end

def method_0_35(arg)
  arg.length
end

def method_0_36(arg)
  arg.length
end

def method_0_37(arg)
  arg.length
end

def method_0_38(arg)
  arg.length
end

def method_0_39(arg)
  arg.length
end
`,
  "build/parallel_1.rb": `# Test file 1

def method_1_0(arg)
  arg.length
end

def method_1_1(arg)
  arg.length
end

def method_1_2(arg)
  arg.length
end

def method_1_3(arg)
  arg.length
end

def method_1_4(arg)
  arg.length
end

def method_1_5(arg)
  arg.length
end

def method_1_6(arg)
  arg.length
end

def method_1_7(arg)
  arg.length
end

def method_1_8(arg)
  arg.length
end

def method_1_9(arg)
  arg.length
end

def method_1_10(arg)
  arg.length
end

def method_1_11(arg)
  arg.length
end

def method_1_12(arg)
  arg.length
end

def method_1_13(arg)
  arg.length
end

def method_1_14(arg)
  arg.length
end

def method_1_15(arg)
  arg.length
end

def method_1_16(arg)
  arg.length
end

def method_1_17(arg)
  arg.length
end

def method_1_18(arg)
  arg.length
end

def method_1_19(arg)
  arg.length
end

def method_1_20(arg)
  arg.length
end

def method_1_21(arg)
  arg.length
end

def method_1_22(arg)
  arg.length
end

def method_1_23(arg)
  arg.length
end

def method_1_24(arg)
  arg.length
end

def method_1_25(arg)
  arg.length
end

def method_1_26(arg)
  arg.length
end

def method_1_27(arg)
  arg.length
end

def method_1_28(arg)
  arg.length
end

def method_1_29(arg)
  arg.length
end

def method_1_30(arg)
  arg.length
end

def method_1_31(arg)
  arg.length
end

def method_1_32(arg)
  arg.length
end

def method_1_33(arg)
  arg.length
end

def method_1_34(arg)
  arg.length
end

def method_1_35(arg)
  arg.length
end

def method_1_36(arg)
  arg.length
end

def method_1_37(arg)
  arg.length
end

def method_1_38(arg)
  arg.length
end

def method_1_39(arg)
  arg.length
end
`,
  "build/parallel_10.rb": `# Test file 10

def method_10_0(arg)
  arg.length
end

def method_10_1(arg)
  arg.length
end

def method_10_2(arg)
  arg.length
end

def method_10_3(arg)
  arg.length
end

def method_10_4(arg)
  arg.length
end

def method_10_5(arg)
  arg.length
end

def method_10_6(arg)
  arg.length
end

def method_10_7(arg)
  arg.length
end

def method_10_8(arg)
  arg.length
end

def method_10_9(arg)
  arg.length
end

def method_10_10(arg)
  arg.length
end

def method_10_11(arg)
  arg.length
end

def method_10_12(arg)
  arg.length
end

def method_10_13(arg)
  arg.length
end

def method_10_14(arg)
  arg.length
end

def method_10_15(arg)
  arg.length
end

def method_10_16(arg)
  arg.length
end

def method_10_17(arg)
  arg.length
end

def method_10_18(arg)
  arg.length
end

def method_10_19(arg)
  arg.length
end

def method_10_20(arg)
  arg.length
end

def method_10_21(arg)
  arg.length
end

def method_10_22(arg)
  arg.length
end

def method_10_23(arg)
  arg.length
end

def method_10_24(arg)
  arg.length
end

def method_10_25(arg)
  arg.length
end

def method_10_26(arg)
  arg.length
end

def method_10_27(arg)
  arg.length
end

def method_10_28(arg)
  arg.length
end

def method_10_29(arg)
  arg.length
end

def method_10_30(arg)
  arg.length
end

def method_10_31(arg)
  arg.length
end

def method_10_32(arg)
  arg.length
end

def method_10_33(arg)
  arg.length
end

def method_10_34(arg)
  arg.length
end

def method_10_35(arg)
  arg.length
end

def method_10_36(arg)
  arg.length
end

def method_10_37(arg)
  arg.length
end

def method_10_38(arg)
  arg.length
end

def method_10_39(arg)
  arg.length
end
`,
  "build/parallel_11.rb": `# Test file 11

def method_11_0(arg)
  arg.length
end

def method_11_1(arg)
  arg.length
end

def method_11_2(arg)
  arg.length
end

def method_11_3(arg)
  arg.length
end

def method_11_4(arg)
  arg.length
end

def method_11_5(arg)
  arg.length
end

def method_11_6(arg)
  arg.length
end

def method_11_7(arg)
  arg.length
end

def method_11_8(arg)
  arg.length
end

def method_11_9(arg)
  arg.length
end

def method_11_10(arg)
  arg.length
end

def method_11_11(arg)
  arg.length
end

def method_11_12(arg)
  arg.length
end

def method_11_13(arg)
  arg.length
end

def method_11_14(arg)
  arg.length
end

def method_11_15(arg)
  arg.length
end

def method_11_16(arg)
  arg.length
end

def method_11_17(arg)
  arg.length
end

def method_11_18(arg)
  arg.length
end

def method_11_19(arg)
  arg.length
end

def method_11_20(arg)
  arg.length
end

def method_11_21(arg)
  arg.length
end

def method_11_22(arg)
  arg.length
end

def method_11_23(arg)
  arg.length
end

def method_11_24(arg)
  arg.length
end

def method_11_25(arg)
  arg.length
end

def method_11_26(arg)
  arg.length
end

def method_11_27(arg)
  arg.length
end

def method_11_28(arg)
  arg.length
end

def method_11_29(arg)
  arg.length
end

def method_11_30(arg)
  arg.length
end

def method_11_31(arg)
  arg.length
end

def method_11_32(arg)
  arg.length
end

def method_11_33(arg)
  arg.length
end

def method_11_34(arg)
  arg.length
end

def method_11_35(arg)
  arg.length
end

def method_11_36(arg)
  arg.length
end

def method_11_37(arg)
  arg.length
end

def method_11_38(arg)
  arg.length
end

def method_11_39(arg)
  arg.length
end
`,
  "build/parallel_12.rb": `# Test file 12

def method_12_0(arg)
  arg.length
end

def method_12_1(arg)
  arg.length
end

def method_12_2(arg)
  arg.length
end

def method_12_3(arg)
  arg.length
end

def method_12_4(arg)
  arg.length
end

def method_12_5(arg)
  arg.length
end

def method_12_6(arg)
  arg.length
end

def method_12_7(arg)
  arg.length
end

def method_12_8(arg)
  arg.length
end

def method_12_9(arg)
  arg.length
end

def method_12_10(arg)
  arg.length
end

def method_12_11(arg)
  arg.length
end

def method_12_12(arg)
  arg.length
end

def method_12_13(arg)
  arg.length
end

def method_12_14(arg)
  arg.length
end

def method_12_15(arg)
  arg.length
end

def method_12_16(arg)
  arg.length
end

def method_12_17(arg)
  arg.length
end

def method_12_18(arg)
  arg.length
end

def method_12_19(arg)
  arg.length
end

def method_12_20(arg)
  arg.length
end

def method_12_21(arg)
  arg.length
end

def method_12_22(arg)
  arg.length
end

def method_12_23(arg)
  arg.length
end

def method_12_24(arg)
  arg.length
end

def method_12_25(arg)
  arg.length
end

def method_12_26(arg)
  arg.length
end

def method_12_27(arg)
  arg.length
end

def method_12_28(arg)
  arg.length
end

def method_12_29(arg)
  arg.length
end

def method_12_30(arg)
  arg.length
end

def method_12_31(arg)
  arg.length
end

def method_12_32(arg)
  arg.length
end

def method_12_33(arg)
  arg.length
end

def method_12_34(arg)
  arg.length
end

def method_12_35(arg)
  arg.length
end

def method_12_36(arg)
  arg.length
end

def method_12_37(arg)
  arg.length
end

def method_12_38(arg)
  arg.length
end

def method_12_39(arg)
  arg.length
end
`,
  "build/parallel_13.rb": `# Test file 13

def method_13_0(arg)
  arg.length
end

def method_13_1(arg)
  arg.length
end

def method_13_2(arg)
  arg.length
end

def method_13_3(arg)
  arg.length
end

def method_13_4(arg)
  arg.length
end

def method_13_5(arg)
  arg.length
end

def method_13_6(arg)
  arg.length
end

def method_13_7(arg)
  arg.length
end

def method_13_8(arg)
  arg.length
end

def method_13_9(arg)
  arg.length
end

def method_13_10(arg)
  arg.length
end

def method_13_11(arg)
  arg.length
end

def method_13_12(arg)
  arg.length
end

def method_13_13(arg)
  arg.length
end

def method_13_14(arg)
  arg.length
end

def method_13_15(arg)
  arg.length
end

def method_13_16(arg)
  arg.length
end

def method_13_17(arg)
  arg.length
end

def method_13_18(arg)
  arg.length
end

def method_13_19(arg)
  arg.length
end

def method_13_20(arg)
  arg.length
end

def method_13_21(arg)
  arg.length
end

def method_13_22(arg)
  arg.length
end

def method_13_23(arg)
  arg.length
end

def method_13_24(arg)
  arg.length
end

def method_13_25(arg)
  arg.length
end

def method_13_26(arg)
  arg.length
end

def method_13_27(arg)
  arg.length
end

def method_13_28(arg)
  arg.length
end

def method_13_29(arg)
  arg.length
end

def method_13_30(arg)
  arg.length
end

def method_13_31(arg)
  arg.length
end

def method_13_32(arg)
  arg.length
end

def method_13_33(arg)
  arg.length
end

def method_13_34(arg)
  arg.length
end

def method_13_35(arg)
  arg.length
end

def method_13_36(arg)
  arg.length
end

def method_13_37(arg)
  arg.length
end

def method_13_38(arg)
  arg.length
end

def method_13_39(arg)
  arg.length
end
`,
  "build/parallel_14.rb": `# Test file 14

def method_14_0(arg)
  arg.length
end

def method_14_1(arg)
  arg.length
end

def method_14_2(arg)
  arg.length
end

def method_14_3(arg)
  arg.length
end

def method_14_4(arg)
  arg.length
end

def method_14_5(arg)
  arg.length
end

def method_14_6(arg)
  arg.length
end

def method_14_7(arg)
  arg.length
end

def method_14_8(arg)
  arg.length
end

def method_14_9(arg)
  arg.length
end

def method_14_10(arg)
  arg.length
end

def method_14_11(arg)
  arg.length
end

def method_14_12(arg)
  arg.length
end

def method_14_13(arg)
  arg.length
end

def method_14_14(arg)
  arg.length
end

def method_14_15(arg)
  arg.length
end

def method_14_16(arg)
  arg.length
end

def method_14_17(arg)
  arg.length
end

def method_14_18(arg)
  arg.length
end

def method_14_19(arg)
  arg.length
end

def method_14_20(arg)
  arg.length
end

def method_14_21(arg)
  arg.length
end

def method_14_22(arg)
  arg.length
end

def method_14_23(arg)
  arg.length
end

def method_14_24(arg)
  arg.length
end

def method_14_25(arg)
  arg.length
end

def method_14_26(arg)
  arg.length
end

def method_14_27(arg)
  arg.length
end

def method_14_28(arg)
  arg.length
end

def method_14_29(arg)
  arg.length
end

def method_14_30(arg)
  arg.length
end

def method_14_31(arg)
  arg.length
end

def method_14_32(arg)
  arg.length
end

def method_14_33(arg)
  arg.length
end

def method_14_34(arg)
  arg.length
end

def method_14_35(arg)
  arg.length
end

def method_14_36(arg)
  arg.length
end

def method_14_37(arg)
  arg.length
end

def method_14_38(arg)
  arg.length
end

def method_14_39(arg)
  arg.length
end
`,
  "build/parallel_15.rb": `# Test file 15

def method_15_0(arg)
  arg.length
end

def method_15_1(arg)
  arg.length
end

def method_15_2(arg)
  arg.length
end

def method_15_3(arg)
  arg.length
end

def method_15_4(arg)
  arg.length
end

def method_15_5(arg)
  arg.length
end

def method_15_6(arg)
  arg.length
end

def method_15_7(arg)
  arg.length
end

def method_15_8(arg)
  arg.length
end

def method_15_9(arg)
  arg.length
end

def method_15_10(arg)
  arg.length
end

def method_15_11(arg)
  arg.length
end

def method_15_12(arg)
  arg.length
end

def method_15_13(arg)
  arg.length
end

def method_15_14(arg)
  arg.length
end

def method_15_15(arg)
  arg.length
end

def method_15_16(arg)
  arg.length
end

def method_15_17(arg)
  arg.length
end

def method_15_18(arg)
  arg.length
end

def method_15_19(arg)
  arg.length
end

def method_15_20(arg)
  arg.length
end

def method_15_21(arg)
  arg.length
end

def method_15_22(arg)
  arg.length
end

def method_15_23(arg)
  arg.length
end

def method_15_24(arg)
  arg.length
end

def method_15_25(arg)
  arg.length
end

def method_15_26(arg)
  arg.length
end

def method_15_27(arg)
  arg.length
end

def method_15_28(arg)
  arg.length
end

def method_15_29(arg)
  arg.length
end

def method_15_30(arg)
  arg.length
end

def method_15_31(arg)
  arg.length
end

def method_15_32(arg)
  arg.length
end

def method_15_33(arg)
  arg.length
end

def method_15_34(arg)
  arg.length
end

def method_15_35(arg)
  arg.length
end

def method_15_36(arg)
  arg.length
end

def method_15_37(arg)
  arg.length
end

def method_15_38(arg)
  arg.length
end

def method_15_39(arg)
  arg.length
end
`,
  "build/parallel_16.rb": `# Test file 16

def method_16_0(arg)
  arg.length
end

def method_16_1(arg)
  arg.length
end

def method_16_2(arg)
  arg.length
end

def method_16_3(arg)
  arg.length
end

def method_16_4(arg)
  arg.length
end

def method_16_5(arg)
  arg.length
end

def method_16_6(arg)
  arg.length
end

def method_16_7(arg)
  arg.length
end

def method_16_8(arg)
  arg.length
end

def method_16_9(arg)
  arg.length
end

def method_16_10(arg)
  arg.length
end

def method_16_11(arg)
  arg.length
end

def method_16_12(arg)
  arg.length
end

def method_16_13(arg)
  arg.length
end

def method_16_14(arg)
  arg.length
end

def method_16_15(arg)
  arg.length
end

def method_16_16(arg)
  arg.length
end

def method_16_17(arg)
  arg.length
end

def method_16_18(arg)
  arg.length
end

def method_16_19(arg)
  arg.length
end

def method_16_20(arg)
  arg.length
end

def method_16_21(arg)
  arg.length
end

def method_16_22(arg)
  arg.length
end

def method_16_23(arg)
  arg.length
end

def method_16_24(arg)
  arg.length
end

def method_16_25(arg)
  arg.length
end

def method_16_26(arg)
  arg.length
end

def method_16_27(arg)
  arg.length
end

def method_16_28(arg)
  arg.length
end

def method_16_29(arg)
  arg.length
end

def method_16_30(arg)
  arg.length
end

def method_16_31(arg)
  arg.length
end

def method_16_32(arg)
  arg.length
end

def method_16_33(arg)
  arg.length
end

def method_16_34(arg)
  arg.length
end

def method_16_35(arg)
  arg.length
end

def method_16_36(arg)
  arg.length
end

def method_16_37(arg)
  arg.length
end

def method_16_38(arg)
  arg.length
end

def method_16_39(arg)
  arg.length
end
`,
  "build/parallel_17.rb": `# Test file 17

def method_17_0(arg)
  arg.length
end

def method_17_1(arg)
  arg.length
end

def method_17_2(arg)
  arg.length
end

def method_17_3(arg)
  arg.length
end

def method_17_4(arg)
  arg.length
end

def method_17_5(arg)
  arg.length
end

def method_17_6(arg)
  arg.length
end

def method_17_7(arg)
  arg.length
end

def method_17_8(arg)
  arg.length
end

def method_17_9(arg)
  arg.length
end

def method_17_10(arg)
  arg.length
end

def method_17_11(arg)
  arg.length
end

def method_17_12(arg)
  arg.length
end

def method_17_13(arg)
  arg.length
end

def method_17_14(arg)
  arg.length
end

def method_17_15(arg)
  arg.length
end

def method_17_16(arg)
  arg.length
end

def method_17_17(arg)
  arg.length
end

def method_17_18(arg)
  arg.length
end

def method_17_19(arg)
  arg.length
end

def method_17_20(arg)
  arg.length
end

def method_17_21(arg)
  arg.length
end

def method_17_22(arg)
  arg.length
end

def method_17_23(arg)
  arg.length
end

def method_17_24(arg)
  arg.length
end

def method_17_25(arg)
  arg.length
end

def method_17_26(arg)
  arg.length
end

def method_17_27(arg)
  arg.length
end

def method_17_28(arg)
  arg.length
end

def method_17_29(arg)
  arg.length
end

def method_17_30(arg)
  arg.length
end

def method_17_31(arg)
  arg.length
end

def method_17_32(arg)
  arg.length
end

def method_17_33(arg)
  arg.length
end

def method_17_34(arg)
  arg.length
end

def method_17_35(arg)
  arg.length
end

def method_17_36(arg)
  arg.length
end

def method_17_37(arg)
  arg.length
end

def method_17_38(arg)
  arg.length
end

def method_17_39(arg)
  arg.length
end
`,
  "build/parallel_18.rb": `# Test file 18

def method_18_0(arg)
  arg.length
end

def method_18_1(arg)
  arg.length
end

def method_18_2(arg)
  arg.length
end

def method_18_3(arg)
  arg.length
end

def method_18_4(arg)
  arg.length
end

def method_18_5(arg)
  arg.length
end

def method_18_6(arg)
  arg.length
end

def method_18_7(arg)
  arg.length
end

def method_18_8(arg)
  arg.length
end

def method_18_9(arg)
  arg.length
end

def method_18_10(arg)
  arg.length
end

def method_18_11(arg)
  arg.length
end

def method_18_12(arg)
  arg.length
end

def method_18_13(arg)
  arg.length
end

def method_18_14(arg)
  arg.length
end

def method_18_15(arg)
  arg.length
end

def method_18_16(arg)
  arg.length
end

def method_18_17(arg)
  arg.length
end

def method_18_18(arg)
  arg.length
end

def method_18_19(arg)
  arg.length
end

def method_18_20(arg)
  arg.length
end

def method_18_21(arg)
  arg.length
end

def method_18_22(arg)
  arg.length
end

def method_18_23(arg)
  arg.length
end

def method_18_24(arg)
  arg.length
end

def method_18_25(arg)
  arg.length
end

def method_18_26(arg)
  arg.length
end

def method_18_27(arg)
  arg.length
end

def method_18_28(arg)
  arg.length
end

def method_18_29(arg)
  arg.length
end

def method_18_30(arg)
  arg.length
end

def method_18_31(arg)
  arg.length
end

def method_18_32(arg)
  arg.length
end

def method_18_33(arg)
  arg.length
end

def method_18_34(arg)
  arg.length
end

def method_18_35(arg)
  arg.length
end

def method_18_36(arg)
  arg.length
end

def method_18_37(arg)
  arg.length
end

def method_18_38(arg)
  arg.length
end

def method_18_39(arg)
  arg.length
end
`,
  "build/parallel_19.rb": `# Test file 19

def method_19_0(arg)
  arg.length
end

def method_19_1(arg)
  arg.length
end

def method_19_2(arg)
  arg.length
end

def method_19_3(arg)
  arg.length
end

def method_19_4(arg)
  arg.length
end

def method_19_5(arg)
  arg.length
end

def method_19_6(arg)
  arg.length
end

def method_19_7(arg)
  arg.length
end

def method_19_8(arg)
  arg.length
end

def method_19_9(arg)
  arg.length
end

def method_19_10(arg)
  arg.length
end

def method_19_11(arg)
  arg.length
end

def method_19_12(arg)
  arg.length
end

def method_19_13(arg)
  arg.length
end

def method_19_14(arg)
  arg.length
end

def method_19_15(arg)
  arg.length
end

def method_19_16(arg)
  arg.length
end

def method_19_17(arg)
  arg.length
end

def method_19_18(arg)
  arg.length
end

def method_19_19(arg)
  arg.length
end

def method_19_20(arg)
  arg.length
end

def method_19_21(arg)
  arg.length
end

def method_19_22(arg)
  arg.length
end

def method_19_23(arg)
  arg.length
end

def method_19_24(arg)
  arg.length
end

def method_19_25(arg)
  arg.length
end

def method_19_26(arg)
  arg.length
end

def method_19_27(arg)
  arg.length
end

def method_19_28(arg)
  arg.length
end

def method_19_29(arg)
  arg.length
end

def method_19_30(arg)
  arg.length
end

def method_19_31(arg)
  arg.length
end

def method_19_32(arg)
  arg.length
end

def method_19_33(arg)
  arg.length
end

def method_19_34(arg)
  arg.length
end

def method_19_35(arg)
  arg.length
end

def method_19_36(arg)
  arg.length
end

def method_19_37(arg)
  arg.length
end

def method_19_38(arg)
  arg.length
end

def method_19_39(arg)
  arg.length
end
`,
  "build/parallel_2.rb": `# Test file 2

def method_2_0(arg)
  arg.length
end

def method_2_1(arg)
  arg.length
end

def method_2_2(arg)
  arg.length
end

def method_2_3(arg)
  arg.length
end

def method_2_4(arg)
  arg.length
end

def method_2_5(arg)
  arg.length
end

def method_2_6(arg)
  arg.length
end

def method_2_7(arg)
  arg.length
end

def method_2_8(arg)
  arg.length
end

def method_2_9(arg)
  arg.length
end

def method_2_10(arg)
  arg.length
end

def method_2_11(arg)
  arg.length
end

def method_2_12(arg)
  arg.length
end

def method_2_13(arg)
  arg.length
end

def method_2_14(arg)
  arg.length
end

def method_2_15(arg)
  arg.length
end

def method_2_16(arg)
  arg.length
end

def method_2_17(arg)
  arg.length
end

def method_2_18(arg)
  arg.length
end

def method_2_19(arg)
  arg.length
end

def method_2_20(arg)
  arg.length
end

def method_2_21(arg)
  arg.length
end

def method_2_22(arg)
  arg.length
end

def method_2_23(arg)
  arg.length
end

def method_2_24(arg)
  arg.length
end

def method_2_25(arg)
  arg.length
end

def method_2_26(arg)
  arg.length
end

def method_2_27(arg)
  arg.length
end

def method_2_28(arg)
  arg.length
end

def method_2_29(arg)
  arg.length
end

def method_2_30(arg)
  arg.length
end

def method_2_31(arg)
  arg.length
end

def method_2_32(arg)
  arg.length
end

def method_2_33(arg)
  arg.length
end

def method_2_34(arg)
  arg.length
end

def method_2_35(arg)
  arg.length
end

def method_2_36(arg)
  arg.length
end

def method_2_37(arg)
  arg.length
end

def method_2_38(arg)
  arg.length
end

def method_2_39(arg)
  arg.length
end
`,
  "build/parallel_3.rb": `# Test file 3

def method_3_0(arg)
  arg.length
end

def method_3_1(arg)
  arg.length
end

def method_3_2(arg)
  arg.length
end

def method_3_3(arg)
  arg.length
end

def method_3_4(arg)
  arg.length
end

def method_3_5(arg)
  arg.length
end

def method_3_6(arg)
  arg.length
end

def method_3_7(arg)
  arg.length
end

def method_3_8(arg)
  arg.length
end

def method_3_9(arg)
  arg.length
end

def method_3_10(arg)
  arg.length
end

def method_3_11(arg)
  arg.length
end

def method_3_12(arg)
  arg.length
end

def method_3_13(arg)
  arg.length
end

def method_3_14(arg)
  arg.length
end

def method_3_15(arg)
  arg.length
end

def method_3_16(arg)
  arg.length
end

def method_3_17(arg)
  arg.length
end

def method_3_18(arg)
  arg.length
end

def method_3_19(arg)
  arg.length
end

def method_3_20(arg)
  arg.length
end

def method_3_21(arg)
  arg.length
end

def method_3_22(arg)
  arg.length
end

def method_3_23(arg)
  arg.length
end

def method_3_24(arg)
  arg.length
end

def method_3_25(arg)
  arg.length
end

def method_3_26(arg)
  arg.length
end

def method_3_27(arg)
  arg.length
end

def method_3_28(arg)
  arg.length
end

def method_3_29(arg)
  arg.length
end

def method_3_30(arg)
  arg.length
end

def method_3_31(arg)
  arg.length
end

def method_3_32(arg)
  arg.length
end

def method_3_33(arg)
  arg.length
end

def method_3_34(arg)
  arg.length
end

def method_3_35(arg)
  arg.length
end

def method_3_36(arg)
  arg.length
end

def method_3_37(arg)
  arg.length
end

def method_3_38(arg)
  arg.length
end

def method_3_39(arg)
  arg.length
end
`,
  "build/parallel_4.rb": `# Test file 4

def method_4_0(arg)
  arg.length
end

def method_4_1(arg)
  arg.length
end

def method_4_2(arg)
  arg.length
end

def method_4_3(arg)
  arg.length
end

def method_4_4(arg)
  arg.length
end

def method_4_5(arg)
  arg.length
end

def method_4_6(arg)
  arg.length
end

def method_4_7(arg)
  arg.length
end

def method_4_8(arg)
  arg.length
end

def method_4_9(arg)
  arg.length
end

def method_4_10(arg)
  arg.length
end

def method_4_11(arg)
  arg.length
end

def method_4_12(arg)
  arg.length
end

def method_4_13(arg)
  arg.length
end

def method_4_14(arg)
  arg.length
end

def method_4_15(arg)
  arg.length
end

def method_4_16(arg)
  arg.length
end

def method_4_17(arg)
  arg.length
end

def method_4_18(arg)
  arg.length
end

def method_4_19(arg)
  arg.length
end

def method_4_20(arg)
  arg.length
end

def method_4_21(arg)
  arg.length
end

def method_4_22(arg)
  arg.length
end

def method_4_23(arg)
  arg.length
end

def method_4_24(arg)
  arg.length
end

def method_4_25(arg)
  arg.length
end

def method_4_26(arg)
  arg.length
end

def method_4_27(arg)
  arg.length
end

def method_4_28(arg)
  arg.length
end

def method_4_29(arg)
  arg.length
end

def method_4_30(arg)
  arg.length
end

def method_4_31(arg)
  arg.length
end

def method_4_32(arg)
  arg.length
end

def method_4_33(arg)
  arg.length
end

def method_4_34(arg)
  arg.length
end

def method_4_35(arg)
  arg.length
end

def method_4_36(arg)
  arg.length
end

def method_4_37(arg)
  arg.length
end

def method_4_38(arg)
  arg.length
end

def method_4_39(arg)
  arg.length
end
`,
  "build/parallel_5.rb": `# Test file 5

def method_5_0(arg)
  arg.length
end

def method_5_1(arg)
  arg.length
end

def method_5_2(arg)
  arg.length
end

def method_5_3(arg)
  arg.length
end

def method_5_4(arg)
  arg.length
end

def method_5_5(arg)
  arg.length
end

def method_5_6(arg)
  arg.length
end

def method_5_7(arg)
  arg.length
end

def method_5_8(arg)
  arg.length
end

def method_5_9(arg)
  arg.length
end

def method_5_10(arg)
  arg.length
end

def method_5_11(arg)
  arg.length
end

def method_5_12(arg)
  arg.length
end

def method_5_13(arg)
  arg.length
end

def method_5_14(arg)
  arg.length
end

def method_5_15(arg)
  arg.length
end

def method_5_16(arg)
  arg.length
end

def method_5_17(arg)
  arg.length
end

def method_5_18(arg)
  arg.length
end

def method_5_19(arg)
  arg.length
end

def method_5_20(arg)
  arg.length
end

def method_5_21(arg)
  arg.length
end

def method_5_22(arg)
  arg.length
end

def method_5_23(arg)
  arg.length
end

def method_5_24(arg)
  arg.length
end

def method_5_25(arg)
  arg.length
end

def method_5_26(arg)
  arg.length
end

def method_5_27(arg)
  arg.length
end

def method_5_28(arg)
  arg.length
end

def method_5_29(arg)
  arg.length
end

def method_5_30(arg)
  arg.length
end

def method_5_31(arg)
  arg.length
end

def method_5_32(arg)
  arg.length
end

def method_5_33(arg)
  arg.length
end

def method_5_34(arg)
  arg.length
end

def method_5_35(arg)
  arg.length
end

def method_5_36(arg)
  arg.length
end

def method_5_37(arg)
  arg.length
end

def method_5_38(arg)
  arg.length
end

def method_5_39(arg)
  arg.length
end
`,
  "build/parallel_6.rb": `# Test file 6

def method_6_0(arg)
  arg.length
end

def method_6_1(arg)
  arg.length
end

def method_6_2(arg)
  arg.length
end

def method_6_3(arg)
  arg.length
end

def method_6_4(arg)
  arg.length
end

def method_6_5(arg)
  arg.length
end

def method_6_6(arg)
  arg.length
end

def method_6_7(arg)
  arg.length
end

def method_6_8(arg)
  arg.length
end

def method_6_9(arg)
  arg.length
end

def method_6_10(arg)
  arg.length
end

def method_6_11(arg)
  arg.length
end

def method_6_12(arg)
  arg.length
end

def method_6_13(arg)
  arg.length
end

def method_6_14(arg)
  arg.length
end

def method_6_15(arg)
  arg.length
end

def method_6_16(arg)
  arg.length
end

def method_6_17(arg)
  arg.length
end

def method_6_18(arg)
  arg.length
end

def method_6_19(arg)
  arg.length
end

def method_6_20(arg)
  arg.length
end

def method_6_21(arg)
  arg.length
end

def method_6_22(arg)
  arg.length
end

def method_6_23(arg)
  arg.length
end

def method_6_24(arg)
  arg.length
end

def method_6_25(arg)
  arg.length
end

def method_6_26(arg)
  arg.length
end

def method_6_27(arg)
  arg.length
end

def method_6_28(arg)
  arg.length
end

def method_6_29(arg)
  arg.length
end

def method_6_30(arg)
  arg.length
end

def method_6_31(arg)
  arg.length
end

def method_6_32(arg)
  arg.length
end

def method_6_33(arg)
  arg.length
end

def method_6_34(arg)
  arg.length
end

def method_6_35(arg)
  arg.length
end

def method_6_36(arg)
  arg.length
end

def method_6_37(arg)
  arg.length
end

def method_6_38(arg)
  arg.length
end

def method_6_39(arg)
  arg.length
end
`,
  "build/parallel_7.rb": `# Test file 7

def method_7_0(arg)
  arg.length
end

def method_7_1(arg)
  arg.length
end

def method_7_2(arg)
  arg.length
end

def method_7_3(arg)
  arg.length
end

def method_7_4(arg)
  arg.length
end

def method_7_5(arg)
  arg.length
end

def method_7_6(arg)
  arg.length
end

def method_7_7(arg)
  arg.length
end

def method_7_8(arg)
  arg.length
end

def method_7_9(arg)
  arg.length
end

def method_7_10(arg)
  arg.length
end

def method_7_11(arg)
  arg.length
end

def method_7_12(arg)
  arg.length
end

def method_7_13(arg)
  arg.length
end

def method_7_14(arg)
  arg.length
end

def method_7_15(arg)
  arg.length
end

def method_7_16(arg)
  arg.length
end

def method_7_17(arg)
  arg.length
end

def method_7_18(arg)
  arg.length
end

def method_7_19(arg)
  arg.length
end

def method_7_20(arg)
  arg.length
end

def method_7_21(arg)
  arg.length
end

def method_7_22(arg)
  arg.length
end

def method_7_23(arg)
  arg.length
end

def method_7_24(arg)
  arg.length
end

def method_7_25(arg)
  arg.length
end

def method_7_26(arg)
  arg.length
end

def method_7_27(arg)
  arg.length
end

def method_7_28(arg)
  arg.length
end

def method_7_29(arg)
  arg.length
end

def method_7_30(arg)
  arg.length
end

def method_7_31(arg)
  arg.length
end

def method_7_32(arg)
  arg.length
end

def method_7_33(arg)
  arg.length
end

def method_7_34(arg)
  arg.length
end

def method_7_35(arg)
  arg.length
end

def method_7_36(arg)
  arg.length
end

def method_7_37(arg)
  arg.length
end

def method_7_38(arg)
  arg.length
end

def method_7_39(arg)
  arg.length
end
`,
  "build/parallel_8.rb": `# Test file 8

def method_8_0(arg)
  arg.length
end

def method_8_1(arg)
  arg.length
end

def method_8_2(arg)
  arg.length
end

def method_8_3(arg)
  arg.length
end

def method_8_4(arg)
  arg.length
end

def method_8_5(arg)
  arg.length
end

def method_8_6(arg)
  arg.length
end

def method_8_7(arg)
  arg.length
end

def method_8_8(arg)
  arg.length
end

def method_8_9(arg)
  arg.length
end

def method_8_10(arg)
  arg.length
end

def method_8_11(arg)
  arg.length
end

def method_8_12(arg)
  arg.length
end

def method_8_13(arg)
  arg.length
end

def method_8_14(arg)
  arg.length
end

def method_8_15(arg)
  arg.length
end

def method_8_16(arg)
  arg.length
end

def method_8_17(arg)
  arg.length
end

def method_8_18(arg)
  arg.length
end

def method_8_19(arg)
  arg.length
end

def method_8_20(arg)
  arg.length
end

def method_8_21(arg)
  arg.length
end

def method_8_22(arg)
  arg.length
end

def method_8_23(arg)
  arg.length
end

def method_8_24(arg)
  arg.length
end

def method_8_25(arg)
  arg.length
end

def method_8_26(arg)
  arg.length
end

def method_8_27(arg)
  arg.length
end

def method_8_28(arg)
  arg.length
end

def method_8_29(arg)
  arg.length
end

def method_8_30(arg)
  arg.length
end

def method_8_31(arg)
  arg.length
end

def method_8_32(arg)
  arg.length
end

def method_8_33(arg)
  arg.length
end

def method_8_34(arg)
  arg.length
end

def method_8_35(arg)
  arg.length
end

def method_8_36(arg)
  arg.length
end

def method_8_37(arg)
  arg.length
end

def method_8_38(arg)
  arg.length
end

def method_8_39(arg)
  arg.length
end
`,
  "build/parallel_9.rb": `# Test file 9

def method_9_0(arg)
  arg.length
end

def method_9_1(arg)
  arg.length
end

def method_9_2(arg)
  arg.length
end

def method_9_3(arg)
  arg.length
end

def method_9_4(arg)
  arg.length
end

def method_9_5(arg)
  arg.length
end

def method_9_6(arg)
  arg.length
end

def method_9_7(arg)
  arg.length
end

def method_9_8(arg)
  arg.length
end

def method_9_9(arg)
  arg.length
end

def method_9_10(arg)
  arg.length
end

def method_9_11(arg)
  arg.length
end

def method_9_12(arg)
  arg.length
end

def method_9_13(arg)
  arg.length
end

def method_9_14(arg)
  arg.length
end

def method_9_15(arg)
  arg.length
end

def method_9_16(arg)
  arg.length
end

def method_9_17(arg)
  arg.length
end

def method_9_18(arg)
  arg.length
end

def method_9_19(arg)
  arg.length
end

def method_9_20(arg)
  arg.length
end

def method_9_21(arg)
  arg.length
end

def method_9_22(arg)
  arg.length
end

def method_9_23(arg)
  arg.length
end

def method_9_24(arg)
  arg.length
end

def method_9_25(arg)
  arg.length
end

def method_9_26(arg)
  arg.length
end

def method_9_27(arg)
  arg.length
end

def method_9_28(arg)
  arg.length
end

def method_9_29(arg)
  arg.length
end

def method_9_30(arg)
  arg.length
end

def method_9_31(arg)
  arg.length
end

def method_9_32(arg)
  arg.length
end

def method_9_33(arg)
  arg.length
end

def method_9_34(arg)
  arg.length
end

def method_9_35(arg)
  arg.length
end

def method_9_36(arg)
  arg.length
end

def method_9_37(arg)
  arg.length
end

def method_9_38(arg)
  arg.length
end

def method_9_39(arg)
  arg.length
end
`,
  "build/parse_error.rb": `def foo(: String)
  "hello"
end`,
  "build/script.rb": `def greet(person)
  puts "Hello, #{person}!"
end

greet("world")
`,
  "build/script123.rb": `puts 'test'`,
  "build/syntax_error.rb": `def foo(: String)
  "hello"
end
`,
  "build/tasks.rb": `def get_task(id)
  nil
end

def update_status(task, status)
  task
end
`,
  "build/test.rb": `puts 'test'`,
  "build/test20251229-46125-v5j1tv.rb": `def 함수명 자체가 올바르지_않은_경우 (n: Integer, s: String)
    n
end
`,
  "build/test20251229-47581-5m1ofg.rb": `def 함수명 자체가 올바르지_않은_경우 (n: Integer, s: String)
    n
end
`,
  "build/test_bool.rb": `def is_valid()
  true
end
`,
  "build/test_boolean.rb": `def is_valid()
  true
end
`,
  "build/test_err.rb": `def foo(: String); end
`,
  "build/test_scan_err.rb": `"unterminated string
`,
  "build/type_error.rb": `def greet(name)
  name
end

greet(123)
`,
  "build/type_error_test.rb": `class HelloWorld
    def initialize(name)
        @name = name
    end

    def greet()
        "Hello, #{@name}!"
    end

    def 조건문으로_인해_유니온_타입_추론_테스트(name)
        return true

        if name == "asdf"
            nil
        elsif name.length > 10
            name.length
        else
            name
        end
    end
end
`,
  "build/types.rb": ``,
  "build/valid.rb": `def hello
  puts 'hi'
end`,
  "build/world.rb": `class HelloWorld
    def initialize(name)
        @name = name
    end

    def greet()
        "Hello, #{@name}!"
    end

    def return_sign_untyped_method_should_infer_return_type(name)
        "asdf1234!="
    end

    def 비_영어_함수명___테스트1!(name)
        "asdf1234!="
    end

    def 조건문으로_인해_유니온_타입_추론_테스트(name)
        return true

        if name == "asdf"
            nil
        elsif name.length > 10
            name.length
        else
            name
        end
    end

    private def private_method_example
        0
    end
end

puts HelloWorld.new("World").greet()

# parsing visibility modifiers
## with private def

### parses private def in class
class Example
    private def secret(x)
        x.length
    end
end

### parses private def at top level
private def helper(x)
    x.upcase
end

# 정상
def t1
    1
end

# 에러 : 콜론은 기본적으로 함수명과 공백없이 붙어있어야 합니다.
def t1_콜론과_함수명_사이에_공백_불허
    1
end

# 에러 : 콜론과 타입 사이에는 최소 1개의 공백이 필요합니다.
def t1_콜론과_함수명_사이에_공백_불허
    1
end

# 에러 : 콜론 앞 '함수명' 이라 함은, 인자를 정의하는 소괄호가 있다면 그 소괄호의 닫힘까지를 '함수명' 으로 부르기로 합니다. 즉, 소괄호 닫힘문자와 콜론은 반드시 공백없이 붙어있어야 합니다.
def t1_콜론과_함수명_사이에_공백_불허_괄호있음()
    1
end

# 에러 : 위와 마찬가지인데, 인자 정의부에 내용이 좀 더 추가된 형태입니다.
def t1_콜론과_함수명_사이에_공백_불허_괄호 내에 공백 있음(n: Integer, s: String)
    n
end
`,
  "lib/t_ruby/ast_type_inferrer.rb": `# frozen_string_literal: true

module TRuby
  # ASTTypeInferrer - TypeScript 스타일 정적 타입 추론 엔진
  # IR 노드를 순회하면서 타입을 추론하고 캐싱
  class ASTTypeInferrer
    # 리터럴 타입 매핑
    LITERAL_TYPE_MAP = {
      string: "String",
      integer: "Integer",
      float: "Float",
      boolean: "bool",
      symbol: "Symbol",
      nil: "nil",
      array: "Array[untyped]",
      hash: "Hash[untyped, untyped]",
    }.freeze

    # 산술 연산자 규칙 (피연산자 타입 → 결과 타입)
    ARITHMETIC_OPS = %w[+ - * / % **].freeze
    COMPARISON_OPS = %w[== != < > <= >= <=>].freeze
    LOGICAL_OPS = %w[&& ||].freeze

    # 내장 메서드 반환 타입
    BUILTIN_METHODS = {
      # String 메서드
      %w[String upcase] => "String",
      %w[String downcase] => "String",
      %w[String capitalize] => "String",
      %w[String reverse] => "String",
      %w[String strip] => "String",
      %w[String chomp] => "String",
      %w[String chop] => "String",
      %w[String gsub] => "String",
      %w[String sub] => "String",
      %w[String tr] => "String",
      %w[String to_s] => "String",
      %w[String to_str] => "String",
      %w[String to_sym] => "Symbol",
      %w[String to_i] => "Integer",
      %w[String to_f] => "Float",
      %w[String length] => "Integer",
      %w[String size] => "Integer",
      %w[String bytesize] => "Integer",
      %w[String empty?] => "bool",
      %w[String include?] => "bool",
      %w[String start_with?] => "bool",
      %w[String end_with?] => "bool",
      %w[String match?] => "bool",
      %w[String split] => "Array[String]",
      %w[String chars] => "Array[String]",
      %w[String bytes] => "Array[Integer]",
      %w[String lines] => "Array[String]",

      # Integer 메서드
      %w[Integer to_s] => "String",
      %w[Integer to_i] => "Integer",
      %w[Integer to_f] => "Float",
      %w[Integer abs] => "Integer",
      %w[Integer even?] => "bool",
      %w[Integer odd?] => "bool",
      %w[Integer zero?] => "bool",
      %w[Integer positive?] => "bool",
      %w[Integer negative?] => "bool",
      %w[Integer times] => "Integer",
      %w[Integer upto] => "Enumerator[Integer]",
      %w[Integer downto] => "Enumerator[Integer]",

      # Float 메서드
      %w[Float to_s] => "String",
      %w[Float to_i] => "Integer",
      %w[Float to_f] => "Float",
      %w[Float abs] => "Float",
      %w[Float ceil] => "Integer",
      %w[Float floor] => "Integer",
      %w[Float round] => "Integer",
      %w[Float truncate] => "Integer",
      %w[Float nan?] => "bool",
      %w[Float infinite?] => "Integer?",
      %w[Float finite?] => "bool",
      %w[Float zero?] => "bool",
      %w[Float positive?] => "bool",
      %w[Float negative?] => "bool",

      # Array 메서드
      %w[Array length] => "Integer",
      %w[Array size] => "Integer",
      %w[Array count] => "Integer",
      %w[Array empty?] => "bool",
      %w[Array any?] => "bool",
      %w[Array all?] => "bool",
      %w[Array none?] => "bool",
      %w[Array include?] => "bool",
      %w[Array reverse] => "Array[untyped]",
      %w[Array sort] => "Array[untyped]",
      %w[Array uniq] => "Array[untyped]",
      %w[Array compact] => "Array[untyped]",
      %w[Array flatten] => "Array[untyped]",
      %w[Array join] => "String",
      %w[Array to_s] => "String",
      %w[Array to_a] => "Array[untyped]",

      # Hash 메서드
      %w[Hash length] => "Integer",
      %w[Hash size] => "Integer",
      %w[Hash empty?] => "bool",
      %w[Hash key?] => "bool",
      %w[Hash has_key?] => "bool",
      %w[Hash value?] => "bool",
      %w[Hash has_value?] => "bool",
      %w[Hash include?] => "bool",
      %w[Hash keys] => "Array[untyped]",
      %w[Hash values] => "Array[untyped]",
      %w[Hash to_s] => "String",
      %w[Hash to_a] => "Array[untyped]",
      %w[Hash to_h] => "Hash[untyped, untyped]",

      # Object 메서드 (모든 타입에 적용)
      %w[Object to_s] => "String",
      %w[Object inspect] => "String",
      %w[Object class] => "Class",
      %w[Object is_a?] => "bool",
      %w[Object kind_of?] => "bool",
      %w[Object instance_of?] => "bool",
      %w[Object respond_to?] => "bool",
      %w[Object nil?] => "bool",
      %w[Object frozen?] => "bool",
      %w[Object dup] => "untyped",
      %w[Object clone] => "untyped",
      %w[Object freeze] => "self",
      %w[Object tap] => "self",
      %w[Object then] => "untyped",
      %w[Object yield_self] => "untyped",

      # Symbol 메서드
      %w[Symbol to_s] => "String",
      %w[Symbol to_sym] => "Symbol",
      %w[Symbol length] => "Integer",
      %w[Symbol size] => "Integer",
      %w[Symbol empty?] => "bool",
    }.freeze

    attr_reader :type_cache

    def initialize
      @type_cache = {} # 노드 → 타입 캐시 (TypeScript의 지연 평가)
    end

    # 표현식 타입 추론
    # @param node [IR::Node] IR 노드
    # @param env [TypeEnv] 타입 환경
    # @return [String, IR::TypeNode, nil] 추론된 타입
    def infer_expression(node, env)
      # 캐시 확인 (지연 평가)
      cache_key = node.object_id
      return @type_cache[cache_key] if @type_cache.key?(cache_key)

      type = case node
             when IR::Literal
               infer_literal(node)
             when IR::InterpolatedString
               "String" # Interpolated strings always produce String
             when IR::VariableRef
               infer_variable_ref(node, env)
             when IR::BinaryOp
               infer_binary_op(node, env)
             when IR::UnaryOp
               infer_unary_op(node, env)
             when IR::MethodCall
               infer_method_call(node, env)
             when IR::ArrayLiteral
               infer_array_literal(node, env)
             when IR::HashLiteral
               infer_hash_literal(node, env)
             when IR::Assignment
               infer_assignment(node, env)
             when IR::Conditional
               infer_conditional(node, env)
             when IR::Block
               infer_block(node, env)
             when IR::Return
               infer_return(node, env)
             when IR::RawCode
               "untyped"
             else
               "untyped"
             end

      @type_cache[cache_key] = type
      type
    end

    # 메서드 반환 타입 추론
    # @param method_node [IR::MethodDef] 메서드 정의 IR
    # @param class_env [TypeEnv, nil] 클래스 타입 환경
    # @return [String, IR::TypeNode, nil] 추론된 반환 타입
    def infer_method_return_type(method_node, class_env = nil)
      return nil unless method_node.body

      # 메서드 스코프 생성
      env = TypeEnv.new(class_env)

      # 파라미터 타입 등록
      method_node.params.each do |param|
        param_type = param.type_annotation&.to_rbs || "untyped"
        env.define(param.name, param_type)
      end

      # 본문에서 반환 타입 수집
      return_types, terminated = collect_return_types(method_node.body, env)

      # 암묵적 반환값 추론 (마지막 표현식) - 종료되지 않은 경우만
      unless terminated
        implicit_return = infer_implicit_return(method_node.body, env)
        return_types << implicit_return if implicit_return
      end

      # 타입 통합
      unify_types(return_types)
    end

    private

    # 리터럴 타입 추론
    def infer_literal(node)
      LITERAL_TYPE_MAP[node.literal_type] || "untyped"
    end

    # 변수 참조 타입 추론
    def infer_variable_ref(node, env)
      # 상수(클래스명)는 그 자체가 타입 (예: MyClass.new 호출 시)
      if node.scope == :constant || node.name.match?(/^[A-Z]/)
        return node.name
      end

      env.lookup(node.name) || "untyped"
    end

    # 이항 연산자 타입 추론
    def infer_binary_op(node, env)
      left_type = infer_expression(node.left, env)
      right_type = infer_expression(node.right, env)
      op = node.operator

      # 비교 연산자는 항상 bool
      return "bool" if COMPARISON_OPS.include?(op)

      # 논리 연산자
      if op == "&&"
        # && 는 falsy면 왼쪽, truthy면 오른쪽 반환
        return right_type # 단순화: 오른쪽 타입 반환
      end

      if op == "||"
        # || 는 truthy면 왼쪽, falsy면 오른쪽 반환
        return union_type(left_type, right_type)
      end

      # 산술 연산자
      if ARITHMETIC_OPS.include?(op)
        return infer_arithmetic_result(left_type, right_type, op)
      end

      "untyped"
    end

    # 산술 연산 결과 타입 추론
    def infer_arithmetic_result(left_type, right_type, op)
      left_base = base_type(left_type)
      right_base = base_type(right_type)

      # 문자열 연결
      if op == "+" && (left_base == "String" || right_base == "String")
        return "String"
      end

      # 숫자 연산
      if numeric_type?(left_base) && numeric_type?(right_base)
        # Float가 하나라도 있으면 Float
        return "Float" if left_base == "Float" || right_base == "Float"

        return "Integer"
      end

      # 배열 연결
      if op == "+" && left_base.start_with?("Array")
        return left_type
      end

      "untyped"
    end

    # 단항 연산자 타입 추론
    def infer_unary_op(node, env)
      operand_type = infer_expression(node.operand, env)

      case node.operator
      when "!"
        "bool"
      when "-"
        operand_type
      else
        "untyped"
      end
    end

    # 메서드 호출 타입 추론
    def infer_method_call(node, env)
      # receiver 타입 추론
      receiver_type = if node.receiver
                        infer_expression(node.receiver, env)
                      else
                        "Object"
                      end

      receiver_base = base_type(receiver_type)

      # 내장 메서드 조회
      method_key = [receiver_base, node.method_name]
      if BUILTIN_METHODS.key?(method_key)
        result = BUILTIN_METHODS[method_key]

        # self 반환인 경우 receiver 타입 반환
        return receiver_type if result == "self"

        return result
      end

      # Object 메서드 fallback
      object_key = ["Object", node.method_name]
      if BUILTIN_METHODS.key?(object_key)
        result = BUILTIN_METHODS[object_key]
        return receiver_type if result == "self"

        return result
      end

      # new 메서드는 클래스 인스턴스 반환
      if node.method_name == "new" && receiver_base.match?(/^[A-Z]/)
        return receiver_base
      end

      "untyped"
    end

    # 배열 리터럴 타입 추론
    def infer_array_literal(node, env)
      return "Array[untyped]" if node.elements.empty?

      element_types = node.elements.map { |e| infer_expression(e, env) }
      unified = unify_types(element_types)

      "Array[#{unified}]"
    end

    # 해시 리터럴 타입 추론
    def infer_hash_literal(node, env)
      return "Hash[untyped, untyped]" if node.pairs.empty?

      key_types = node.pairs.map { |p| infer_expression(p.key, env) }
      value_types = node.pairs.map { |p| infer_expression(p.value, env) }

      key_type = unify_types(key_types)
      value_type = unify_types(value_types)

      "Hash[#{key_type}, #{value_type}]"
    end

    # 대입 타입 추론 (변수 타입 업데이트 및 우변 타입 반환)
    def infer_assignment(node, env)
      value_type = infer_expression(node.value, env)

      # 변수 타입 등록
      target = node.target
      if target.start_with?("@") && !target.start_with?("@@")
        env.define_instance_var(target, value_type)
      elsif target.start_with?("@@")
        env.define_class_var(target, value_type)
      else
        env.define(target, value_type)
      end

      value_type
    end

    # 조건문 타입 추론 (then/else 브랜치 통합)
    def infer_conditional(node, env)
      then_type = infer_expression(node.then_branch, env) if node.then_branch
      else_type = infer_expression(node.else_branch, env) if node.else_branch

      types = [then_type, else_type].compact
      return "nil" if types.empty?

      unify_types(types)
    end

    # 블록 타입 추론 (마지막 문장의 타입)
    def infer_block(node, env)
      return "nil" if node.statements.empty?

      # 마지막 문장 타입 반환 (Ruby의 암묵적 반환)
      last_stmt = node.statements.last
      infer_expression(last_stmt, env)
    end

    # return 문 타입 추론
    def infer_return(node, env)
      return "nil" unless node.value

      infer_expression(node.value, env)
    end

    # 본문에서 모든 return 타입 수집
    # @return [Array<(Array<String>, Boolean)>] [수집된 타입들, 종료 여부]
    def collect_return_types(body, env)
      types = []

      terminated = collect_returns_recursive(body, env, types)

      [types, terminated]
    end

    # @return [Boolean] true if this node terminates (contains unconditional return)
    def collect_returns_recursive(node, env, types)
      case node
      when IR::Return
        type = node.value ? infer_expression(node.value, env) : "nil"
        types << type
        true # return은 항상 실행 흐름 종료
      when IR::Block
        node.statements.each do |stmt|
          terminated = collect_returns_recursive(stmt, env, types)
          return true if terminated # return 이후 코드는 unreachable
        end
        false
      when IR::Conditional
        then_terminated = node.then_branch ? collect_returns_recursive(node.then_branch, env, types) : false
        else_terminated = node.else_branch ? collect_returns_recursive(node.else_branch, env, types) : false
        # 모든 분기가 종료되어야 조건문 전체가 종료됨
        then_terminated && else_terminated
      else
        false
      end
    end

    # 암묵적 반환값 추론 (마지막 표현식)
    def infer_implicit_return(body, env)
      case body
      when IR::Block
        return nil if body.statements.empty?

        last_stmt = body.statements.last

        # return 문이면 이미 수집됨
        return nil if last_stmt.is_a?(IR::Return)

        infer_expression(last_stmt, env)
      else
        infer_expression(body, env)
      end
    end

    # 타입 통합 (여러 타입을 하나로)
    def unify_types(types)
      types = types.compact.uniq

      return "nil" if types.empty?
      return types.first if types.length == 1

      # nil과 다른 타입이 있으면 nullable
      if types.include?("nil") && types.length == 2
        other = types.find { |t| t != "nil" }
        return "#{other}?" if other
      end

      # 동일 기본 타입은 통합
      base_types = types.map { |t| base_type(t) }.uniq
      return types.first if base_types.length == 1

      # Union 타입 생성
      types.join(" | ")
    end

    # Union 타입 생성
    def union_type(type1, type2)
      return type2 if type1 == type2
      return type2 if type1 == "nil"
      return type1 if type2 == "nil"

      "#{type1} | #{type2}"
    end

    # 기본 타입 추출 (Generic에서)
    def base_type(type)
      return "untyped" if type.nil?

      type_str = type.is_a?(String) ? type : type.to_rbs

      # Array[X] → Array
      return ::Regexp.last_match(1) if type_str =~ /^(\\w+)\\[/

      # Nullable X? → X
      return type_str[0..-2] if type_str.end_with?("?")

      type_str
    end

    # 숫자 타입인지 확인
    def numeric_type?(type)
      %w[Integer Float Numeric].include?(type)
    end
  end
end
`,
  "lib/t_ruby/benchmark.rb": `# frozen_string_literal: true

require "benchmark"
require "json"
require "fileutils"
require "time"

module TRuby
  # Benchmark suite for T-Ruby performance measurement
  class BenchmarkSuite
    attr_reader :results, :config

    BENCHMARK_CATEGORIES = %i[
      parsing
      type_checking
      compilation
      incremental
      parallel
      memory
    ].freeze

    def initialize(config = nil)
      @config = config || Config.new
      @results = {}
      @compiler = nil
      @type_checker = nil
    end

    # Run all benchmarks
    def run_all(iterations: 5, warmup: 2)
      puts "T-Ruby Benchmark Suite"
      puts "=" * 60
      puts "Iterations: #{iterations}, Warmup: #{warmup}"
      puts

      BENCHMARK_CATEGORIES.each do |category|
        run_category(category, iterations: iterations, warmup: warmup)
      end

      print_summary
      @results
    end

    # Run specific category
    def run_category(category, iterations: 5, warmup: 2)
      puts "Running #{category} benchmarks..."
      puts "-" * 40

      @results[category] = case category
                           when :parsing then benchmark_parsing(iterations, warmup)
                           when :type_checking then benchmark_type_checking(iterations, warmup)
                           when :compilation then benchmark_compilation(iterations, warmup)
                           when :incremental then benchmark_incremental(iterations, warmup)
                           when :parallel then benchmark_parallel(iterations, warmup)
                           when :memory then benchmark_memory
                           end

      puts
    end

    # Export results to JSON
    def export_json(path = "benchmark_results.json")
      File.write(path, JSON.pretty_generate({
                                              timestamp: Time.now.iso8601,
                                              ruby_version: RUBY_VERSION,
                                              platform: RUBY_PLATFORM,
                                              results: @results,
                                            }))
    end

    # Export results to Markdown
    def export_markdown(path = "benchmark_results.md")
      md = []
      md << "# T-Ruby Benchmark Results"
      md << ""
      md << "**Generated:** #{Time.now}"
      md << "**Ruby Version:** #{RUBY_VERSION}"
      md << "**Platform:** #{RUBY_PLATFORM}"
      md << ""

      @results.each do |category, benchmarks|
        md << "## #{category.to_s.capitalize}"
        md << ""
        md << "| Benchmark | Time (ms) | Memory (KB) | Iterations/sec |"
        md << "|-----------|-----------|-------------|----------------|"

        benchmarks.each do |name, data|
          time_ms = (data[:avg_time] * 1000).round(2)
          memory_kb = (data[:memory] || 0).round(2)
          ips = data[:avg_time].positive? ? (1.0 / data[:avg_time]).round(2) : 0
          md << "| #{name} | #{time_ms} | #{memory_kb} | #{ips} |"
        end
        md << ""
      end

      File.write(path, md.join("\\n"))
    end

    # Compare with previous results
    def compare(previous_path)
      return nil unless File.exist?(previous_path)

      previous = JSON.parse(File.read(previous_path), symbolize_names: true)
      comparison = {}

      @results.each do |category, benchmarks|
        prev_cat = previous[:results][category]
        next unless prev_cat

        comparison[category] = {}
        benchmarks.each do |name, data|
          prev_data = prev_cat[name]
          next unless prev_data

          diff = ((data[:avg_time] - prev_data[:avg_time]) / prev_data[:avg_time] * 100).round(2)
          comparison[category][name] = {
            current: data[:avg_time],
            previous: prev_data[:avg_time],
            diff_percent: diff,
            improved: diff.negative?,
          }
        end
      end

      comparison
    end

    private

    def compiler
      @compiler ||= Compiler.new(@config)
    end

    def type_checker
      @type_checker ||= TypeChecker.new
    end

    # Parsing benchmarks
    def benchmark_parsing(iterations, warmup)
      test_files = generate_test_files(:parsing)
      results = {}

      test_files.each do |name, content|
        times = []

        # Warmup
        warmup.times { Parser.new(content).parse }

        # Actual benchmark
        iterations.times do
          time = Benchmark.realtime { Parser.new(content).parse }
          times << time
        end

        results[name] = calculate_stats(times)
        print_result(name, results[name])
      end

      results
    end

    # Type checking benchmarks
    def benchmark_type_checking(iterations, warmup)
      test_cases = generate_test_files(:type_checking)
      results = {}

      test_cases.each do |name, content|
        times = []
        ast = Parser.new(content).parse

        # Warmup
        warmup.times { TypeChecker.new.check(ast) }

        # Actual benchmark
        iterations.times do
          checker = TypeChecker.new
          time = Benchmark.realtime { checker.check(ast) }
          times << time
        end

        results[name] = calculate_stats(times)
        print_result(name, results[name])
      end

      results
    end

    # Compilation benchmarks
    def benchmark_compilation(iterations, warmup)
      test_cases = generate_test_files(:compilation)
      results = {}

      Dir.mktmpdir("trb_bench") do |tmpdir|
        test_cases.each do |name, content|
          input_path = File.join(tmpdir, "#{name}.trb")
          File.write(input_path, content)

          times = []

          # Warmup
          warmup.times { compiler.compile(input_path) }

          # Actual benchmark
          iterations.times do
            time = Benchmark.realtime { compiler.compile(input_path) }
            times << time
          end

          results[name] = calculate_stats(times)
          print_result(name, results[name])
        end
      end

      results
    end

    # Incremental compilation benchmarks
    def benchmark_incremental(iterations, warmup)
      results = {}

      Dir.mktmpdir("trb_incr_bench") do |tmpdir|
        # Create test files
        files = 10.times.map do |i|
          path = File.join(tmpdir, "file_#{i}.trb")
          File.write(path, generate_test_content(i))
          path
        end

        # Full compilation
        full_times = []
        warmup.times { IncrementalCompiler.new(compiler).compile_all(files) }
        iterations.times do
          ic = IncrementalCompiler.new(compiler)
          time = Benchmark.realtime { ic.compile_all(files) }
          full_times << time
        end
        results[:full_compile] = calculate_stats(full_times)
        print_result(:full_compile, results[:full_compile])

        # Incremental (single file change)
        incr_times = []
        ic = IncrementalCompiler.new(compiler)
        ic.compile_all(files)

        warmup.times do
          File.write(files[0], generate_test_content(0, modified: true))
          ic.compile_incremental([files[0]])
        end

        iterations.times do
          File.write(files[0], generate_test_content(0, modified: true))
          time = Benchmark.realtime { ic.compile_incremental([files[0]]) }
          incr_times << time
        end
        results[:incremental_single] = calculate_stats(incr_times)
        print_result(:incremental_single, results[:incremental_single])

        # Calculate speedup
        if results[:full_compile][:avg_time].positive?
          speedup = results[:full_compile][:avg_time] / results[:incremental_single][:avg_time]
          puts "  Incremental speedup: #{speedup.round(2)}x"
        end
      end

      results
    end

    # Parallel compilation benchmarks
    def benchmark_parallel(iterations, warmup)
      results = {}

      Dir.mktmpdir("trb_parallel_bench") do |tmpdir|
        # Create 20 test files
        files = 20.times.map do |i|
          path = File.join(tmpdir, "parallel_#{i}.trb")
          File.write(path, generate_test_content(i))
          path
        end

        # Sequential
        seq_times = []
        warmup.times do
          files.each { |f| compiler.compile(f) }
        end
        iterations.times do
          time = Benchmark.realtime do
            files.each { |f| compiler.compile(f) }
          end
          seq_times << time
        end
        results[:sequential] = calculate_stats(seq_times)
        print_result(:sequential, results[:sequential])

        # Parallel (2 workers)
        par2_times = []
        processor = ParallelProcessor.new(workers: 2)
        warmup.times { processor.process_files(files) { |f| compiler.compile(f) } }
        iterations.times do
          time = Benchmark.realtime do
            processor.process_files(files) { |f| compiler.compile(f) }
          end
          par2_times << time
        end
        results[:parallel_2] = calculate_stats(par2_times)
        print_result(:parallel_2, results[:parallel_2])

        # Parallel (4 workers)
        par4_times = []
        processor4 = ParallelProcessor.new(workers: 4)
        warmup.times { processor4.process_files(files) { |f| compiler.compile(f) } }
        iterations.times do
          time = Benchmark.realtime do
            processor4.process_files(files) { |f| compiler.compile(f) }
          end
          par4_times << time
        end
        results[:parallel_4] = calculate_stats(par4_times)
        print_result(:parallel_4, results[:parallel_4])

        # Print speedups
        if results[:sequential][:avg_time].positive?
          puts "  Parallel(2) speedup: #{(results[:sequential][:avg_time] / results[:parallel_2][:avg_time]).round(2)}x"
          puts "  Parallel(4) speedup: #{(results[:sequential][:avg_time] / results[:parallel_4][:avg_time]).round(2)}x"
        end
      end

      results
    end

    # Memory benchmarks
    def benchmark_memory
      results = {}

      # Baseline memory
      GC.start
      get_memory_usage

      # Parser memory
      content = generate_test_content(0)
      GC.start
      before = get_memory_usage
      10.times { Parser.new(content).parse }
      GC.start
      after = get_memory_usage
      results[:parsing] = { memory: (after - before) / 10.0, avg_time: 0, min_time: 0, max_time: 0, std_dev: 0 }
      print_result(:parsing, results[:parsing], unit: "KB")

      # Type checker memory
      ast = Parser.new(content).parse
      GC.start
      before = get_memory_usage
      10.times { TypeChecker.new.check(ast) }
      GC.start
      after = get_memory_usage
      results[:type_checking] = { memory: (after - before) / 10.0, avg_time: 0, min_time: 0, max_time: 0, std_dev: 0 }
      print_result(:type_checking, results[:type_checking], unit: "KB")

      # Cache memory
      GC.start
      before = get_memory_usage
      cache = CompilationCache.new
      1000.times { |i| cache.set("key_#{i}", "value_#{i}") }
      GC.start
      after = get_memory_usage
      results[:cache_1000] = { memory: after - before, avg_time: 0, min_time: 0, max_time: 0, std_dev: 0 }
      print_result(:cache_1000, results[:cache_1000], unit: "KB")

      results
    end

    def generate_test_files(category)
      case category
      when :parsing
        {
          small_file: generate_test_content(0, lines: 10),
          medium_file: generate_test_content(0, lines: 100),
          large_file: generate_test_content(0, lines: 500),
          complex_types: generate_complex_types_content,
        }
      when :type_checking
        {
          simple_types: generate_simple_types_content,
          generic_types: generate_generic_types_content,
          union_types: generate_union_types_content,
          interface_types: generate_interface_types_content,
        }
      when :compilation
        {
          minimal: "def hello: void; end",
          with_types: generate_test_content(0, lines: 50),
          with_interfaces: generate_interface_types_content,
        }
      else
        {}
      end
    end

    def generate_test_content(seed, lines: 50, modified: false)
      content = []
      content << "# Test file #{seed}#{" (modified)" if modified}"
      content << ""
      content << "type CustomType#{seed} = String | Integer | nil"
      content << ""
      content << "interface TestInterface#{seed}"
      content << "  value: CustomType#{seed}"
      content << "  process: Boolean"
      content << "end"
      content << ""

      (lines - 10).times do |i|
        content << "def method_#{seed}_#{i}(arg: String): Integer"
        content << "  arg.length"
        content << "end"
        content << ""
      end

      content.join("\\n")
    end

    def generate_complex_types_content
      <<~TRB
        type DeepNested<T> = Hash<String, Array<Hash<Symbol, T>>>
        type UnionOfGenerics<A, B> = Array<A> | Hash<String, B> | nil
        type FunctionType = Proc<Integer> | Lambda<String>

        interface ComplexInterface<T, U>
          data: DeepNested<T>
          transform: UnionOfGenerics<T, U>
          callback: FunctionType
        end

        def complex_method<T>(
          input: DeepNested<T>,
          options: Hash<Symbol, String | Integer | Boolean>
        ): UnionOfGenerics<T, String>
          nil
        end
      TRB
    end

    def generate_simple_types_content
      <<~TRB
        def add(a: Integer, b: Integer): Integer
          a + b
        end

        def greet(name: String): String
          "Hello, \\#{name}"
        end

        def valid?(value: Boolean): Boolean
          value
        end
      TRB
    end

    def generate_generic_types_content
      <<~TRB
        def first<T>(items: Array<T>): T | nil
          items.first
        end

        def map_values<K, V, R>(hash: Hash<K, V>, &block: Proc<R>): Hash<K, R>
          hash.transform_values(&block)
        end

        def wrap<T>(value: T): Array<T>
          [value]
        end
      TRB
    end

    def generate_union_types_content
      <<~TRB
        type StringOrNumber = String | Integer
        type NullableString = String | nil
        type Status = "pending" | "active" | "completed"

        def process(value: StringOrNumber): String
          value.to_s
        end

        def safe_call(input: NullableString): String
          input || "default"
        end
      TRB
    end

    def generate_interface_types_content
      <<~TRB
        interface Comparable<T>
          <=>: Integer
        end

        interface Enumerable<T>
          each: void
          map: Array<T>
          select: Array<T>
        end

        interface Repository<T>
          find: T | nil
          save: Boolean
          delete: Boolean
          all: Array<T>
        end

        def sort<T: Comparable<T>>(items: Array<T>): Array<T>
          items.sort
        end
      TRB
    end

    def calculate_stats(times)
      avg = times.sum / times.length.to_f
      min = times.min
      max = times.max
      variance = times.map { |t| (t - avg)**2 }.sum / times.length.to_f
      std_dev = Math.sqrt(variance)

      {
        avg_time: avg,
        min_time: min,
        max_time: max,
        std_dev: std_dev,
        iterations: times.length,
      }
    end

    def print_result(name, stats, unit: "ms")
      if unit == "KB"
        puts "  #{name}: #{stats[:memory].round(2)} KB"
      else
        avg_ms = (stats[:avg_time] * 1000).round(3)
        std_ms = (stats[:std_dev] * 1000).round(3)
        puts "  #{name}: #{avg_ms}ms (±#{std_ms}ms)"
      end
    end

    def print_summary
      puts "=" * 60
      puts "SUMMARY"
      puts "=" * 60

      total_time = 0
      @results.each do |category, benchmarks|
        cat_time = benchmarks.values.sum { |b| b[:avg_time] || 0 }
        total_time += cat_time
        puts "#{category}: #{(cat_time * 1000).round(2)}ms total"
      end

      puts "-" * 40
      puts "Total benchmark time: #{(total_time * 1000).round(2)}ms"
    end

    def get_memory_usage
      # Returns memory in KB
      if RUBY_PLATFORM =~ /linux/
        File.read("/proc/#{Process.pid}/statm").split[1].to_i * 4 # pages * 4KB
      else
        # Fallback using GC stats
        GC.stat[:heap_live_slots] * 40 / 1024.0 # approximate
      end
    end
  end

  # Quick benchmark helper
  module QuickBenchmark
    def self.measure(name = "Operation", iterations: 100)
      times = []

      iterations.times do
        start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
        yield
        times << (Process.clock_gettime(Process::CLOCK_MONOTONIC) - start)
      end

      avg = times.sum / times.length
      puts "#{name}: #{(avg * 1000).round(3)}ms avg (#{iterations} iterations)"

      avg
    end

    def self.compare(name, &block)
      before = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      result = block.call
      after = Process.clock_gettime(Process::CLOCK_MONOTONIC)

      puts "#{name}: #{((after - before) * 1000).round(3)}ms"
      result
    end
  end
end
`,
  "lib/t_ruby/bundler_integration.rb": `# frozen_string_literal: true

require "fileutils"
require "time"

module TRuby
  # Integrates T-Ruby type packages with Bundler/RubyGems ecosystem
  class BundlerIntegration
    TYPES_GROUP = :types
    TYPE_SUFFIX = "-types"
    GEMFILE = "Gemfile"
    GEMFILE_LOCK = "Gemfile.lock"

    attr_reader :project_dir, :errors

    def initialize(project_dir: ".")
      @project_dir = project_dir
      @errors = []
      @type_gems = {}
    end

    # Check if project uses Bundler
    def bundler_project?
      File.exist?(gemfile_path)
    end

    # Initialize T-Ruby types support in existing Bundler project
    def init
      unless bundler_project?
        @errors << "No Gemfile found. Run 'bundle init' first."
        return false
      end

      add_types_group_to_gemfile unless types_group_exists?
      create_types_directory
      true
    end

    # Find type packages for installed gems
    def discover_type_packages
      return {} unless bundler_project?

      installed_gems = parse_gemfile_lock
      type_packages = {}

      installed_gems.each_key do |gem_name|
        type_gem = find_type_gem(gem_name)
        type_packages[gem_name] = type_gem if type_gem
      end

      type_packages
    end

    # Add a type package dependency
    def add_type_gem(gem_name, version: nil)
      type_gem_name = "#{gem_name}#{TYPE_SUFFIX}"
      version_constraint = version || ">= 0"

      append_to_gemfile(type_gem_name, version_constraint, group: TYPES_GROUP)
      @type_gems[gem_name] = { name: type_gem_name, version: version_constraint }

      { gem: type_gem_name, version: version_constraint, status: :added }
    end

    # Remove a type package dependency
    def remove_type_gem(gem_name)
      type_gem_name = "#{gem_name}#{TYPE_SUFFIX}"
      remove_from_gemfile(type_gem_name)
      @type_gems.delete(gem_name)

      { gem: type_gem_name, status: :removed }
    end

    # Sync type definitions from installed type gems
    def sync_types
      return { synced: [], errors: @errors } unless bundler_project?

      synced = []
      type_gems = find_installed_type_gems

      type_gems.each do |gem_info|
        result = sync_gem_types(gem_info)
        synced << result if result[:success]
      end

      { synced: synced, errors: @errors }
    end

    # Generate a .trb-bundle.json manifest for compatibility
    def generate_bundle_manifest
      manifest = {
        bundler_integration: true,
        version: TRuby::VERSION,
        types_group: TYPES_GROUP.to_s,
        type_gems: list_type_gems,
        local_types: list_local_types,
        generated_at: Time.now.iso8601,
      }

      manifest_path = File.join(@project_dir, ".trb-bundle.json")
      File.write(manifest_path, JSON.pretty_generate(manifest))
      manifest_path
    end

    # Load type definitions from Bundler-managed gems
    def load_bundled_types
      type_definitions = {}

      find_installed_type_gems.each do |gem_info|
        defs = load_gem_type_definitions(gem_info)
        type_definitions.merge!(defs)
      end

      # Also load local types
      local_types = load_local_type_definitions
      type_definitions.merge!(local_types)

      type_definitions
    end

    # Check compatibility between gem version and type version
    def check_version_compatibility
      issues = []
      gemfile_lock = parse_gemfile_lock

      @type_gems.each do |base_gem, type_info|
        base_version = gemfile_lock[base_gem]
        type_version = gemfile_lock[type_info[:name]]

        next unless base_version && type_version

        next if versions_compatible?(base_version, type_version)

        issues << {
          gem: base_gem,
          gem_version: base_version,
          type_gem: type_info[:name],
          type_version: type_version,
          message: "Version mismatch: #{base_gem}@#{base_version} vs #{type_info[:name]}@#{type_version}",
        }
      end

      issues
    end

    # Create a new type gem scaffold
    def create_type_gem_scaffold(gem_name, output_dir: nil)
      type_gem_name = "#{gem_name}#{TYPE_SUFFIX}"
      output = output_dir || File.join(@project_dir, type_gem_name)

      FileUtils.mkdir_p(output)
      FileUtils.mkdir_p(File.join(output, "lib", type_gem_name.gsub("-", "_")))
      FileUtils.mkdir_p(File.join(output, "sig"))

      # Create gemspec
      create_type_gemspec(type_gem_name, gem_name, output)

      # Create main type file
      create_main_type_file(type_gem_name, gem_name, output)

      # Create README
      create_type_gem_readme(type_gem_name, gem_name, output)

      { path: output, gem_name: type_gem_name, status: :created }
    end

    private

    def gemfile_path
      File.join(@project_dir, GEMFILE)
    end

    def gemfile_lock_path
      File.join(@project_dir, GEMFILE_LOCK)
    end

    def types_group_exists?
      return false unless File.exist?(gemfile_path)

      content = File.read(gemfile_path)
      content.include?("group :#{TYPES_GROUP}") || content.include?("group :types")
    end

    def add_types_group_to_gemfile
      content = File.read(gemfile_path)

      types_group = <<~RUBY

        # T-Ruby type definitions
        group :types do
          # Add type gems here, e.g.:
          # gem 'rails-types', '~> 7.0'
        end
      RUBY

      File.write(gemfile_path, content + types_group)
    end

    def create_types_directory
      types_dir = File.join(@project_dir, "types")
      FileUtils.mkdir_p(types_dir)

      # Create a sample .d.trb file
      sample_path = File.join(types_dir, "custom.d.trb")
      return if File.exist?(sample_path)

      File.write(sample_path, <<~TRB)
        # Custom type definitions for your project
        # These types are available throughout your T-Ruby code

        # Example type alias
        # type UserId = String

        # Example interface
        # interface Serializable
        #   to_json: String
        #   from_json: (String) -> self
        # end
      TRB
    end

    def append_to_gemfile(gem_name, version, group:)
      content = File.read(gemfile_path)

      # Find the types group and add gem there
      if content.include?("group :#{group}")
        # Add inside existing group
        new_content = content.gsub(
          /(group :#{group}.*?do\\s*\\n)/m,
          "\\\\1  gem '#{gem_name}', '#{version}'\\n"
        )
        File.write(gemfile_path, new_content)
      else
        # Create group with gem
        File.write(gemfile_path, content + <<~RUBY)

          group :#{group} do
            gem '#{gem_name}', '#{version}'
          end
        RUBY
      end
    end

    def remove_from_gemfile(gem_name)
      content = File.read(gemfile_path)
      new_content = content.gsub(/^\\s*gem ['"]#{gem_name}['"].*$\\n?/, "")
      File.write(gemfile_path, new_content)
    end

    def parse_gemfile_lock
      return {} unless File.exist?(gemfile_lock_path)

      gems = {}
      in_specs = false

      File.readlines(gemfile_lock_path).each do |line|
        if line.strip == "specs:"
          in_specs = true
          next
        end

        if in_specs && line.match?(/^\\s{4}(\\S+)\\s+\\((.+)\\)/)
          match = line.match(/^\\s{4}(\\S+)\\s+\\((.+)\\)/)
          gems[match[1]] = match[2]
        end

        in_specs = false if in_specs && !line.start_with?("  ")
      end

      gems
    end

    def find_type_gem(gem_name)
      type_gem_name = "#{gem_name}#{TYPE_SUFFIX}"

      # Check if type gem exists in known registries
      # This is a simplified check - in production would query RubyGems API
      {
        name: type_gem_name,
        available: check_gem_availability(type_gem_name),
      }
    end

    def check_gem_availability(gem_name)
      # Simplified availability check
      # In production, would use: Gem::SpecFetcher.fetcher.detect(:latest)
      # For now, return based on common type packages
      common_type_gems = %w[
        rails-types
        activerecord-types
        activesupport-types
        rspec-types
        sidekiq-types
        redis-types
        pg-types
      ]

      common_type_gems.include?(gem_name)
    end

    def find_installed_type_gems
      gems = parse_gemfile_lock
      gems.select { |name, _| name.end_with?(TYPE_SUFFIX) }.map do |name, version|
        base_gem = name.sub(/#{TYPE_SUFFIX}$/, "")
        {
          name: name,
          base_gem: base_gem,
          version: version,
          path: find_gem_path(name, version),
        }
      end
    end

    def find_gem_path(gem_name, version)
      # Try to find gem in standard locations
      possible_paths = [
        File.join(ENV["GEM_HOME"] || "", "gems", "#{gem_name}-#{version}"),
        File.join(Dir.home, ".gem", "ruby", "*", "gems", "#{gem_name}-#{version}"),
        File.join(@project_dir, "vendor", "bundle", "**", "gems", "#{gem_name}-#{version}"),
      ]

      possible_paths.each do |pattern|
        matches = Dir.glob(pattern)
        return matches.first if matches.any?
      end

      nil
    end

    def sync_gem_types(gem_info)
      return { success: false, gem: gem_info[:name] } unless gem_info[:path]

      # Look for type definitions in the gem
      type_files = Dir.glob(File.join(gem_info[:path], "**", "*.d.trb"))
      rbs_files = Dir.glob(File.join(gem_info[:path], "sig", "**", "*.rbs"))

      target_dir = File.join(@project_dir, ".trb-types", gem_info[:name])
      FileUtils.mkdir_p(target_dir)

      copied = []

      (type_files + rbs_files).each do |file|
        target = File.join(target_dir, File.basename(file))
        FileUtils.cp(file, target)
        copied << target
      end

      { success: true, gem: gem_info[:name], files: copied }
    end

    def load_gem_type_definitions(gem_info)
      definitions = {}
      return definitions unless gem_info[:path]

      type_files = Dir.glob(File.join(gem_info[:path], "**", "*.d.trb"))

      type_files.each do |file|
        content = File.read(file)
        parsed = parse_type_definitions(content)
        definitions.merge!(parsed)
      end

      definitions
    end

    def load_local_type_definitions
      definitions = {}
      types_dir = File.join(@project_dir, "types")

      return definitions unless Dir.exist?(types_dir)

      Dir.glob(File.join(types_dir, "**", "*.d.trb")).each do |file|
        content = File.read(file)
        parsed = parse_type_definitions(content)
        definitions.merge!(parsed)
      end

      definitions
    end

    def parse_type_definitions(content)
      definitions = {}

      # Parse type aliases
      content.scan(/^\\s*type\\s+(\\w+)\\s*=\\s*(.+)$/).each do |match|
        definitions[match[0]] = { kind: :alias, definition: match[1] }
      end

      # Parse interfaces
      content.scan(/^\\s*interface\\s+(\\w+)/).each do |match|
        definitions[match[0]] = { kind: :interface }
      end

      definitions
    end

    def list_type_gems
      find_installed_type_gems.map do |gem_info|
        {
          name: gem_info[:name],
          base_gem: gem_info[:base_gem],
          version: gem_info[:version],
        }
      end
    end

    def list_local_types
      types_dir = File.join(@project_dir, "types")
      return [] unless Dir.exist?(types_dir)

      Dir.glob(File.join(types_dir, "**", "*.d.trb")).map do |file|
        File.basename(file)
      end
    end

    def versions_compatible?(gem_version, type_version)
      # Check if major.minor versions match
      gem_parts = gem_version.split(".")
      type_parts = type_version.split(".")

      gem_parts[0] == type_parts[0] && gem_parts[1] == type_parts[1]
    end

    def create_type_gemspec(type_gem_name, base_gem, output_dir)
      gemspec_content = <<~RUBY
        # frozen_string_literal: true

        Gem::Specification.new do |spec|
          spec.name          = "#{type_gem_name}"
          spec.version       = "0.1.0"
          spec.authors       = ["Your Name"]
          spec.email         = ["your.email@example.com"]

          spec.summary       = "T-Ruby type definitions for #{base_gem}"
          spec.description   = "Type definitions for #{base_gem} to be used with T-Ruby"
          spec.homepage      = "https://github.com/your-username/#{type_gem_name}"
          spec.license       = "MIT"
          spec.required_ruby_version = ">= 3.0.0"

          spec.metadata["rubygems_mfa_required"] = "true"
          spec.metadata["source_code_uri"] = spec.homepage
          spec.metadata["changelog_uri"] = "\\#{spec.homepage}/blob/main/CHANGELOG.md"

          spec.files = Dir.glob("{lib,sig}/**/*") + %w[README.md LICENSE.txt]
          spec.require_paths = ["lib"]

          # Match the base gem version
          spec.add_dependency "#{base_gem}"
        end
      RUBY

      File.write(File.join(output_dir, "#{type_gem_name}.gemspec"), gemspec_content)
    end

    def create_main_type_file(type_gem_name, base_gem, output_dir)
      module_name = type_gem_name.gsub("-", "_").split("_").map(&:capitalize).join
      lib_dir = File.join(output_dir, "lib", type_gem_name.gsub("-", "_"))

      main_file = <<~RUBY
        # frozen_string_literal: true

        # Type definitions for #{base_gem}
        # Auto-generated scaffold - customize as needed

        module #{module_name}
          VERSION = "0.1.0"
        end
      RUBY

      File.write(File.join(lib_dir, "version.rb"), main_file)

      # Create types directory and sample file
      types_dir = File.join(output_dir, "sig")
      FileUtils.mkdir_p(types_dir)

      types_file = <<~TRB
        # Type definitions for #{base_gem}
        # Add your type definitions here

        # Example:
        # interface #{base_gem.capitalize}Client
        #   connect: (String) -> Boolean
        #   disconnect: () -> void
        # end
      TRB

      File.write(File.join(types_dir, "#{base_gem}.d.trb"), types_file)
    end

    def create_type_gem_readme(type_gem_name, base_gem, output_dir)
      readme = <<~MARKDOWN
        # #{type_gem_name}

        T-Ruby type definitions for [#{base_gem}](https://rubygems.org/gems/#{base_gem}).

        ## Installation

        Add this line to your Gemfile:

        \`\`\`ruby
        group :types do
          gem '#{type_gem_name}'
        end
        \`\`\`

        Then run:

        \`\`\`bash
        bundle install
        \`\`\`

        ## Usage

        The type definitions will be automatically loaded by T-Ruby when compiling your \`.trb\` files.

        ## Contributing

        Bug reports and pull requests are welcome.

        ## License

        MIT License
      MARKDOWN

      File.write(File.join(output_dir, "README.md"), readme)
    end
  end

  # Extension to PackageManager for Bundler support
  class PackageManager
    attr_reader :bundler

    def initialize(project_dir: ".")
      @project_dir = project_dir
      @manifest = PackageManifest.load(File.join(project_dir, PackageManifest::MANIFEST_FILE))
      @registry = PackageRegistry.new(local_path: File.join(project_dir, ".trb-packages"))
      @resolver = DependencyResolver.new(@registry)
      @bundler = BundlerIntegration.new(project_dir: project_dir)
    end

    # Use Bundler if available, fall back to native package management
    def install_with_bundler_fallback
      if @bundler.bundler_project?
        @bundler.sync_types
      else
        install
      end
    end

    # Migrate from native T-Ruby packages to Bundler
    def migrate_to_bundler
      return { success: false, error: "Not a Bundler project" } unless @bundler.bundler_project?

      migrated = []

      # Read existing T-Ruby manifest
      @manifest&.dependencies&.each do |name, version|
        result = @bundler.add_type_gem(name, version: version)
        migrated << result
      end

      # Generate new bundle manifest
      @bundler.generate_bundle_manifest

      { success: true, migrated: migrated }
    end
  end
end
`,
  "lib/t_ruby/cache.rb": `# frozen_string_literal: true

require "digest"
require "json"
require "fileutils"

module TRuby
  # Cache entry with metadata
  class CacheEntry
    attr_reader :key, :value, :created_at, :accessed_at, :hits

    def initialize(key, value)
      @key = key
      @value = value
      @created_at = Time.now
      @accessed_at = Time.now
      @hits = 0
    end

    def access
      @accessed_at = Time.now
      @hits += 1
      @value
    end

    def stale?(max_age)
      Time.now - @created_at > max_age
    end

    def to_h
      {
        key: @key,
        value: @value,
        created_at: @created_at.to_i,
        hits: @hits,
      }
    end
  end

  # In-memory LRU cache
  class MemoryCache
    attr_reader :max_size, :hits, :misses

    def initialize(max_size: 1000)
      @max_size = max_size
      @cache = {}
      @access_order = []
      @hits = 0
      @misses = 0
      @mutex = Mutex.new
    end

    def get(key)
      @mutex.synchronize do
        if @cache.key?(key)
          @hits += 1
          touch(key)
          @cache[key].access
        else
          @misses += 1
          nil
        end
      end
    end

    def set(key, value)
      @mutex.synchronize do
        evict if @cache.size >= @max_size && !@cache.key?(key)

        @cache[key] = CacheEntry.new(key, value)
        touch(key)
        value
      end
    end

    def delete(key)
      @mutex.synchronize do
        @cache.delete(key)
        @access_order.delete(key)
      end
    end

    def clear
      @mutex.synchronize do
        @cache.clear
        @access_order.clear
        @hits = 0
        @misses = 0
      end
    end

    def size
      @cache.size
    end

    def hit_rate
      total = @hits + @misses
      return 0.0 if total.zero?

      @hits.to_f / total
    end

    def stats
      {
        size: size,
        max_size: @max_size,
        hits: @hits,
        misses: @misses,
        hit_rate: hit_rate,
      }
    end

    private

    def touch(key)
      @access_order.delete(key)
      @access_order.push(key)
    end

    def evict
      return if @access_order.empty?

      # Evict least recently used
      oldest_key = @access_order.shift
      @cache.delete(oldest_key)
    end
  end

  # File-based persistent cache
  class FileCache
    attr_reader :cache_dir, :max_age

    def initialize(cache_dir: ".t-ruby-cache", max_age: 3600)
      @cache_dir = cache_dir
      @max_age = max_age
      FileUtils.mkdir_p(@cache_dir)
    end

    def get(key)
      path = cache_path(key)
      return nil unless File.exist?(path)

      # Check if stale
      if File.mtime(path) < Time.now - @max_age
        File.delete(path)
        return nil
      end

      data = File.read(path)
      JSON.parse(data, symbolize_names: true)
    rescue JSON::ParserError
      File.delete(path)
      nil
    end

    def set(key, value)
      path = cache_path(key)
      File.write(path, JSON.generate(value))
      value
    end

    def delete(key)
      path = cache_path(key)
      FileUtils.rm_f(path)
    end

    def clear
      FileUtils.rm_rf(@cache_dir)
      FileUtils.mkdir_p(@cache_dir)
    end

    def prune
      Dir.glob(File.join(@cache_dir, "*.json")).each do |path|
        File.delete(path) if File.mtime(path) < Time.now - @max_age
      end
    end

    private

    def cache_path(key)
      hash = Digest::SHA256.hexdigest(key.to_s)[0, 16]
      File.join(@cache_dir, "#{hash}.json")
    end
  end

  # AST parse tree cache
  class ParseCache
    def initialize(memory_cache: nil, file_cache: nil)
      @memory_cache = memory_cache || MemoryCache.new(max_size: 500)
      @file_cache = file_cache
    end

    def get(source)
      key = source_key(source)

      # Try memory first
      result = @memory_cache.get(key)
      return result if result

      # Try file cache
      if @file_cache
        result = @file_cache.get(key)
        if result
          @memory_cache.set(key, result)
          return result
        end
      end

      nil
    end

    def set(source, parse_result)
      key = source_key(source)

      @memory_cache.set(key, parse_result)
      @file_cache&.set(key, parse_result)

      parse_result
    end

    def invalidate(source)
      key = source_key(source)
      @memory_cache.delete(key)
      @file_cache&.delete(key)
    end

    def stats
      @memory_cache.stats
    end

    private

    def source_key(source)
      Digest::SHA256.hexdigest(source)
    end
  end

  # Type resolution cache
  class TypeResolutionCache
    def initialize
      @cache = MemoryCache.new(max_size: 2000)
    end

    def get(type_expression)
      @cache.get(type_expression)
    end

    def set(type_expression, resolved_type)
      @cache.set(type_expression, resolved_type)
    end

    def clear
      @cache.clear
    end

    def stats
      @cache.stats
    end
  end

  # Declaration file cache
  class DeclarationCache
    def initialize(cache_dir: ".t-ruby-cache/declarations")
      @file_cache = FileCache.new(cache_dir: cache_dir, max_age: 86_400) # 24 hours
      @memory_cache = MemoryCache.new(max_size: 200)
    end

    def get(file_path)
      # Check modification time
      return nil unless File.exist?(file_path)

      mtime = File.mtime(file_path).to_i
      cache_key = "#{file_path}:#{mtime}"

      # Try memory first
      result = @memory_cache.get(cache_key)
      return result if result

      # Try file cache
      result = @file_cache.get(cache_key)
      if result
        @memory_cache.set(cache_key, result)
        return result
      end

      nil
    end

    def set(file_path, declarations)
      mtime = File.mtime(file_path).to_i
      cache_key = "#{file_path}:#{mtime}"

      @memory_cache.set(cache_key, declarations)
      @file_cache.set(cache_key, declarations)

      declarations
    end

    def clear
      @memory_cache.clear
      @file_cache.clear
    end
  end

  # Incremental compilation support
  class IncrementalCompiler
    attr_reader :file_hashes, :dependencies

    def initialize(compiler, cache: nil)
      @compiler = compiler
      @cache = cache || ParseCache.new
      @file_hashes = {}
      @dependencies = {}
      @compiled_files = {}
    end

    # Check if file needs recompilation
    def needs_compile?(file_path)
      return true unless File.exist?(file_path)

      current_hash = compute_file_hash(file_path)
      stored_hash = @file_hashes[file_path]

      return true if stored_hash.nil? || stored_hash != current_hash

      # Check dependencies
      deps = @dependencies[file_path] || []
      deps.any? { |dep| needs_compile?(dep) }
    end

    # Compile file with caching
    def compile(file_path)
      return @compiled_files[file_path] unless needs_compile?(file_path)

      result = @compiler.compile(file_path)
      @file_hashes[file_path] = compute_file_hash(file_path)
      @compiled_files[file_path] = result

      result
    end

    # Compile multiple files, skipping unchanged
    def compile_all(file_paths)
      results = {}
      to_compile = file_paths.select { |f| needs_compile?(f) }

      to_compile.each do |file_path|
        results[file_path] = compile(file_path)
      end

      results
    end

    # Register dependency between files
    def add_dependency(file_path, depends_on)
      @dependencies[file_path] ||= []
      @dependencies[file_path] << depends_on unless @dependencies[file_path].include?(depends_on)
    end

    # Clear compilation cache
    def clear
      @file_hashes.clear
      @dependencies.clear
      @compiled_files.clear
      @cache.stats # Just accessing for potential cleanup
    end

    # Update file hash after external compile (for watcher integration)
    def update_file_hash(file_path)
      @file_hashes[file_path] = compute_file_hash(file_path)
    end

    private

    def compute_file_hash(file_path)
      return nil unless File.exist?(file_path)

      Digest::SHA256.hexdigest(File.read(file_path))
    end
  end

  # Parallel file processor
  class ParallelProcessor
    attr_reader :thread_count

    def initialize(thread_count: nil)
      @thread_count = thread_count || determine_thread_count
    end

    # Process files in parallel
    def process_files(file_paths, &block)
      return [] if file_paths.empty?

      # Split into batches
      batches = file_paths.each_slice(batch_size(file_paths.length)).to_a

      results = []
      mutex = Mutex.new

      threads = batches.map do |batch|
        Thread.new do
          batch_results = batch.map { |file| block.call(file) }
          mutex.synchronize { results.concat(batch_results) }
        end
      end

      threads.each(&:join)
      results
    end

    # Process with work stealing
    def process_with_queue(file_paths, &block)
      queue = Queue.new
      file_paths.each { |f| queue << f }

      results = []
      mutex = Mutex.new

      threads = @thread_count.times.map do
        Thread.new do
          loop do
            file = begin
              queue.pop(true)
            rescue StandardError
              break
            end
            result = block.call(file)
            mutex.synchronize { results << result }
          end
        end
      end

      threads.each(&:join)
      results
    end

    private

    def determine_thread_count
      # Use number of CPU cores, max 8
      [Etc.nprocessors, 8].min
    rescue StandardError
      4
    end

    def batch_size(total)
      [total / @thread_count, 1].max
    end
  end

  # Cross-file Type Checker
  class CrossFileTypeChecker
    attr_reader :errors, :warnings, :file_types

    def initialize(type_checker: nil)
      @type_checker = type_checker || TypeChecker.new
      @file_types = {} # file_path => { types: [], functions: [], interfaces: [] }
      @global_registry = {} # name => { file: path, kind: :type/:func/:interface, definition: ... }
      @errors = []
      @warnings = []
    end

    # Register types from a file
    def register_file(file_path, ir_program)
      types = []
      functions = []
      interfaces = []

      ir_program.declarations.each do |decl|
        case decl
        when IR::TypeAlias
          types << { name: decl.name, definition: decl.definition }
          register_global(decl.name, file_path, :type, decl)
        when IR::Interface
          interfaces << { name: decl.name, members: decl.members }
          register_global(decl.name, file_path, :interface, decl)
        when IR::MethodDef
          functions << { name: decl.name, params: decl.params, return_type: decl.return_type }
          register_global(decl.name, file_path, :function, decl)
        end
      end

      @file_types[file_path] = { types: types, functions: functions, interfaces: interfaces }
    end

    # Check cross-file type consistency
    def check_all
      @errors = []
      @warnings = []

      # Check for duplicate definitions
      check_duplicate_definitions

      # Check for unresolved type references
      check_unresolved_references

      # Check interface implementations
      check_interface_implementations

      {
        success: @errors.empty?,
        errors: @errors,
        warnings: @warnings,
      }
    end

    # Check a specific file against global types
    def check_file(file_path, ir_program)
      file_errors = []

      ir_program.declarations.each do |decl|
        case decl
        when IR::MethodDef
          # Check parameter types
          decl.params.each do |param|
            next unless param.type_annotation && !type_exists?(param.type_annotation)

            file_errors << {
              file: file_path,
              message: "Unknown type '#{type_name(param.type_annotation)}' in parameter '#{param.name}'",
            }
          end

          # Check return type
          if decl.return_type && !type_exists?(decl.return_type)
            file_errors << {
              file: file_path,
              message: "Unknown return type '#{type_name(decl.return_type)}' in function '#{decl.name}'",
            }
          end
        end
      end

      file_errors
    end

    # Get all registered types
    def all_types
      @global_registry.keys
    end

    # Find where a type is defined
    def find_definition(name)
      @global_registry[name]
    end

    # Clear all registrations
    def clear
      @file_types.clear
      @global_registry.clear
      @errors.clear
      @warnings.clear
    end

    private

    def register_global(name, file_path, kind, definition)
      if @global_registry[name] && @global_registry[name][:file] != file_path
        # Duplicate definition from different file
        @warnings << {
          message: "#{kind.to_s.capitalize} '#{name}' defined in multiple files",
          files: [@global_registry[name][:file], file_path],
        }
      end

      @global_registry[name] = { file: file_path, kind: kind, definition: definition }
    end

    def check_duplicate_definitions
      @global_registry.group_by { |_, v| v[:file] }.each do |file, entries|
        # Check for duplicates within file
        names = entries.map(&:first)
        duplicates = names.select { |n| names.count(n) > 1 }.uniq

        duplicates.each do |name|
          @errors << {
            file: file,
            message: "Duplicate definition of '#{name}'",
          }
        end
      end
    end

    def check_unresolved_references
      @file_types.each do |file_path, info|
        # Check type alias definitions for unresolved types
        info[:types].each do |type_info|
          referenced_types = extract_type_references(type_info[:definition])
          referenced_types.each do |ref|
            next if type_exists_by_name?(ref)

            @errors << {
              file: file_path,
              message: "Unresolved type reference '#{ref}' in type alias '#{type_info[:name]}'",
            }
          end
        end
      end
    end

    def check_interface_implementations
      # For future: check that classes implement all interface methods
    end

    def type_exists?(type_node)
      case type_node
      when IR::SimpleType
        type_exists_by_name?(type_node.name)
      when IR::GenericType
        type_exists_by_name?(type_node.base)
      when IR::UnionType
        type_node.types.all? { |t| type_exists?(t) }
      when IR::IntersectionType
        type_node.types.all? { |t| type_exists?(t) }
      when IR::NullableType
        type_exists?(type_node.inner_type)
      else
        true # Assume valid for unknown types
      end
    end

    def type_exists_by_name?(name)
      return true if %w[String Integer Float Boolean Array Hash Symbol void nil Object Numeric
                        Enumerable].include?(name)
      return true if @global_registry[name]

      false
    end

    def type_name(type_node)
      case type_node
      when IR::SimpleType
        type_node.name
      when IR::GenericType
        "#{type_node.base}<...>"
      else
        type_node.to_s
      end
    end

    def extract_type_references(definition)
      return [] unless definition

      case definition
      when IR::SimpleType
        [definition.name]
      when IR::GenericType
        [definition.base] + definition.type_args.flat_map { |t| extract_type_references(t) }
      when IR::UnionType
        definition.types.flat_map { |t| extract_type_references(t) }
      when IR::IntersectionType
        definition.types.flat_map { |t| extract_type_references(t) }
      when IR::NullableType
        extract_type_references(definition.inner_type)
      else
        []
      end
    end
  end

  # Enhanced Incremental Compiler with IR and Cross-file support
  class EnhancedIncrementalCompiler < IncrementalCompiler
    attr_reader :cross_file_checker, :ir_cache

    def initialize(compiler, cache: nil, enable_cross_file: true)
      super(compiler, cache: cache)
      @ir_cache = {} # file_path => IR::Program
      @cross_file_checker = CrossFileTypeChecker.new if enable_cross_file
    end

    # Compile with IR caching
    def compile_with_ir(file_path)
      return @compiled_files[file_path] unless needs_compile?(file_path)

      # Get IR from compiler
      ir_program = @compiler.compile_to_ir(file_path)
      @ir_cache[file_path] = ir_program

      # Register with cross-file checker
      @cross_file_checker&.register_file(file_path, ir_program)

      # Compile from IR
      result = @compiler.compile(file_path)
      @file_hashes[file_path] = file_hash(file_path)
      @compiled_files[file_path] = result

      result
    end

    # Compile all with cross-file checking
    # Returns diagnostics using unified Diagnostic format
    def compile_all_with_checking(file_paths)
      results = {}
      all_diagnostics = []

      # First pass: compile and register all files
      file_paths.each do |file_path|
        source = File.exist?(file_path) ? File.read(file_path) : nil

        begin
          results[file_path] = compile_with_ir(file_path)
        rescue TypeCheckError => e
          all_diagnostics << Diagnostic.from_type_check_error(e, file: file_path, source: source)
        rescue ParseError => e
          all_diagnostics << Diagnostic.from_parse_error(e, file: file_path, source: source)
        rescue Scanner::ScanError => e
          all_diagnostics << Diagnostic.from_scan_error(e, file: file_path, source: source)
        rescue StandardError => e
          all_diagnostics << Diagnostic.new(
            code: "TR0001",
            message: e.message,
            file: file_path,
            line: 1,
            column: 1
          )
        end
      end

      # Second pass: cross-file type checking
      if @cross_file_checker
        check_result = @cross_file_checker.check_all
        check_result[:errors].each do |e|
          all_diagnostics << Diagnostic.new(
            code: "TR2002",
            message: e[:message],
            file: e[:file],
            line: 1,
            column: 1
          )
        end
      end

      {
        results: results,
        diagnostics: all_diagnostics,
        success: all_diagnostics.empty?,
      }
    end

    # Get cached IR for a file
    def get_ir(file_path)
      @ir_cache[file_path]
    end

    # Clear all caches
    def clear
      super
      @ir_cache.clear
      @cross_file_checker&.clear
    end

    private

    def file_hash(file_path)
      return nil unless File.exist?(file_path)

      Digest::SHA256.hexdigest(File.read(file_path))
    end
  end

  # Compilation profiler
  class CompilationProfiler
    def initialize
      @timings = {}
      @call_counts = {}
    end

    def profile(name, &block)
      start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
      result = block.call
      elapsed = Process.clock_gettime(Process::CLOCK_MONOTONIC) - start

      @timings[name] ||= 0.0
      @timings[name] += elapsed

      @call_counts[name] ||= 0
      @call_counts[name] += 1

      result
    end

    def report
      puts "=== Compilation Profile ==="
      @timings.sort_by { |_, v| -v }.each do |name, time|
        calls = @call_counts[name]
        avg = time / calls
        puts "#{name}: #{format("%.3f", time)}s total, #{calls} calls, #{format("%.3f", avg * 1000)}ms avg"
      end
    end

    def reset
      @timings.clear
      @call_counts.clear
    end

    def to_h
      @timings.map do |name, time|
        {
          name: name,
          total_time: time,
          call_count: @call_counts[name],
          avg_time: time / @call_counts[name],
        }
      end
    end
  end
end
`,
  "lib/t_ruby/cli.rb": `# frozen_string_literal: true

module TRuby
  class CLI
    HELP_TEXT = <<~HELP.freeze
      t-ruby compiler (trc) v#{VERSION}

      Usage:
        trc <file.trb>           Compile a .trb file to .rb
        trc <file.rb>            Copy .rb file to build/ and generate .rbs
        trc --init               Initialize a new t-ruby project
        trc --config, -c <path>  Use custom config file
        trc --watch, -w          Watch input files and recompile on change
        trc --decl <file.trb>    Generate .d.trb declaration file
        trc --lsp                Start LSP server (for IDE integration)
        trc run <file.trb>       Run a .trb file directly (delegates to t-ruby)
        trc update               Update t-ruby to the latest version
        trc --version, -v        Show version (and check for updates)
        trc --help, -h           Show this help

      Examples:
        trc hello.trb            Compile hello.trb to build/hello.rb
        trc utils.rb             Copy utils.rb to build/ and generate utils.rbs
        trc --init               Create trbconfig.yml and src/, build/ directories
        trc -c custom.yml file.trb  Compile with custom config file
        trc -w                   Watch all .trb and .rb files in current directory
        trc -w src/              Watch all .trb and .rb files in src/ directory
        trc --watch hello.trb    Watch specific file for changes
        trc --decl hello.trb     Generate hello.d.trb declaration file
        trc --lsp                Start language server for VS Code
        trc run hello.trb        Run hello.trb directly without compilation
    HELP

    def self.run(args)
      new(args).run
    end

    def initialize(args)
      @args = args
    end

    def run
      if @args.empty? || @args.include?("--help") || @args.include?("-h")
        puts HELP_TEXT
        return
      end

      if @args.include?("--version") || @args.include?("-v")
        puts "trc #{VERSION}"
        check_for_updates
        return
      end

      if @args.include?("update")
        update_gem
        return
      end

      if @args.include?("--init")
        init_project
        return
      end

      if @args.include?("--lsp")
        start_lsp_server
        return
      end

      if @args.first == "run"
        run_direct
        return
      end

      if @args.include?("--watch") || @args.include?("-w")
        start_watch_mode
        return
      end

      if @args.include?("--decl")
        input_file = @args[@args.index("--decl") + 1]
        generate_declaration(input_file)
        return
      end

      # Extract config path if --config or -c flag is present
      config_path = extract_config_path

      # Get input file (first non-flag argument)
      input_file = find_input_file
      compile(input_file, config_path: config_path)
    end

    private

    def check_for_updates
      result = VersionChecker.check
      return unless result

      puts ""
      puts "New version available: #{result[:latest]} (current: #{result[:current]})"
      puts "Run 'trc update' to update"
    end

    def update_gem
      puts "Updating t-ruby..."
      if VersionChecker.update
        puts "Successfully updated t-ruby!"
      else
        puts "Update failed. Try: gem install t-ruby"
      end
    end

    def init_project
      config_file = "trbconfig.yml"
      src_dir = "src"
      build_dir = "build"

      created = []
      skipped = []

      # Create trbconfig.yml with new schema
      if File.exist?(config_file)
        skipped << config_file
      else
        File.write(config_file, <<~YAML)
          # T-Ruby configuration file
          # See: https://type-ruby.github.io/docs/getting-started/project-configuration

          source:
            include:
              - #{src_dir}
            exclude: []
            extensions:
              - ".trb"
              - ".rb"

          output:
            ruby_dir: #{build_dir}
            # rbs_dir: sig  # Optional: separate directory for .rbs files
            # clean_before_build: false

          compiler:
            strictness: standard  # strict | standard | permissive
            generate_rbs: true
            target_ruby: "#{RubyVersion.current.major}.#{RubyVersion.current.minor}"
            # experimental: []
            # checks:
            #   no_implicit_any: false
            #   no_unused_vars: false
            #   strict_nil: false

          watch:
            # paths: []  # Additional paths to watch
            debounce: 100
            # clear_screen: false
            # on_success: "bundle exec rspec"
        YAML
        created << config_file
      end

      # Create src/ directory
      if Dir.exist?(src_dir)
        skipped << "#{src_dir}/"
      else
        Dir.mkdir(src_dir)
        created << "#{src_dir}/"
      end

      # Create build/ directory
      if Dir.exist?(build_dir)
        skipped << "#{build_dir}/"
      else
        Dir.mkdir(build_dir)
        created << "#{build_dir}/"
      end

      # Output results
      if created.any?
        puts "Created: #{created.join(", ")}"
      end
      if skipped.any?
        puts "Skipped (already exists): #{skipped.join(", ")}"
      end
      if created.empty? && skipped.any?
        puts "Project already initialized."
      else
        puts "t-ruby project initialized successfully!"
      end
    end

    def start_lsp_server
      server = LSPServer.new
      server.run
    end

    def run_direct
      remaining_args = @args[1..] || []

      # Find t-ruby executable path
      t_ruby_bin = File.expand_path("../../bin/t-ruby", __dir__)

      # Execute t-ruby (replaces current process)
      exec(t_ruby_bin, *remaining_args)
    end

    def start_watch_mode
      # Get paths to watch (everything after --watch or -w flag)
      watch_index = @args.index("--watch") || @args.index("-w")
      paths = @args[(watch_index + 1)..]

      # Default to current directory if no paths specified
      paths = ["."] if paths.empty?

      config = Config.new
      watcher = Watcher.new(paths: paths, config: config)
      watcher.watch
    end

    def generate_declaration(input_file)
      config = Config.new
      generator = DeclarationGenerator.new

      output_path = generator.generate_file(input_file, config.out_dir)
      puts "Generated: #{input_file} -> #{output_path}"
    rescue ArgumentError => e
      puts "Error: #{e.message}"
      exit 1
    end

    def compile(input_file, config_path: nil)
      config = Config.new(config_path)
      compiler = Compiler.new(config)

      result = compiler.compile_with_diagnostics(input_file)

      if result[:success]
        puts "Compiled: #{input_file} -> #{result[:output_path]}"
      else
        formatter = DiagnosticFormatter.new(use_colors: $stdout.tty?)
        result[:diagnostics].each do |diagnostic|
          puts formatter.format(diagnostic)
        end
        puts
        puts formatter.send(:format_summary, result[:diagnostics])
        exit 1
      end
    end

    # Extract config path from --config or -c flag
    def extract_config_path
      config_index = @args.index("--config") || @args.index("-c")
      return nil unless config_index

      @args[config_index + 1]
    end

    # Find the input file (first non-flag argument)
    def find_input_file
      skip_next = false
      @args.each do |arg|
        if skip_next
          skip_next = false
          next
        end

        # Skip known flags with arguments
        if %w[--config -c --decl].include?(arg)
          skip_next = true
          next
        end

        # Skip flags without arguments
        next if arg.start_with?("-")

        return arg
      end
      nil
    end
  end
end
`,
  "lib/t_ruby/code_emitter.rb": `# frozen_string_literal: true

module TRuby
  # Version-specific code transformation strategies
  #
  # @example
  #   emitter = CodeEmitter.for_version("4.0")
  #   result = emitter.transform(source)
  #
  module CodeEmitter
    # Factory method to get appropriate emitter for target Ruby version
    #
    # @param target_ruby [String] target Ruby version (e.g., "3.0", "4.0")
    # @return [Base] appropriate emitter instance
    def self.for_version(target_ruby)
      version = RubyVersion.parse(target_ruby)

      if version.numbered_parameters_raise_error?
        Ruby40.new(version)
      elsif version.supports_it_parameter?
        Ruby34.new(version)
      elsif version.supports_anonymous_block_forwarding?
        Ruby31.new(version)
      else
        Ruby30.new(version)
      end
    end

    # Base class for version-specific code emitters
    class Base
      attr_reader :version

      def initialize(version)
        @version = version
      end

      # Apply all transformations for this version
      #
      # @param source [String] source code to transform
      # @return [String] transformed source code
      def transform(source)
        result = source.dup
        result = transform_numbered_params(result)
        transform_block_forwarding(result)
      end

      # Transform numbered block parameters (_1, _2, etc.)
      # Default: no transformation
      #
      # @param source [String] source code
      # @return [String] transformed source code
      def transform_numbered_params(source)
        source
      end

      # Transform block forwarding syntax
      # Default: no transformation
      #
      # @param source [String] source code
      # @return [String] transformed source code
      def transform_block_forwarding(source)
        source
      end

      # Check if this version supports the \`it\` implicit block parameter
      #
      # @return [Boolean]
      def supports_it?
        false
      end

      # Check if numbered parameters raise NameError in this version
      #
      # @return [Boolean]
      def numbered_params_error?
        false
      end
    end

    # Ruby 3.0 emitter - baseline, no transformations
    class Ruby30 < Base
      # Ruby 3.0 uses standard syntax, no transformations needed
    end

    # Ruby 3.1+ emitter - supports anonymous block forwarding
    class Ruby31 < Base
      # Transform \`def foo(&block) ... bar(&block)\` to \`def foo(&) ... bar(&)\`
      #
      # Only transforms when the block parameter is ONLY used for forwarding,
      # not when it's called directly (e.g., block.call)
      def transform_block_forwarding(source)
        result = source.dup

        # Find method definitions with block parameters
        # Pattern: def method_name(&block_name)
        result.gsub!(/def\\s+(\\w+[?!=]?)\\s*\\(([^)]*?)&(\\w+)\\s*\\)/) do |_match|
          method_name = ::Regexp.last_match(1)
          other_params = ::Regexp.last_match(2)
          block_name = ::Regexp.last_match(3)

          # Find the method body to check block usage
          method_start = ::Regexp.last_match.begin(0)
          remaining = result[method_start..]

          # Check if block is only used for forwarding (not called directly)
          if block_only_forwarded?(remaining, block_name)
            "def #{method_name}(#{other_params}&)"
          else
            "def #{method_name}(#{other_params}&#{block_name})"
          end
        end

        # Replace block forwarding calls with anonymous forwarding
        # This is a simplified approach - in practice we'd need proper scope tracking
        result.gsub!(/(\\w+)\\s*\\(\\s*&(\\w+)\\s*\\)/) do |match|
          call_name = ::Regexp.last_match(1)
          ::Regexp.last_match(2)

          # Check if this block name was converted to anonymous
          if result.include?("def ") && result.include?("(&)")
            "#{call_name}(&)"
          else
            match
          end
        end

        result
      end

      private

      # Check if a block parameter is only used for forwarding
      def block_only_forwarded?(method_body, block_name)
        # Simple heuristic: if block_name appears with .call or without &, it's not just forwarding
        # Look for patterns like: block_name.call, block_name.(), yield

        # Extract method body (until next def or end of class)
        lines = method_body.lines
        depth = 0
        body_lines = []

        lines.each do |line|
          depth += 1 if line.match?(/\\b(def|class|module|do|begin|case|if|unless|while|until)\\b/)
          depth -= 1 if line.match?(/\\bend\\b/)
          body_lines << line
          break if depth <= 0 && body_lines.length > 1
        end

        body = body_lines.join

        # Check for direct block usage
        return false if body.match?(/\\b#{block_name}\\s*\\./)     # block.call, block.(), etc.
        return false if body.match?(/\\b#{block_name}\\s*\\[/)     # block[args]
        return false if body.match?(/\\byield\\b/)                # yield instead of forwarding

        # Only &block_name patterns - this is forwarding
        true
      end
    end

    # Ruby 3.4+ emitter - supports \`it\` implicit block parameter
    class Ruby34 < Ruby31
      def supports_it?
        true
      end

      # Ruby 3.4 still supports _1 syntax, so no transformation needed by default
      # Users can opt-in to using \`it\` style if they want
    end

    # Ruby 4.0+ emitter - _1 raises NameError, must use \`it\`
    class Ruby40 < Ruby34
      def numbered_params_error?
        true
      end

      # Transform numbered parameters to appropriate syntax
      #
      # - Single _1 → it
      # - Multiple (_1, _2) → explicit |k, v| params
      def transform_numbered_params(source)
        result = source.dup

        # Simple approach: replace all _1 with it when it's the only numbered param in scope
        # For complex cases with _2+, we'd need proper parsing
        # For now, do a global replacement if _2 etc are not present
        if result.match?(/\\b_[2-9]\\b/)
          # Has multiple numbered params - need to convert to explicit params
          # This is a complex case that requires proper block parsing
          transform_multi_numbered_params(result)
        else
          # Only _1 is used - simple replacement
          result.gsub(/\\b_1\\b/, "it")
        end
      end

      private

      def transform_multi_numbered_params(source)
        result = source.dup

        # Find blocks and transform them
        # Use a recursive approach with placeholder replacement

        # Replace innermost blocks first
        loop do
          changed = false
          result = result.gsub(/\\{([^{}]*)\\}/) do |block|
            content = ::Regexp.last_match(1)
            max_param = find_max_numbered_param(content)

            if max_param > 1
              # Multiple params - convert to explicit
              param_names = generate_param_names(max_param)
              new_content = content.dup
              (1..max_param).each do |i|
                new_content.gsub!(/\\b_#{i}\\b/, param_names[i - 1])
              end
              changed = true
              "{ |#{param_names.join(", ")}| #{new_content.strip} }"
            elsif max_param == 1
              # Single _1 - convert to it
              changed = true
              "{ #{content.gsub(/\\b_1\\b/, "it").strip} }"
            else
              block
            end
          end
          break unless changed
        end

        result
      end

      def find_max_numbered_param(content)
        max = 0
        content.scan(/\\b_(\\d+)\\b/) do |match|
          num = match[0].to_i
          max = num if num > max
        end
        max
      end

      def generate_param_names(count)
        # Generate simple parameter names: a, b, c, ... or k, v for 2
        if count == 2
          %w[k v]
        else
          ("a".."z").take(count)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/compiler.rb": `# frozen_string_literal: true

require "fileutils"

module TRuby
  # Pattern for method names that supports Unicode characters
  # \\p{L} matches any Unicode letter, \\p{N} matches any Unicode number
  IDENTIFIER_CHAR = '[\\p{L}\\p{N}_]'
  METHOD_NAME_PATTERN = "#{IDENTIFIER_CHAR}+[?!]?".freeze
  # Visibility modifiers for method definitions
  VISIBILITY_PATTERN = '(?:(?:private|protected|public)\\s+)?'

  class Compiler
    attr_reader :declaration_loader, :optimizer

    def initialize(config = nil, optimize: true)
      @config = config || Config.new
      @optimize = optimize
      @declaration_loader = DeclarationLoader.new
      @optimizer = IR::Optimizer.new if optimize
      @type_inferrer = ASTTypeInferrer.new if type_check?
      setup_declaration_paths if @config
    end

    def type_check?
      @config.type_check?
    end

    def compile(input_path)
      unless File.exist?(input_path)
        raise ArgumentError, "File not found: #{input_path}"
      end

      # Handle .rb files separately
      if input_path.end_with?(".rb")
        return copy_ruby_file(input_path)
      end

      unless input_path.end_with?(".trb")
        raise ArgumentError, "Expected .trb or .rb file, got: #{input_path}"
      end

      source = File.read(input_path)

      # Parse with IR support
      parser = Parser.new(source)
      parser.parse

      # Run type checking if enabled
      if type_check? && parser.ir_program
        check_types(parser.ir_program, input_path)
      end

      # Transform source to Ruby code
      output = transform_with_ir(source, parser)

      # Compute output path (respects preserve_structure setting)
      output_path = compute_output_path(input_path, @config.ruby_dir, ".rb")
      FileUtils.mkdir_p(File.dirname(output_path))

      File.write(output_path, output)

      # Generate .rbs file if enabled in config
      if @config.compiler["generate_rbs"]
        rbs_path = compute_output_path(input_path, @config.rbs_dir, ".rbs")
        FileUtils.mkdir_p(File.dirname(rbs_path))
        generate_rbs_from_ir_to_path(rbs_path, parser.ir_program)
      end

      # Generate .d.trb file if enabled in config (legacy support)
      # TODO: Add compiler.generate_dtrb option in future
      if @config.compiler.key?("generate_dtrb") && @config.compiler["generate_dtrb"]
        generate_dtrb_file(input_path, @config.ruby_dir)
      end

      output_path
    end

    # Compile a file and return result with diagnostics
    # This is the unified compilation interface for CLI and Watcher
    # @param input_path [String] Path to the input file
    # @return [Hash] Result with :success, :output_path, :diagnostics keys
    def compile_with_diagnostics(input_path)
      source = File.exist?(input_path) ? File.read(input_path) : nil
      all_diagnostics = []

      # Run analyze first to get all diagnostics (colon spacing, etc.)
      if source
        all_diagnostics = analyze(source, file: input_path)
      end

      begin
        output_path = compile(input_path)
        # Compilation succeeded, but we may still have diagnostics from analyze
        {
          success: all_diagnostics.empty?,
          output_path: all_diagnostics.empty? ? output_path : nil,
          diagnostics: all_diagnostics,
        }
      rescue TypeCheckError => e
        # Skip if already reported by analyze (same message and location)
        new_diag = Diagnostic.from_type_check_error(e, file: input_path, source: source)
        unless all_diagnostics.any? { |d| d.message == new_diag.message && d.line == new_diag.line }
          all_diagnostics << new_diag
        end
        {
          success: false,
          output_path: nil,
          diagnostics: all_diagnostics,
        }
      rescue ParseError => e
        new_diag = Diagnostic.from_parse_error(e, file: input_path, source: source)
        unless all_diagnostics.any? { |d| d.message == new_diag.message && d.line == new_diag.line }
          all_diagnostics << new_diag
        end
        {
          success: false,
          output_path: nil,
          diagnostics: all_diagnostics,
        }
      rescue Scanner::ScanError => e
        new_diag = Diagnostic.from_scan_error(e, file: input_path, source: source)
        unless all_diagnostics.any? { |d| d.message == new_diag.message && d.line == new_diag.line }
          all_diagnostics << new_diag
        end
        {
          success: false,
          output_path: nil,
          diagnostics: all_diagnostics,
        }
      rescue ArgumentError => e
        all_diagnostics << Diagnostic.new(
          code: "TR0001",
          message: e.message,
          file: input_path,
          severity: Diagnostic::SEVERITY_ERROR
        )
        {
          success: false,
          output_path: nil,
          diagnostics: all_diagnostics,
        }
      end
    end

    # Analyze source code without compiling - returns diagnostics only
    # This is the unified analysis interface for LSP and other tools
    # @param source [String] T-Ruby source code
    # @param file [String] File path for error reporting (optional)
    # @return [Array<Diagnostic>] Array of diagnostic objects
    def analyze(source, file: "<source>")
      diagnostics = []
      source_lines = source.split("\\n")

      # Run ErrorHandler checks (syntax validation, duplicate definitions, etc.)
      error_handler = ErrorHandler.new(source)
      errors = error_handler.check
      errors.each do |error|
        # Parse line number from "Line N: message" format
        next unless error =~ /^Line (\\d+):\\s*(.+)$/

        line_num = Regexp.last_match(1).to_i
        message = Regexp.last_match(2)
        source_line = source_lines[line_num - 1] if line_num.positive?
        diagnostics << Diagnostic.new(
          code: "TR1002",
          message: message,
          file: file,
          line: line_num,
          column: 1,
          source_line: source_line,
          severity: Diagnostic::SEVERITY_ERROR
        )
      end

      # Run TokenDeclarationParser for colon spacing and declaration syntax validation
      begin
        scanner = Scanner.new(source)
        tokens = scanner.scan_all
        decl_parser = ParserCombinator::TokenDeclarationParser.new
        decl_parser.parse_program(tokens)

        if decl_parser.has_errors?
          decl_parser.errors.each do |err|
            source_line = source_lines[err.line - 1] if err.line.positive? && err.line <= source_lines.length
            diagnostics << Diagnostic.new(
              code: "TR1003",
              message: err.message,
              file: file,
              line: err.line,
              column: err.column,
              source_line: source_line,
              severity: Diagnostic::SEVERITY_ERROR
            )
          end
        end
      rescue Scanner::ScanError
        # Scanner errors will be caught below in the main parse section
      rescue StandardError
        # Ignore TokenDeclarationParser errors for now - regex parser is authoritative
      end

      begin
        # Parse source with regex-based parser for IR generation
        parser = Parser.new(source)
        parser.parse

        # Run type checking if enabled and IR is available
        if type_check? && parser.ir_program
          begin
            check_types(parser.ir_program, file)
          rescue TypeCheckError => e
            diagnostics << Diagnostic.from_type_check_error(e, file: file, source: source)
          end
        end
      rescue ParseError => e
        diagnostics << Diagnostic.from_parse_error(e, file: file, source: source)
      rescue Scanner::ScanError => e
        diagnostics << Diagnostic.from_scan_error(e, file: file, source: source)
      rescue StandardError => e
        diagnostics << Diagnostic.new(
          code: "TR0001",
          message: e.message,
          file: file,
          line: 1,
          column: 1,
          severity: Diagnostic::SEVERITY_ERROR
        )
      end

      diagnostics
    end

    # Compile T-Ruby source code from a string (useful for WASM/playground)
    # @param source [String] T-Ruby source code
    # @param options [Hash] Options for compilation
    # @option options [Boolean] :rbs Whether to generate RBS output (default: true)
    # @return [Hash] Result with :ruby, :rbs, :errors keys
    def compile_string(source, options = {})
      generate_rbs = options.fetch(:rbs, true)

      parser = Parser.new(source)
      parser.parse

      # Transform source to Ruby code
      ruby_output = transform_with_ir(source, parser)

      # Generate RBS if requested
      rbs_output = ""
      if generate_rbs && parser.ir_program
        generator = IR::RBSGenerator.new
        rbs_output = generator.generate(parser.ir_program)
      end

      {
        ruby: ruby_output,
        rbs: rbs_output,
        errors: [],
      }
    rescue ParseError => e
      {
        ruby: "",
        rbs: "",
        errors: [e.message],
      }
    rescue StandardError => e
      {
        ruby: "",
        rbs: "",
        errors: ["Compilation error: #{e.message}"],
      }
    end

    # Compile to IR without generating output files
    def compile_to_ir(input_path)
      unless File.exist?(input_path)
        raise ArgumentError, "File not found: #{input_path}"
      end

      source = File.read(input_path)
      parser = Parser.new(source)
      parser.parse
      parser.ir_program
    end

    # Compile from IR program directly
    def compile_from_ir(ir_program, output_path)
      out_dir = File.dirname(output_path)
      FileUtils.mkdir_p(out_dir)

      # Optimize if enabled
      program = ir_program
      if @optimize && @optimizer
        result = @optimizer.optimize(program)
        program = result[:program]
      end

      # Generate Ruby code
      generator = IRCodeGenerator.new
      output = generator.generate(program)
      File.write(output_path, output)

      output_path
    end

    # Load external declarations from a file
    def load_declaration(name)
      @declaration_loader.load(name)
    end

    # Add a search path for declaration files
    def add_declaration_path(path)
      @declaration_loader.add_search_path(path)
    end

    # Get optimization statistics (only available after IR compilation)
    def optimization_stats
      @optimizer&.stats
    end

    # Compute output path for a source file
    # @param input_path [String] path to source file
    # @param output_dir [String] base output directory
    # @param new_extension [String] new file extension (e.g., ".rb", ".rbs")
    # @return [String] computed output path (always preserves directory structure)
    def compute_output_path(input_path, output_dir, new_extension)
      relative = compute_relative_path(input_path)
      base = relative.sub(/\\.[^.]+$/, new_extension)
      File.join(output_dir, base)
    end

    # Compute relative path from source directory
    # @param input_path [String] path to source file
    # @return [String] relative path preserving directory structure
    def compute_relative_path(input_path)
      # Use realpath to resolve symlinks (e.g., /var vs /private/var on macOS)
      absolute_input = resolve_path(input_path)
      source_dirs = @config.source_include

      # Check if file is inside any source_include directory
      if source_dirs.size > 1
        # Multiple source directories: include the source dir name in output
        # src/models/user.trb → src/models/user.trb
        source_dirs.each do |src_dir|
          absolute_src = resolve_path(src_dir)
          next unless absolute_input.start_with?("#{absolute_src}/")

          # Return path relative to parent of source dir (includes src dir name)
          parent_of_src = File.dirname(absolute_src)
          return absolute_input.sub("#{parent_of_src}/", "")
        end
      else
        # Single source directory: exclude the source dir name from output
        # src/models/user.trb → models/user.trb
        src_dir = source_dirs.first
        if src_dir
          absolute_src = resolve_path(src_dir)
          if absolute_input.start_with?("#{absolute_src}/")
            return absolute_input.sub("#{absolute_src}/", "")
          end
        end
      end

      # File outside source directories: use path relative to current working directory
      # external/foo.trb → external/foo.trb
      cwd = resolve_path(".")
      if absolute_input.start_with?("#{cwd}/")
        return absolute_input.sub("#{cwd}/", "")
      end

      # Absolute path from outside cwd: use basename only
      File.basename(input_path)
    end

    private

    # Check types in IR program and raise TypeCheckError if mismatches found
    # @param ir_program [IR::Program] IR program to check
    # @param file_path [String] source file path for error messages
    def check_types(ir_program, file_path)
      ir_program.declarations.each do |decl|
        case decl
        when IR::MethodDef
          check_method_return_type(decl, nil, file_path)
        when IR::ClassDecl
          decl.body.each do |member|
            check_method_return_type(member, decl, file_path) if member.is_a?(IR::MethodDef)
          end
        end
      end
    end

    # Check if method's inferred return type matches declared return type
    # @param method [IR::MethodDef] method to check
    # @param class_def [IR::ClassDef, nil] containing class if any
    # @param file_path [String] source file path for error messages
    def check_method_return_type(method, class_def, file_path)
      # Skip if no explicit return type annotation
      return unless method.return_type

      declared_type = normalize_type(method.return_type.to_rbs)

      # Create type environment for the class context
      class_env = create_class_env(class_def) if class_def

      # Infer actual return type
      inferred_type = @type_inferrer.infer_method_return_type(method, class_env)
      inferred_type = normalize_type(inferred_type || "nil")

      # Check compatibility
      return if types_compatible?(inferred_type, declared_type)

      location = method.location ? "#{file_path}:#{method.location}" : file_path
      method_name = class_def ? "#{class_def.name}##{method.name}" : method.name

      raise TypeCheckError.new(
        message: "Return type mismatch in method '#{method_name}': " \\
                 "declared '#{declared_type}' but inferred '#{inferred_type}'",
        location: location,
        expected: declared_type,
        actual: inferred_type
      )
    end

    # Create type environment for class context
    # @param class_def [IR::ClassDecl] class declaration
    # @return [TypeEnv] type environment with instance variables
    def create_class_env(class_def)
      env = TypeEnv.new

      # Register instance variables from class
      class_def.instance_vars&.each do |ivar|
        type = ivar.type_annotation&.to_rbs || "untyped"
        env.define_instance_var(ivar.name, type)
      end

      env
    end

    # Normalize type string for comparison
    # @param type [String] type string
    # @return [String] normalized type string
    def normalize_type(type)
      return "untyped" if type.nil?

      normalized = type.to_s.strip

      # Normalize boolean types (bool/Boolean/TrueClass/FalseClass -> bool)
      case normalized
      when "Boolean", "TrueClass", "FalseClass"
        "bool"
      else
        normalized
      end
    end

    # Check if inferred type is compatible with declared type
    # @param inferred [String] inferred type
    # @param declared [String] declared type
    # @return [Boolean] true if compatible
    def types_compatible?(inferred, declared)
      # Exact match
      return true if inferred == declared

      # untyped is compatible with anything
      return true if inferred == "untyped" || declared == "untyped"

      # void is compatible with anything (no return value check)
      return true if declared == "void"

      # nil is compatible with nullable types
      return true if inferred == "nil" && declared.end_with?("?")

      # Subtype relationships
      return true if subtype_of?(inferred, declared)

      # Handle generic types (e.g., Array[untyped] is compatible with Array[String])
      if inferred.include?("[") && declared.include?("[")
        inferred_base = inferred.split("[").first
        declared_base = declared.split("[").first
        if inferred_base == declared_base
          # Extract type arguments
          inferred_args = inferred[/\\[(.+)\\]/, 1]
          declared_args = declared[/\\[(.+)\\]/, 1]
          # untyped type argument is compatible with any type argument
          return true if inferred_args == "untyped" || declared_args == "untyped"
        end
      end

      # Handle union types in declared
      if declared.include?("|")
        declared_types = declared.split("|").map(&:strip)
        return true if declared_types.include?(inferred)
        return true if declared_types.any? { |t| types_compatible?(inferred, t) }
      end

      # Handle union types in inferred - all must be compatible
      if inferred.include?("|")
        inferred_types = inferred.split("|").map(&:strip)
        return inferred_types.all? { |t| types_compatible?(t, declared) }
      end

      false
    end

    # Check if subtype is a subtype of supertype
    # @param subtype [String] potential subtype
    # @param supertype [String] potential supertype
    # @return [Boolean] true if subtype
    def subtype_of?(subtype, supertype)
      # Handle nullable - X is subtype of X?
      return true if supertype.end_with?("?") && supertype[0..-2] == subtype

      # Numeric hierarchy
      return true if subtype == "Integer" && supertype == "Numeric"
      return true if subtype == "Float" && supertype == "Numeric"

      # Object is supertype of everything
      return true if supertype == "Object"

      false
    end

    # Resolve path to absolute path, following symlinks
    # Falls back to expand_path if realpath fails (e.g., file doesn't exist yet)
    def resolve_path(path)
      File.realpath(path)
    rescue Errno::ENOENT
      File.expand_path(path)
    end

    def setup_declaration_paths
      # Add default declaration paths
      @declaration_loader.add_search_path(@config.out_dir)
      @declaration_loader.add_search_path(@config.src_dir)
      @declaration_loader.add_search_path("./types")
      @declaration_loader.add_search_path("./lib/types")
    end

    # Transform using IR system
    def transform_with_ir(source, parser)
      ir_program = parser.ir_program
      return source unless ir_program

      # Run optimization passes if enabled
      if @optimize && @optimizer
        result = @optimizer.optimize(ir_program)
        ir_program = result[:program]
      end

      # Generate Ruby code using IR-aware generator with target Ruby version
      generator = IRCodeGenerator.new(target_ruby: @config.target_ruby)
      generator.generate_with_source(ir_program, source)
    end

    # Generate RBS from IR to a specific path
    def generate_rbs_from_ir_to_path(rbs_path, ir_program)
      return unless ir_program

      generator = IR::RBSGenerator.new
      rbs_content = generator.generate(ir_program)
      File.write(rbs_path, rbs_content) unless rbs_content.strip.empty?
    end

    def generate_dtrb_file(input_path, out_dir)
      dtrb_path = compute_output_path(input_path, out_dir, DeclarationGenerator::DECLARATION_EXTENSION)
      FileUtils.mkdir_p(File.dirname(dtrb_path))

      generator = DeclarationGenerator.new
      generator.generate_file_to_path(input_path, dtrb_path)
    end

    # Copy .rb file to output directory and generate .rbs signature
    def copy_ruby_file(input_path)
      unless File.exist?(input_path)
        raise ArgumentError, "File not found: #{input_path}"
      end

      # Compute output path (respects preserve_structure setting)
      output_path = compute_output_path(input_path, @config.ruby_dir, ".rb")
      FileUtils.mkdir_p(File.dirname(output_path))

      # Copy the .rb file to output directory
      FileUtils.cp(input_path, output_path)

      # Generate .rbs file if enabled in config
      if @config.compiler["generate_rbs"]
        rbs_path = compute_output_path(input_path, @config.rbs_dir, ".rbs")
        FileUtils.mkdir_p(File.dirname(rbs_path))
        generate_rbs_from_ruby_to_path(rbs_path, input_path)
      end

      output_path
    end

    # Generate RBS from Ruby file using rbs prototype to a specific path
    def generate_rbs_from_ruby_to_path(rbs_path, input_path)
      result = \`rbs prototype rb #{input_path} 2>/dev/null\`
      File.write(rbs_path, result) unless result.strip.empty?
    end
  end

  # IR-aware code generator for source-preserving transformation
  class IRCodeGenerator
    attr_reader :emitter

    # @param target_ruby [String] target Ruby version (e.g., "3.0", "4.0")
    def initialize(target_ruby: "3.0")
      @output = []
      @emitter = CodeEmitter.for_version(target_ruby)
    end

    # Generate Ruby code from IR program
    def generate(program)
      generator = IR::CodeGenerator.new
      generator.generate(program)
    end

    # Generate Ruby code while preserving source structure
    def generate_with_source(program, source)
      result = source.dup

      # Collect type alias names to remove
      program.declarations
             .select { |d| d.is_a?(IR::TypeAlias) }
             .map(&:name)

      # Collect interface names to remove
      program.declarations
             .select { |d| d.is_a?(IR::Interface) }
             .map(&:name)

      # Remove type alias definitions
      result = result.gsub(/^\\s*type\\s+\\w+\\s*=\\s*.+?$\\n?/, "")

      # Remove interface definitions (multi-line)
      result = result.gsub(/^\\s*interface\\s+\\w+.*?^\\s*end\\s*$/m, "")

      # Remove parameter type annotations using IR info
      # Enhanced: Handle complex types (generics, unions, etc.)
      result = erase_parameter_types(result)

      # Remove return type annotations
      result = erase_return_types(result)

      # Apply version-specific transformations
      result = @emitter.transform(result)

      # Clean up extra blank lines
      result.gsub(/\\n{3,}/, "\\n\\n")
    end

    private

    # Erase parameter type annotations
    def erase_parameter_types(source)
      result = source.dup

      # Match function definitions and remove type annotations from parameters
      # Also supports visibility modifiers: private def, protected def, public def
      result.gsub!(/^(\\s*#{TRuby::VISIBILITY_PATTERN}def\\s+#{TRuby::METHOD_NAME_PATTERN}\\s*\\()([^)]+)(\\)\\s*)(?::\\s*[^\\n]+)?(\\s*$)/) do |_match|
        indent = ::Regexp.last_match(1)
        params = ::Regexp.last_match(2)
        close_paren = ::Regexp.last_match(3)
        ending = ::Regexp.last_match(4)

        # Remove type annotations from each parameter
        cleaned_params = remove_param_types(params)

        "#{indent}#{cleaned_params}#{close_paren.rstrip}#{ending}"
      end

      result
    end

    # Remove type annotations from parameter list
    def remove_param_types(params_str)
      return params_str if params_str.strip.empty?

      params = []
      current = ""
      depth = 0
      brace_depth = 0

      params_str.each_char do |char|
        case char
        when "<", "[", "("
          depth += 1
          current += char
        when ">", "]", ")"
          depth -= 1
          current += char
        when "{"
          brace_depth += 1
          current += char
        when "}"
          brace_depth -= 1
          current += char
        when ","
          if depth.zero? && brace_depth.zero?
            cleaned = clean_param(current.strip)
            params.concat(Array(cleaned)) if cleaned
            current = ""
          else
            current += char
          end
        else
          current += char
        end
      end

      cleaned = clean_param(current.strip) unless current.empty?
      params.concat(Array(cleaned)) if cleaned
      params.join(", ")
    end

    # Clean a single parameter (remove type annotation, preserve default value)
    # Returns String or Array of Strings (for keyword args group)
    def clean_param(param)
      param = param.strip
      return nil if param.empty?

      # 0. 블록 파라미터: &name: Type -> &name
      if param.start_with?("&")
        match = param.match(/^&(\\w+)(?::\\s*.+)?$/)
        return "&#{match[1]}" if match

        return param
      end

      # 1. 더블 스플랫: **name: Type -> **name
      if param.start_with?("**")
        match = param.match(/^\\*\\*(\\w+)(?::\\s*.+)?$/)
        return "**#{match[1]}" if match

        return param
      end

      # 2. 키워드 인자 그룹: { ... } 또는 { ... }: InterfaceName
      if param.start_with?("{")
        return clean_keyword_args_group(param)
      end

      # 3. Hash 리터럴: name: { ... } -> name
      if param.match?(/^\\w+:\\s*\\{/)
        match = param.match(/^(\\w+):\\s*\\{.+\\}(?::\\s*\\w+)?$/)
        return match[1] if match

        return param
      end

      # 4. 일반 파라미터: name: Type = value -> name = value 또는 name: Type -> name
      # Match: name: Type = value (with default value)
      if (match = param.match(/^(#{TRuby::IDENTIFIER_CHAR}+)\\s*:\\s*.+?\\s*(=\\s*.+)$/))
        "#{match[1]} #{match[2]}"
      # Match: name: Type (without default value)
      elsif (match = param.match(/^(#{TRuby::IDENTIFIER_CHAR}+)\\s*:/))
        match[1]
      else
        param
      end
    end

    # 키워드 인자 그룹을 Ruby 키워드 인자로 변환
    # { name: String, age: Integer = 0 } -> name:, age: 0
    # { name:, age: 0 }: UserParams -> name:, age: 0
    def clean_keyword_args_group(param)
      # { ... }: InterfaceName 또는 { ... } 형태 파싱
      interface_match = param.match(/^\\{(.+)\\}\\s*:\\s*\\w+\\s*$/)
      inline_match = param.match(/^\\{(.+)\\}\\s*$/) unless interface_match

      inner_content = if interface_match
                        interface_match[1]
                      elsif inline_match
                        inline_match[1]
                      else
                        return param
                      end

      # 내부 파라미터 분리
      parts = split_nested_content(inner_content)
      keyword_params = []

      parts.each do |part|
        part = part.strip
        next if part.empty?

        if interface_match
          # interface 참조: name: default_value 또는 name:
          if (match = part.match(/^(\\w+):\\s*(.*)$/))
            name = match[1]
            default_value = match[2].strip
            keyword_params << if default_value.empty?
                                "#{name}:"
                              else
                                "#{name}: #{default_value}"
                              end
          end
        elsif (match = part.match(/^(\\w+):\\s*(.+)$/))
          # 인라인 타입: name: Type = default 또는 name: Type
          name = match[1]
          type_and_default = match[2].strip

          # Type = default 분리
          default_value = extract_default_value(type_and_default)
          keyword_params << if default_value
                              "#{name}: #{default_value}"
                            else
                              "#{name}:"
                            end
        end
      end

      keyword_params
    end

    # 중첩된 내용을 콤마로 분리
    def split_nested_content(content)
      StringUtils.split_by_comma(content)
    end

    # 타입과 기본값에서 기본값만 추출
    def extract_default_value(type_and_default)
      StringUtils.extract_default_value(type_and_default)
    end

    # Erase return type annotations
    def erase_return_types(source)
      result = source.dup

      # Remove return type after parentheses: ): Type or ): Type<Foo> etc.
      result.gsub!(/\\)\\s*:\\s*[^\\n]+?(?=\\s*$)/m) do |_match|
        ")"
      end

      # Remove return type for methods without parentheses: def method_name: Type
      result.gsub!(/^(\\s*#{TRuby::VISIBILITY_PATTERN}def\\s+#{TRuby::METHOD_NAME_PATTERN})\\s*:\\s*[^\\n]+?(?=\\s*$)/m) do |_match|
        ::Regexp.last_match(1)
      end

      result
    end
  end
end
`,
  "lib/t_ruby/config.rb": `# frozen_string_literal: true

require "yaml"

module TRuby
  # Error raised when configuration is invalid
  class ConfigError < StandardError; end

  class Config
    # Valid strictness levels
    VALID_STRICTNESS = %w[strict standard permissive].freeze
    # New schema structure (v0.0.12+)
    DEFAULT_CONFIG = {
      "source" => {
        "include" => ["src"],
        "exclude" => [],
        "extensions" => [".trb"],
      },
      "output" => {
        "ruby_dir" => "build",
        "rbs_dir" => nil,
        "clean_before_build" => false,
      },
      "compiler" => {
        "strictness" => "standard",
        "generate_rbs" => true,
        "type_check" => true,
        "target_ruby" => nil, # Auto-detect from current Ruby version
        "experimental" => [],
        "checks" => {
          "no_implicit_any" => false,
          "no_unused_vars" => false,
          "strict_nil" => false,
        },
      },
      "watch" => {
        "paths" => [],
        "debounce" => 100,
        "clear_screen" => false,
        "on_success" => nil,
      },
    }.freeze

    # Legacy keys for migration detection
    LEGACY_KEYS = %w[emit paths strict include exclude].freeze

    # Always excluded (not configurable)
    AUTO_EXCLUDE = [".git"].freeze

    attr_reader :source, :output, :compiler, :watch, :version_requirement

    def initialize(config_path = nil)
      raw_config = load_raw_config(config_path)
      config = process_config(raw_config)

      @source = config["source"]
      @output = config["output"]
      @compiler = config["compiler"]
      @watch = config["watch"]
      @version_requirement = raw_config["version"]
    end

    # Get output directory for compiled Ruby files
    # @return [String] output directory path
    def ruby_dir
      @output["ruby_dir"] || "build"
    end

    # Get output directory for RBS files
    # @return [String] RBS output directory (defaults to ruby_dir if not specified)
    def rbs_dir
      @output["rbs_dir"] || ruby_dir
    end

    # Check if output directory should be cleaned before build
    # @return [Boolean] true if should clean before build
    def clean_before_build?
      @output["clean_before_build"] == true
    end

    # Get compiler strictness level
    # @return [String] one of: strict, standard, permissive
    def strictness
      @compiler["strictness"] || "standard"
    end

    # Check if RBS files should be generated
    # @return [Boolean] true if RBS files should be generated
    def generate_rbs?
      @compiler["generate_rbs"] != false
    end

    # Check if type checking is enabled
    # @return [Boolean] true if type checking is enabled (default: true)
    def type_check?
      @compiler["type_check"] != false
    end

    # Get target Ruby version
    # If not specified in config, auto-detects from current Ruby environment
    # @return [String] target Ruby version (e.g., "3.0", "3.2", "4.0")
    # @raise [UnsupportedRubyVersionError] if detected version is not supported
    def target_ruby
      configured = @compiler["target_ruby"]
      if configured
        RubyVersion.parse(configured).validate!
        configured.to_s
      else
        version = RubyVersion.current.validate!
        "#{version.major}.#{version.minor}"
      end
    end

    # Get target Ruby version as RubyVersion object
    # @return [RubyVersion] target Ruby version object
    def target_ruby_version
      RubyVersion.parse(target_ruby)
    end

    # Get list of enabled experimental features
    # @return [Array<String>] list of experimental feature names
    def experimental_features
      @compiler["experimental"] || []
    end

    # Check if a specific experimental feature is enabled
    # @param feature [String] feature name to check
    # @return [Boolean] true if feature is enabled
    def experimental_enabled?(feature)
      experimental_features.include?(feature)
    end

    # Check if no_implicit_any check is enabled
    # @return [Boolean] true if check is enabled
    def check_no_implicit_any?
      @compiler.dig("checks", "no_implicit_any") == true
    end

    # Check if no_unused_vars check is enabled
    # @return [Boolean] true if check is enabled
    def check_no_unused_vars?
      @compiler.dig("checks", "no_unused_vars") == true
    end

    # Check if strict_nil check is enabled
    # @return [Boolean] true if check is enabled
    def check_strict_nil?
      @compiler.dig("checks", "strict_nil") == true
    end

    # Get additional watch paths
    # @return [Array<String>] list of additional paths to watch
    def watch_paths
      @watch["paths"] || []
    end

    # Get watch debounce delay in milliseconds
    # @return [Integer] debounce delay in milliseconds
    def watch_debounce
      @watch["debounce"] || 100
    end

    # Check if terminal should be cleared before rebuild
    # @return [Boolean] true if terminal should be cleared
    def watch_clear_screen?
      @watch["clear_screen"] == true
    end

    # Get command to run after successful compilation
    # @return [String, nil] command to run on success
    def watch_on_success
      @watch["on_success"]
    end

    # Check if current T-Ruby version satisfies the version requirement
    # @return [Boolean] true if version is satisfied or no requirement specified
    def version_satisfied?
      return true if @version_requirement.nil?

      requirement = Gem::Requirement.new(@version_requirement)
      current = Gem::Version.new(TRuby::VERSION)
      requirement.satisfied_by?(current)
    rescue ArgumentError
      false
    end

    # Validate the configuration
    # @raise [ConfigError] if configuration is invalid
    def validate!
      validate_strictness!
      true
    end

    # Backwards compatible: alias for ruby_dir
    def out_dir
      ruby_dir
    end

    # Backwards compatible: first source.include directory
    def src_dir
      @source["include"].first || "src"
    end

    # Get source include directories
    # @return [Array<String>] list of include directories
    def source_include
      @source["include"] || ["src"]
    end

    # Get source exclude patterns
    # @return [Array<String>] list of exclude patterns
    def source_exclude
      @source["exclude"] || []
    end

    # Get source file extensions
    # @return [Array<String>] list of file extensions (e.g., [".trb", ".truby"])
    def source_extensions
      @source["extensions"] || [".trb"]
    end

    # Get include patterns for file discovery
    def include_patterns
      extensions = @source["extensions"] || [".trb"]
      extensions.map { |ext| "**/*#{ext}" }
    end

    # Get exclude patterns
    def exclude_patterns
      @source["exclude"] || []
    end

    # Find all source files matching include patterns, excluding exclude patterns
    # @return [Array<String>] list of matching file paths
    def find_source_files
      files = []

      @source["include"].each do |include_dir|
        base_dir = File.expand_path(include_dir)
        next unless Dir.exist?(base_dir)

        include_patterns.each do |pattern|
          full_pattern = File.join(base_dir, pattern)
          files.concat(Dir.glob(full_pattern))
        end
      end

      # Filter out excluded files
      files.reject { |f| excluded?(f) }.uniq.sort
    end

    # Check if a file path should be excluded
    # @param file_path [String] absolute or relative file path
    # @return [Boolean] true if file should be excluded
    def excluded?(file_path)
      relative_path = relative_to_src(file_path)
      all_exclude_patterns.any? { |pattern| matches_pattern?(relative_path, pattern) }
    end

    private

    # Validate strictness value
    def validate_strictness!
      value = strictness
      return if VALID_STRICTNESS.include?(value)

      raise ConfigError, "Invalid compiler.strictness: '#{value}'. Must be one of: #{VALID_STRICTNESS.join(", ")}"
    end

    def load_raw_config(config_path)
      raw = if config_path && File.exist?(config_path)
              YAML.safe_load_file(config_path, permitted_classes: [Symbol]) || {}
            elsif File.exist?("trbconfig.yml")
              YAML.safe_load_file("trbconfig.yml", permitted_classes: [Symbol]) || {}
            else
              {}
            end
      expand_env_vars(raw)
    end

    # Expand environment variables in config values
    # Supports \${VAR} and \${VAR:-default} syntax
    def expand_env_vars(obj)
      case obj
      when Hash
        obj.transform_values { |v| expand_env_vars(v) }
      when Array
        obj.map { |v| expand_env_vars(v) }
      when String
        expand_env_string(obj)
      else
        obj
      end
    end

    # Expand environment variables in a single string
    def expand_env_string(str)
      str.gsub(/\\$\\{([^}]+)\\}/) do |_match|
        var_expr = ::Regexp.last_match(1)
        if var_expr.include?(":-")
          var_name, default_value = var_expr.split(":-", 2)
          ENV.fetch(var_name, default_value)
        else
          ENV.fetch(var_expr, "")
        end
      end
    end

    def process_config(raw_config)
      if legacy_config?(raw_config)
        warn "DEPRECATED: trbconfig.yml uses legacy format. Please migrate to new schema (source/output/compiler/watch)."
        migrate_legacy_config(raw_config)
      else
        merge_with_defaults(raw_config)
      end
    end

    def legacy_config?(raw_config)
      LEGACY_KEYS.any? { |key| raw_config.key?(key) }
    end

    def migrate_legacy_config(raw_config)
      result = deep_dup(DEFAULT_CONFIG)

      # Migrate emit -> compiler.generate_rbs
      if raw_config["emit"]&.key?("rbs")
        result["compiler"]["generate_rbs"] = raw_config["emit"]["rbs"]
      end

      # Migrate paths -> source.include and output.ruby_dir
      if raw_config["paths"]
        if raw_config["paths"]["src"]
          src_path = raw_config["paths"]["src"].sub(%r{^\\./}, "")
          result["source"]["include"] = [src_path]
        end
        if raw_config["paths"]["out"]
          out_path = raw_config["paths"]["out"].sub(%r{^\\./}, "")
          result["output"]["ruby_dir"] = out_path
        end
      end

      # Migrate include/exclude patterns
      if raw_config["include"]
        # Keep legacy include patterns as-is for now
        result["source"]["include"] = [result["source"]["include"].first || "src"]
      end

      if raw_config["exclude"]
        result["source"]["exclude"] = raw_config["exclude"]
      end

      result
    end

    def merge_with_defaults(user_config)
      result = deep_dup(DEFAULT_CONFIG)
      deep_merge(result, user_config)
      result
    end

    def deep_dup(hash)
      hash.transform_values do |value|
        if value.is_a?(Hash)
          deep_dup(value)
        else
          (value.is_a?(Array) ? value.dup : value)
        end
      end
    end

    def deep_merge(target, source)
      source.each do |key, value|
        if value.is_a?(Hash) && target[key].is_a?(Hash)
          deep_merge(target[key], value)
        elsif !value.nil?
          target[key] = value
        end
      end
    end

    # Combine auto-excluded patterns with user-configured patterns
    def all_exclude_patterns
      patterns = AUTO_EXCLUDE.dup
      patterns << out_dir.sub(%r{^\\./}, "") # Add output directory
      patterns.concat(exclude_patterns)
      patterns.uniq
    end

    # Convert absolute path to relative path from first src_dir
    def relative_to_src(file_path)
      base_dir = File.expand_path(src_dir)
      full_path = File.expand_path(file_path)

      if full_path.start_with?(base_dir)
        full_path.sub("#{base_dir}/", "")
      else
        file_path
      end
    end

    # Check if path matches a glob/directory pattern
    def matches_pattern?(path, pattern)
      # Direct directory match (e.g., "node_modules" matches "node_modules/foo.rb")
      return true if path.start_with?("#{pattern}/") || path == pattern

      # Check if any path component matches
      path_parts = path.split("/")
      return true if path_parts.include?(pattern)

      # Glob pattern match
      File.fnmatch?(pattern, path, File::FNM_PATHNAME | File::FNM_DOTMATCH)
    end
  end
end
`,
  "lib/t_ruby/constraint_checker.rb": `# frozen_string_literal: true

module TRuby
  # Represents a type constraint
  class Constraint
    attr_reader :type, :condition, :message

    def initialize(type:, condition:, message: nil)
      @type = type
      @condition = condition
      @message = message
    end

    def to_s
      "#{@type} where #{@condition}"
    end
  end

  # Bounds constraint: T <: BaseType (T is subtype of BaseType)
  class BoundsConstraint < Constraint
    attr_reader :subtype, :supertype

    def initialize(subtype:, supertype:)
      @subtype = subtype
      @supertype = supertype
      super(type: :bounds, condition: "#{subtype} <: #{supertype}")
    end

    def satisfied?(type_hierarchy)
      type_hierarchy.subtype_of?(@subtype, @supertype)
    end
  end

  # Equality constraint: T == SpecificType
  class EqualityConstraint < Constraint
    attr_reader :left_type, :right_type

    def initialize(left_type:, right_type:)
      @left_type = left_type
      @right_type = right_type
      super(type: :equality, condition: "#{left_type} == #{right_type}")
    end

    def satisfied?(value_type)
      [@left_type, @right_type].include?(value_type)
    end
  end

  # Numeric range constraint: Integer where min..max
  class NumericRangeConstraint < Constraint
    attr_reader :base_type, :min, :max

    def initialize(base_type:, min: nil, max: nil)
      @base_type = base_type
      @min = min
      @max = max
      range_str = build_range_string
      super(type: :numeric_range, condition: range_str)
    end

    def satisfied?(value)
      return false unless value.is_a?(Numeric)
      return false if @min && value < @min
      return false if @max && value > @max

      true
    end

    def validation_code(var_name)
      conditions = []
      conditions << "#{var_name} >= #{@min}" if @min
      conditions << "#{var_name} <= #{@max}" if @max
      conditions.join(" && ")
    end

    private

    def build_range_string
      return "#{@min}..#{@max}" if @min && @max
      return ">= #{@min}" if @min
      return "<= #{@max}" if @max

      ""
    end
  end

  # Pattern constraint for strings: String where /pattern/
  class PatternConstraint < Constraint
    attr_reader :base_type, :pattern

    def initialize(base_type:, pattern:)
      @base_type = base_type
      @pattern = pattern.is_a?(Regexp) ? pattern : Regexp.new(pattern)
      super(type: :pattern, condition: "=~ #{@pattern.inspect}")
    end

    def satisfied?(value)
      return false unless value.is_a?(String)

      @pattern.match?(value)
    end

    def validation_code(var_name)
      "#{@pattern.inspect}.match?(#{var_name})"
    end
  end

  # Predicate constraint: Type where predicate_method
  class PredicateConstraint < Constraint
    attr_reader :base_type, :predicate

    def initialize(base_type:, predicate:)
      @base_type = base_type
      @predicate = predicate
      super(type: :predicate, condition: predicate.to_s)
    end

    def satisfied?(value)
      if @predicate.is_a?(Proc)
        @predicate.call(value)
      elsif @predicate.is_a?(Symbol)
        value.respond_to?(@predicate) && value.send(@predicate)
      else
        false
      end
    end

    def validation_code(var_name)
      if @predicate.is_a?(Symbol)
        "#{var_name}.#{@predicate}"
      else
        "true" # Proc constraints require runtime evaluation
      end
    end
  end

  # Length constraint for strings/arrays: Type where length condition
  class LengthConstraint < Constraint
    attr_reader :base_type, :min_length, :max_length, :exact_length

    def initialize(base_type:, min_length: nil, max_length: nil, exact_length: nil)
      @base_type = base_type
      @min_length = min_length
      @max_length = max_length
      @exact_length = exact_length
      super(type: :length, condition: build_condition)
    end

    def satisfied?(value)
      return false unless value.respond_to?(:length)

      len = value.length
      return len == @exact_length if @exact_length
      return false if @min_length && len < @min_length
      return false if @max_length && len > @max_length

      true
    end

    def validation_code(var_name)
      conditions = []
      if @exact_length
        conditions << "#{var_name}.length == #{@exact_length}"
      else
        conditions << "#{var_name}.length >= #{@min_length}" if @min_length
        conditions << "#{var_name}.length <= #{@max_length}" if @max_length
      end
      conditions.join(" && ")
    end

    private

    def build_condition
      return "length == #{@exact_length}" if @exact_length

      parts = []
      parts << "length >= #{@min_length}" if @min_length
      parts << "length <= #{@max_length}" if @max_length
      parts.join(", ")
    end
  end

  # Main constraint checker class
  class ConstraintChecker
    attr_reader :constraints, :errors

    def initialize
      @constraints = {}
      @errors = []
    end

    # Register a constrained type
    def register(name, base_type:, constraints: [])
      @constraints[name] = {
        base_type: base_type,
        constraints: constraints,
      }
    end

    # Parse constraint syntax from source
    def parse_constraint(definition)
      # Match: type Name <: BaseType where condition
      if definition.match?(/^(\\w+)\\s*<:\\s*(\\w+)\\s*where\\s*(.+)$/)
        match = definition.match(/^(\\w+)\\s*<:\\s*(\\w+)\\s*where\\s*(.+)$/)
        name = match[1]
        base_type = match[2]
        condition = match[3].strip

        constraints = parse_condition(base_type, condition)
        return { name: name, base_type: base_type, constraints: constraints }
      end

      # Match: type Name <: BaseType (bounds only)
      if definition.match?(/^(\\w+)\\s*<:\\s*(\\w+)\\s*$/)
        match = definition.match(/^(\\w+)\\s*<:\\s*(\\w+)\\s*$/)
        name = match[1]
        base_type = match[2]

        return {
          name: name,
          base_type: base_type,
          constraints: [BoundsConstraint.new(subtype: name, supertype: base_type)],
        }
      end

      # Match: type Name = BaseType where condition
      if definition.match?(/^(\\w+)\\s*=\\s*(\\w+)\\s*where\\s*(.+)$/)
        match = definition.match(/^(\\w+)\\s*=\\s*(\\w+)\\s*where\\s*(.+)$/)
        name = match[1]
        base_type = match[2]
        condition = match[3].strip

        constraints = parse_condition(base_type, condition)
        return { name: name, base_type: base_type, constraints: constraints }
      end

      nil
    end

    # Validate a value against a constrained type
    def validate(type_name, value)
      @errors = []

      unless @constraints.key?(type_name)
        @errors << "Unknown constrained type: #{type_name}"
        return false
      end

      type_info = @constraints[type_name]

      # Check base type
      unless matches_base_type?(value, type_info[:base_type])
        @errors << "Value #{value.inspect} does not match base type #{type_info[:base_type]}"
        return false
      end

      # Check all constraints
      type_info[:constraints].each do |constraint|
        unless constraint.satisfied?(value)
          @errors << "Constraint violation: #{constraint.condition}"
          return false
        end
      end

      true
    end

    # Generate validation code for runtime checking
    def generate_validation_code(type_name, var_name)
      return nil unless @constraints.key?(type_name)

      type_info = @constraints[type_name]
      conditions = []

      # Base type check
      case type_info[:base_type]
      when "Integer"
        conditions << "#{var_name}.is_a?(Integer)"
      when "String"
        conditions << "#{var_name}.is_a?(String)"
      when "Float"
        conditions << "#{var_name}.is_a?(Float)"
      when "Numeric"
        conditions << "#{var_name}.is_a?(Numeric)"
      when "Array"
        conditions << "#{var_name}.is_a?(Array)"
      end

      # Constraint checks
      type_info[:constraints].each do |constraint|
        if constraint.respond_to?(:validation_code)
          code = constraint.validation_code(var_name)
          conditions << code unless code.empty?
        end
      end

      conditions.join(" && ")
    end

    private

    def parse_condition(base_type, condition)
      constraints = []

      # Numeric comparison: > N, < N, >= N, <= N
      if condition.match?(/^([<>]=?)\\s*(\\d+(?:\\.\\d+)?)$/)
        match = condition.match(/^([<>]=?)\\s*(\\d+(?:\\.\\d+)?)$/)
        op = match[1]
        value = match[2].include?(".") ? match[2].to_f : match[2].to_i

        case op
        when ">"
          constraints << NumericRangeConstraint.new(base_type: base_type, min: value + 1)
        when ">="
          constraints << NumericRangeConstraint.new(base_type: base_type, min: value)
        when "<"
          constraints << NumericRangeConstraint.new(base_type: base_type, max: value - 1)
        when "<="
          constraints << NumericRangeConstraint.new(base_type: base_type, max: value)
        end
      end

      # Range: min..max
      if condition.match?(/^(\\d+)\\.\\.(\\d+)$/)
        match = condition.match(/^(\\d+)\\.\\.(\\d+)$/)
        constraints << NumericRangeConstraint.new(
          base_type: base_type,
          min: match[1].to_i,
          max: match[2].to_i
        )
      end

      # Pattern: /regex/
      if condition.match?(%r{^/(.+)/$})
        match = condition.match(%r{^/(.+)/$})
        constraints << PatternConstraint.new(base_type: base_type, pattern: match[1])
      end

      # Length constraint: length > N, length == N, etc.
      if condition.match?(/^length\\s*([<>=]+)\\s*(\\d+)$/)
        match = condition.match(/^length\\s*([<>=]+)\\s*(\\d+)$/)
        op = match[1]
        value = match[2].to_i

        case op
        when "=="
          constraints << LengthConstraint.new(base_type: base_type, exact_length: value)
        when ">="
          constraints << LengthConstraint.new(base_type: base_type, min_length: value)
        when "<="
          constraints << LengthConstraint.new(base_type: base_type, max_length: value)
        when ">"
          constraints << LengthConstraint.new(base_type: base_type, min_length: value + 1)
        when "<"
          constraints << LengthConstraint.new(base_type: base_type, max_length: value - 1)
        end
      end

      # Predicate: positive?, negative?, empty?, etc.
      if condition.match?(/^(\\w+)\\?$/)
        match = condition.match(/^(\\w+)\\?$/)
        constraints << PredicateConstraint.new(base_type: base_type, predicate: :"#{match[1]}?")
      end

      constraints
    end

    def matches_base_type?(value, type_name)
      case type_name
      when "Integer" then value.is_a?(Integer)
      when "String" then value.is_a?(String)
      when "Float" then value.is_a?(Float)
      when "Numeric" then value.is_a?(Numeric)
      when "Array" then value.is_a?(Array)
      when "Hash" then value.is_a?(Hash)
      when "Boolean" then [true, false].include?(value)
      when "Symbol" then value.is_a?(Symbol)
      else true # Unknown types pass through
      end
    end
  end

  # Constrained type registry for managing type constraints
  class ConstrainedTypeRegistry
    attr_reader :types

    def initialize
      @types = {}
      @checker = ConstraintChecker.new
    end

    # Register a constrained type from parsed definition
    def register(name, base_type:, constraints: [])
      @types[name] = {
        base_type: base_type,
        constraints: constraints,
        defined_at: caller_locations(1, 1).first,
      }
      @checker.register(name, base_type: base_type, constraints: constraints)
    end

    # Parse and register from source line
    def register_from_source(line)
      result = @checker.parse_constraint(line)
      return false unless result

      register(result[:name], base_type: result[:base_type], constraints: result[:constraints])
      true
    end

    # Check if a type is registered
    def registered?(name)
      @types.key?(name)
    end

    # Get type info
    def get(name)
      @types[name]
    end

    # Validate value against type
    def validate(type_name, value)
      @checker.validate(type_name, value)
    end

    # Get validation errors
    def errors
      @checker.errors
    end

    # Generate validation code
    def validation_code(type_name, var_name)
      @checker.generate_validation_code(type_name, var_name)
    end

    # List all registered types
    def list
      @types.keys
    end

    # Clear all registrations
    def clear
      @types.clear
      @checker = ConstraintChecker.new
    end
  end
end
`,
  "lib/t_ruby/declaration_generator.rb": `# frozen_string_literal: true

module TRuby
  # Generator for .d.trb type declaration files
  # Similar to TypeScript's .d.ts files
  class DeclarationGenerator
    DECLARATION_EXTENSION = ".d.trb"

    def initialize
      @parser = nil
    end

    # Generate declaration content from source code
    def generate(source)
      @parser = Parser.new(source)
      result = @parser.parse

      declarations = []

      # Add header comment
      declarations << "# Auto-generated type declaration file"
      declarations << "# Do not edit manually"
      declarations << ""

      # Generate type alias declarations
      (result[:type_aliases] || []).each do |type_alias|
        declarations << generate_type_alias(type_alias)
      end

      # Generate interface declarations
      (result[:interfaces] || []).each do |interface|
        declarations << generate_interface(interface)
      end

      # Generate function declarations
      (result[:functions] || []).each do |function|
        declarations << generate_function(function)
      end

      declarations.join("\\n")
    end

    # Generate declaration file from a .trb source file
    def generate_file(input_path, output_dir = nil)
      unless File.exist?(input_path)
        raise ArgumentError, "File not found: #{input_path}"
      end

      unless input_path.end_with?(".trb")
        raise ArgumentError, "Expected .trb file, got: #{input_path}"
      end

      source = File.read(input_path)
      content = generate(source)

      # Determine output path
      output_dir ||= File.dirname(input_path)
      FileUtils.mkdir_p(output_dir)

      base_name = File.basename(input_path, ".trb")
      output_path = File.join(output_dir, "#{base_name}#{DECLARATION_EXTENSION}")

      File.write(output_path, content)
      output_path
    end

    # Generate declaration file to a specific output path
    def generate_file_to_path(input_path, output_path)
      unless File.exist?(input_path)
        raise ArgumentError, "File not found: #{input_path}"
      end

      unless input_path.end_with?(".trb")
        raise ArgumentError, "Expected .trb file, got: #{input_path}"
      end

      source = File.read(input_path)
      content = generate(source)

      File.write(output_path, content)
      output_path
    end

    private

    def generate_type_alias(type_alias)
      "type #{type_alias[:name]} = #{type_alias[:definition]}"
    end

    def generate_interface(interface)
      lines = []
      lines << "interface #{interface[:name]}"

      interface[:members].each do |member|
        lines << "  #{member[:name]}: #{member[:type]}"
      end

      lines << "end"
      lines.join("\\n")
    end

    def generate_function(function)
      params = function[:params].map do |param|
        if param[:type]
          "#{param[:name]}: #{param[:type]}"
        else
          param[:name]
        end
      end.join(", ")

      return_type = function[:return_type] ? ": #{function[:return_type]}" : ""

      "def #{function[:name]}(#{params})#{return_type}"
    end
  end

  # Parser for .d.trb declaration files
  class DeclarationParser
    attr_reader :type_aliases, :interfaces, :functions

    def initialize
      @type_aliases = {}
      @interfaces = {}
      @functions = {}
    end

    # Parse a declaration file content (resets existing data)
    def parse(content)
      @type_aliases = {}
      @interfaces = {}
      @functions = {}

      parse_and_merge(content)
    end

    # Parse content and merge with existing data
    def parse_and_merge(content)
      parser = Parser.new(content)
      result = parser.parse

      # Process type aliases
      (result[:type_aliases] || []).each do |type_alias|
        @type_aliases[type_alias[:name]] = type_alias[:definition]
      end

      # Process interfaces
      (result[:interfaces] || []).each do |interface|
        @interfaces[interface[:name]] = interface
      end

      # Process functions
      (result[:functions] || []).each do |function|
        @functions[function[:name]] = function
      end

      self
    end

    # Parse a declaration file from path
    def parse_file(file_path)
      unless File.exist?(file_path)
        raise ArgumentError, "Declaration file not found: #{file_path}"
      end

      unless file_path.end_with?(DeclarationGenerator::DECLARATION_EXTENSION)
        raise ArgumentError, "Expected #{DeclarationGenerator::DECLARATION_EXTENSION} file, got: #{file_path}"
      end

      content = File.read(file_path)
      parse(content)
    end

    # Load multiple declaration files from a directory
    def load_directory(dir_path, recursive: false)
      unless Dir.exist?(dir_path)
        raise ArgumentError, "Directory not found: #{dir_path}"
      end

      pattern = recursive ? "**/*#{DeclarationGenerator::DECLARATION_EXTENSION}" : "*#{DeclarationGenerator::DECLARATION_EXTENSION}"
      files = Dir.glob(File.join(dir_path, pattern))

      files.each do |file|
        content = File.read(file)
        parse_and_merge(content)
      end

      self
    end

    # Check if a type is defined
    def type_defined?(name)
      @type_aliases.key?(name) || @interfaces.key?(name)
    end

    # Resolve a type alias
    def resolve_type(name)
      @type_aliases[name]
    end

    # Get an interface definition
    def get_interface(name)
      @interfaces[name]
    end

    # Get a function signature
    def get_function(name)
      @functions[name]
    end

    # Get all declarations as a hash
    def to_h
      {
        type_aliases: @type_aliases,
        interfaces: @interfaces,
        functions: @functions,
      }
    end

    # Merge another parser's declarations into this one
    def merge(other_parser)
      @type_aliases.merge!(other_parser.type_aliases)
      @interfaces.merge!(other_parser.interfaces)
      @functions.merge!(other_parser.functions)
      self
    end
  end

  # Loader for managing declaration files
  class DeclarationLoader
    attr_reader :search_paths

    def initialize
      @search_paths = []
      @loaded_declarations = DeclarationParser.new
      @loaded_files = Set.new
    end

    # Add a search path for declaration files
    def add_search_path(path)
      @search_paths << path unless @search_paths.include?(path)
      self
    end

    # Load a specific declaration file by name (without extension)
    def load(name)
      file_name = "#{name}#{DeclarationGenerator::DECLARATION_EXTENSION}"

      @search_paths.each do |path|
        full_path = File.join(path, file_name)
        next unless File.exist?(full_path) && !@loaded_files.include?(full_path)

        parser = DeclarationParser.new
        parser.parse_file(full_path)
        @loaded_declarations.merge(parser)
        @loaded_files.add(full_path)
        return true
      end

      false
    end

    # Load all declaration files from search paths
    def load_all
      @search_paths.each do |path|
        next unless Dir.exist?(path)

        Dir.glob(File.join(path, "*#{DeclarationGenerator::DECLARATION_EXTENSION}")).each do |file|
          next if @loaded_files.include?(file)

          parser = DeclarationParser.new
          parser.parse_file(file)
          @loaded_declarations.merge(parser)
          @loaded_files.add(file)
        end
      end

      self
    end

    # Get the combined declarations
    def declarations
      @loaded_declarations
    end

    # Check if a type is defined in any loaded declaration
    def type_defined?(name)
      @loaded_declarations.type_defined?(name)
    end

    # Resolve a type from loaded declarations
    def resolve_type(name)
      @loaded_declarations.resolve_type(name)
    end

    # Get all loaded type aliases
    def type_aliases
      @loaded_declarations.type_aliases
    end

    # Get all loaded interfaces
    def interfaces
      @loaded_declarations.interfaces
    end

    # Get all loaded functions
    def functions
      @loaded_declarations.functions
    end

    # Get list of loaded files
    def loaded_files
      @loaded_files.to_a
    end
  end
end
`,
  "lib/t_ruby/diagnostic.rb": `# frozen_string_literal: true

module TRuby
  class Diagnostic
    SEVERITY_ERROR = :error
    SEVERITY_WARNING = :warning
    SEVERITY_INFO = :info
    SEVERITY_HINT = :hint

    attr_reader :code, :message, :file, :line, :column, :end_column,
                :severity, :expected, :actual, :suggestion, :source_line

    # rubocop:disable Metrics/ParameterLists
    def initialize(
      code:,
      message:,
      file: nil,
      line: nil,
      column: nil,
      end_column: nil,
      severity: SEVERITY_ERROR,
      expected: nil,
      actual: nil,
      suggestion: nil,
      source_line: nil
    )
      # rubocop:enable Metrics/ParameterLists
      @code = code
      @message = message
      @file = file
      @line = line
      @column = column || 1
      @end_column = end_column || (@column + 1)
      @severity = severity
      @expected = expected
      @actual = actual
      @suggestion = suggestion
      @source_line = source_line
    end

    def self.from_type_check_error(error, file: nil, source: nil)
      line, col = parse_location(error.location)
      source_line = extract_source_line(source, line) if source && line

      new(
        code: "TR2001",
        message: error.error_message,
        file: file,
        line: line,
        column: col,
        severity: error.severity || SEVERITY_ERROR,
        expected: error.expected,
        actual: error.actual,
        suggestion: error.suggestion,
        source_line: source_line
      )
    end

    def self.from_parse_error(error, file: nil, source: nil)
      source_line = extract_source_line(source, error.line) if source && error.line

      new(
        code: "TR1001",
        message: error.message,
        file: file,
        line: error.line,
        column: error.column,
        source_line: source_line
      )
    end

    def self.from_scan_error(error, file: nil, source: nil)
      source_line = extract_source_line(source, error.line) if source && error.line
      # ScanError adds " at line X, column Y" to the message in its constructor
      message = error.message.sub(/ at line \\d+, column \\d+\\z/, "")

      new(
        code: "TR1001",
        message: message,
        file: file,
        line: error.line,
        column: error.column,
        source_line: source_line
      )
    end

    def error?
      @severity == SEVERITY_ERROR
    end

    def self.parse_location(location_str)
      return [nil, 1] unless location_str

      case location_str
      when /:(\\d+):(\\d+)$/
        [::Regexp.last_match(1).to_i, ::Regexp.last_match(2).to_i]
      when /:(\\d+)$/
        [::Regexp.last_match(1).to_i, 1]
      when /line (\\d+)/i
        [::Regexp.last_match(1).to_i, 1]
      else
        [nil, 1]
      end
    end

    def self.extract_source_line(source, line_num)
      return nil unless source && line_num

      lines = source.split("\\n")
      lines[line_num - 1] if line_num.positive? && line_num <= lines.length
    end

    private_class_method :parse_location, :extract_source_line
  end
end
`,
  "lib/t_ruby/diagnostic_formatter.rb": `# frozen_string_literal: true

module TRuby
  class DiagnosticFormatter
    COLORS = {
      reset: "\\e[0m",
      bold: "\\e[1m",
      dim: "\\e[2m",
      red: "\\e[31m",
      green: "\\e[32m",
      yellow: "\\e[33m",
      blue: "\\e[34m",
      cyan: "\\e[36m",
      gray: "\\e[90m",
      white: "\\e[37m",
    }.freeze

    def initialize(use_colors: nil)
      @use_colors = use_colors.nil? ? $stdout.tty? : use_colors
    end

    def format(diagnostic)
      lines = []

      lines << format_header(diagnostic)

      if diagnostic.source_line && diagnostic.line
        lines << ""
        lines << format_source_snippet(diagnostic)
        lines << format_marker(diagnostic)
        lines.concat(format_context(diagnostic))
      end

      lines.join("\\n")
    end

    def format_all(diagnostics)
      return "" if diagnostics.empty?

      output = diagnostics.map { |d| format(d) }.join("\\n\\n")
      "#{output}\\n\\n#{format_summary(diagnostics)}"
    end

    private

    def format_header(diagnostic)
      location = format_location(diagnostic)
      severity_text = colorize(severity_color(diagnostic.severity), diagnostic.severity.to_s)
      code_text = colorize(:gray, diagnostic.code)

      "#{location} - #{severity_text} #{code_text}: #{diagnostic.message}"
    end

    def format_location(diagnostic)
      file_part = colorize(:cyan, diagnostic.file || "<unknown>")

      if diagnostic.line
        line_part = colorize(:yellow, diagnostic.line.to_s)
        col_part = colorize(:yellow, diagnostic.column.to_s)
        "#{file_part}:#{line_part}:#{col_part}"
      else
        file_part
      end
    end

    def format_source_snippet(diagnostic)
      line_num = diagnostic.line.to_s.rjust(4)
      line_num_colored = colorize(:gray, line_num)

      "#{line_num_colored} | #{diagnostic.source_line}"
    end

    def format_marker(diagnostic)
      col = diagnostic.column || 1
      width = calculate_marker_width(diagnostic)

      indent = "#{" " * 4} | #{" " * (col - 1)}"
      marker = colorize(:red, "~" * width)

      "#{indent}#{marker}"
    end

    def calculate_marker_width(diagnostic)
      # If end_column is explicitly set (not just default column + 1), use it
      if diagnostic.end_column && diagnostic.end_column > diagnostic.column + 1
        diagnostic.end_column - diagnostic.column
      elsif diagnostic.source_line
        # Try to guess width from identifier at error position
        remaining = diagnostic.source_line[(diagnostic.column - 1)..]
        if remaining && remaining =~ /^(\\w+)/
          ::Regexp.last_match(1).length
        else
          1
        end
      else
        1
      end
    end

    def format_context(diagnostic)
      lines = []
      indent = "#{" " * 4} | "

      if diagnostic.expected
        label = colorize(:dim, "Expected:")
        value = colorize(:green, diagnostic.expected)
        lines << "#{indent}#{label} #{value}"
      end

      if diagnostic.actual
        label = colorize(:dim, "Actual:")
        value = colorize(:red, diagnostic.actual)
        lines << "#{indent}#{label} #{value}"
      end

      if diagnostic.suggestion
        label = colorize(:dim, "Suggestion:")
        lines << "#{indent}#{label} #{diagnostic.suggestion}"
      end

      lines
    end

    def format_summary(diagnostics)
      error_count = diagnostics.count { |d| d.severity == Diagnostic::SEVERITY_ERROR }
      warning_count = diagnostics.count { |d| d.severity == Diagnostic::SEVERITY_WARNING }

      parts = []

      if error_count.positive?
        error_word = error_count == 1 ? "error" : "errors"
        parts << colorize(:red, "#{error_count} #{error_word}")
      end

      if warning_count.positive?
        warning_word = warning_count == 1 ? "warning" : "warnings"
        parts << colorize(:yellow, "#{warning_count} #{warning_word}")
      end

      if parts.empty?
        colorize(:green, "No errors found.")
      else
        "Found #{parts.join(" and ")}."
      end
    end

    def severity_color(severity)
      case severity
      when :error then :red
      when :warning then :yellow
      else :white
      end
    end

    def colorize(color, text)
      return text.to_s unless @use_colors
      return text.to_s unless COLORS[color]

      "#{COLORS[color]}#{text}#{COLORS[:reset]}"
    end
  end
end
`,
  "lib/t_ruby/doc_generator.rb": `# frozen_string_literal: true

require "json"
require "fileutils"
require "time"

module TRuby
  # API Documentation Generator
  class DocGenerator
    attr_reader :docs, :config

    def initialize(config = nil)
      @config = config || Config.new
      @docs = {
        types: {},
        interfaces: {},
        functions: {},
        modules: {},
      }
      @parser = nil
    end

    # Generate documentation from source files
    def generate(paths, output_dir: "docs")
      puts "Generating T-Ruby API Documentation..."

      # Parse all files
      files = collect_files(paths)
      files.each { |file| parse_file(file) }

      # Generate output
      FileUtils.mkdir_p(output_dir)

      generate_index(output_dir)
      generate_type_docs(output_dir)
      generate_interface_docs(output_dir)
      generate_function_docs(output_dir)
      generate_module_docs(output_dir)
      generate_search_index(output_dir)

      puts "Documentation generated in #{output_dir}/"
      @docs
    end

    # Generate single-file markdown documentation
    def generate_markdown(paths, output_path: "API.md")
      files = collect_files(paths)
      files.each { |file| parse_file(file) }

      md = []
      md << "# T-Ruby API Documentation"
      md << ""
      md << "**Generated:** #{Time.now}"
      md << ""
      md << "## Table of Contents"
      md << ""
      md << "- [Types](#types)"
      md << "- [Interfaces](#interfaces)"
      md << "- [Functions](#functions)"
      md << ""

      # Types section
      md << "## Types"
      md << ""
      @docs[:types].each do |name, info|
        md << "### \`#{name}\`"
        md << ""
        md << "\`\`\`typescript"
        md << "type #{name} = #{info[:definition]}"
        md << "\`\`\`"
        md << ""
        md << info[:description] if info[:description]
        md << ""
        md << "**Source:** \`#{info[:source]}\`" if info[:source]
        md << ""
      end

      # Interfaces section
      md << "## Interfaces"
      md << ""
      @docs[:interfaces].each do |name, info|
        md << "### \`#{name}\`"
        md << ""
        md << info[:description] if info[:description]
        md << ""

        if info[:type_params]&.any?
          md << "**Type Parameters:** \`<#{info[:type_params].join(", ")}>\`"
          md << ""
        end

        if info[:members]&.any?
          md << "#### Members"
          md << ""
          md << "| Name | Type | Description |"
          md << "|------|------|-------------|"
          info[:members].each do |member|
            md << "| \`#{member[:name]}\` | \`#{member[:type]}\` | #{member[:description] || "-"} |"
          end
          md << ""
        end

        md << "**Source:** \`#{info[:source]}\`" if info[:source]
        md << ""
      end

      # Functions section
      md << "## Functions"
      md << ""
      @docs[:functions].each do |name, info|
        md << "### \`#{name}\`"
        md << ""
        md << info[:description] if info[:description]
        md << ""

        # Signature
        params = info[:params]&.map { |p| "#{p[:name]}: #{p[:type]}" }&.join(", ") || ""
        type_params = info[:type_params]&.any? ? "<#{info[:type_params].join(", ")}>" : ""
        md << "\`\`\`ruby"
        md << "def #{name}#{type_params}(#{params}): #{info[:return_type] || "void"}"
        md << "\`\`\`"
        md << ""

        if info[:params]&.any?
          md << "#### Parameters"
          md << ""
          md << "| Name | Type | Description |"
          md << "|------|------|-------------|"
          info[:params].each do |param|
            md << "| \`#{param[:name]}\` | \`#{param[:type]}\` | #{param[:description] || "-"} |"
          end
          md << ""
        end

        md << "**Returns:** \`#{info[:return_type]}\`" if info[:return_type]
        md << ""
        md << "**Source:** \`#{info[:source]}\`" if info[:source]
        md << ""
      end

      File.write(output_path, md.join("\\n"))
      puts "Documentation generated: #{output_path}"
    end

    # Generate JSON documentation
    def generate_json(paths, output_path: "api.json")
      files = collect_files(paths)
      files.each { |file| parse_file(file) }

      File.write(output_path, JSON.pretty_generate({
                                                     generated_at: Time.now.iso8601,
                                                     version: TRuby::VERSION,
                                                     types: @docs[:types],
                                                     interfaces: @docs[:interfaces],
                                                     functions: @docs[:functions],
                                                     modules: @docs[:modules],
                                                   }))

      puts "JSON documentation generated: #{output_path}"
    end

    private

    def parser
      @parser ||= Parser.new("")
    end

    def collect_files(paths)
      files = []
      paths.each do |path|
        if File.directory?(path)
          files.concat(Dir.glob(File.join(path, "**", "*.trb")))
          files.concat(Dir.glob(File.join(path, "**", "*.d.trb")))
        elsif File.file?(path)
          files << path
        end
      end
      files.uniq
    end

    def parse_file(file_path)
      content = File.read(file_path)
      relative_path = file_path.sub("#{Dir.pwd}/", "")

      # Extract documentation comments
      doc_comments = extract_doc_comments(content)

      # Parse type aliases
      content.scan(/^type\\s+(\\w+)(?:<([^>]+)>)?\\s*=\\s*(.+)$/) do |name, type_params, definition|
        @docs[:types][name] = {
          name: name,
          type_params: type_params&.split(/\\s*,\\s*/),
          definition: definition.strip,
          description: doc_comments["type:#{name}"],
          source: relative_path,
        }
      end

      # Parse interfaces
      parse_interfaces(content, relative_path, doc_comments)

      # Parse functions
      parse_functions(content, relative_path, doc_comments)
    end

    def extract_doc_comments(content)
      comments = {}
      current_comment = []
      current_target = nil

      content.each_line do |line|
        if line =~ /^\\s*#\\s*@doc\\s+(\\w+):(\\w+)/
          current_target = "#{Regexp.last_match(1)}:#{Regexp.last_match(2)}"
          current_comment = []
        elsif line =~ /^\\s*#\\s*(.+)/ && current_target
          current_comment << Regexp.last_match(1).strip
        elsif line !~ /^\\s*#/ && current_target
          comments[current_target] = current_comment.join(" ")
          current_target = nil
          current_comment = []
        end

        # Also check inline comments before definitions
        if line =~ /^\\s*#\\s*(.+)$/
          current_comment << Regexp.last_match(1).strip
        elsif line =~ /^(type|interface|def)\\s+(\\w+)/
          type = Regexp.last_match(1)
          name = Regexp.last_match(2)
          unless current_comment.empty?
            comments["#{type}:#{name}"] = current_comment.join(" ")
          end
          current_comment = []
        end
      end

      comments
    end

    def parse_interfaces(content, source, doc_comments)
      # Match interface blocks
      content.scan(/interface\\s+(\\w+)(?:<([^>]+)>)?\\s*\\n((?:(?!^end).)*?)^end/m) do |name, type_params, body|
        members = []

        body.scan(/^\\s*(\\w+[?!]?)\\s*:\\s*(.+)$/) do |member_name, member_type|
          members << {
            name: member_name,
            type: member_type.strip,
            description: doc_comments["member:#{name}.#{member_name}"],
          }
        end

        @docs[:interfaces][name] = {
          name: name,
          type_params: type_params&.split(/\\s*,\\s*/),
          members: members,
          description: doc_comments["interface:#{name}"],
          source: source,
        }
      end
    end

    def parse_functions(content, source, doc_comments)
      # Match function definitions
      content.scan(/def\\s+(\\w+[?!]?)(?:<([^>]+)>)?\\s*\\(([^)]*)\\)(?:\\s*:\\s*(.+?))?(?:\\n|$)/) do |name, type_params, params_str, return_type|
        params = []

        params_str.scan(/(\\w+)\\s*:\\s*([^,]+)/) do |param_name, param_type|
          params << {
            name: param_name,
            type: param_type.strip,
            description: doc_comments["param:#{name}.#{param_name}"],
          }
        end

        @docs[:functions][name] = {
          name: name,
          type_params: type_params&.split(/\\s*,\\s*/),
          params: params,
          return_type: return_type&.strip,
          description: doc_comments["def:#{name}"],
          source: source,
        }
      end
    end

    def generate_index(output_dir)
      html = <<~HTML
        <!DOCTYPE html>
        <html>
        <head>
          <title>T-Ruby API Documentation</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
            h1 { color: #cc342d; }
            .section { margin: 20px 0; }
            a { color: #0366d6; text-decoration: none; }
            a:hover { text-decoration: underline; }
            .item { padding: 5px 0; }
            code { background: #f6f8fa; padding: 2px 6px; border-radius: 3px; }
          </style>
        </head>
        <body>
          <h1>T-Ruby API Documentation</h1>
          <p>Generated: #{Time.now}</p>

          <div class="section">
            <h2>Types (#{@docs[:types].size})</h2>
            #{@docs[:types].keys.sort.map { |name| "<div class='item'><a href='types/#{name}.html'><code>#{name}</code></a></div>" }.join}
          </div>

          <div class="section">
            <h2>Interfaces (#{@docs[:interfaces].size})</h2>
            #{@docs[:interfaces].keys.sort.map { |name| "<div class='item'><a href='interfaces/#{name}.html'><code>#{name}</code></a></div>" }.join}
          </div>

          <div class="section">
            <h2>Functions (#{@docs[:functions].size})</h2>
            #{@docs[:functions].keys.sort.map { |name| "<div class='item'><a href='functions/#{name}.html'><code>#{name}</code></a></div>" }.join}
          </div>
        </body>
        </html>
      HTML

      File.write(File.join(output_dir, "index.html"), html)
    end

    def generate_type_docs(output_dir)
      types_dir = File.join(output_dir, "types")
      FileUtils.mkdir_p(types_dir)

      @docs[:types].each do |name, info|
        html = generate_type_html(name, info)
        File.write(File.join(types_dir, "#{name}.html"), html)
      end
    end

    def generate_interface_docs(output_dir)
      interfaces_dir = File.join(output_dir, "interfaces")
      FileUtils.mkdir_p(interfaces_dir)

      @docs[:interfaces].each do |name, info|
        html = generate_interface_html(name, info)
        File.write(File.join(interfaces_dir, "#{name}.html"), html)
      end
    end

    def generate_function_docs(output_dir)
      functions_dir = File.join(output_dir, "functions")
      FileUtils.mkdir_p(functions_dir)

      @docs[:functions].each do |name, info|
        html = generate_function_html(name, info)
        File.write(File.join(functions_dir, "#{name}.html"), html)
      end
    end

    def generate_module_docs(output_dir)
      # Placeholder for module documentation
    end

    def generate_search_index(output_dir)
      search_data = []

      @docs[:types].each_key do |name|
        search_data << { type: "type", name: name, url: "types/#{name}.html" }
      end

      @docs[:interfaces].each_key do |name|
        search_data << { type: "interface", name: name, url: "interfaces/#{name}.html" }
      end

      @docs[:functions].each_key do |name|
        search_data << { type: "function", name: name, url: "functions/#{name}.html" }
      end

      File.write(File.join(output_dir, "search-index.json"), JSON.generate(search_data))
    end

    def generate_type_html(name, info)
      <<~HTML
        <!DOCTYPE html>
        <html>
        <head>
          <title>#{name} - T-Ruby API</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
            h1 { color: #cc342d; }
            pre { background: #f6f8fa; padding: 16px; border-radius: 6px; overflow-x: auto; }
            .meta { color: #6a737d; font-size: 14px; }
            a { color: #0366d6; }
          </style>
        </head>
        <body>
          <a href="../index.html">← Back to Index</a>
          <h1>type #{name}</h1>
          #{"<p>#{info[:description]}</p>" if info[:description]}
          <pre>type #{name}#{"<#{info[:type_params].join(", ")}>" if info[:type_params]} = #{info[:definition]}</pre>
          <p class="meta">Source: <code>#{info[:source]}</code></p>
        </body>
        </html>
      HTML
    end

    def generate_interface_html(name, info)
      members_html = info[:members]&.map do |m|
        "<tr><td><code>#{m[:name]}</code></td><td><code>#{m[:type]}</code></td><td>#{m[:description] || "-"}</td></tr>"
      end&.join || ""

      <<~HTML
        <!DOCTYPE html>
        <html>
        <head>
          <title>#{name} - T-Ruby API</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
            h1 { color: #cc342d; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background: #f6f8fa; }
            pre { background: #f6f8fa; padding: 16px; border-radius: 6px; }
            .meta { color: #6a737d; font-size: 14px; }
            a { color: #0366d6; }
          </style>
        </head>
        <body>
          <a href="../index.html">← Back to Index</a>
          <h1>interface #{name}#{"&lt;#{info[:type_params].join(", ")}&gt;" if info[:type_params]}</h1>
          #{"<p>#{info[:description]}</p>" if info[:description]}
          #{"<h2>Members</h2><table><tr><th>Name</th><th>Type</th><th>Description</th></tr>#{members_html}</table>" unless members_html.empty?}
          <p class="meta">Source: <code>#{info[:source]}</code></p>
        </body>
        </html>
      HTML
    end

    def generate_function_html(name, info)
      params_html = info[:params]&.map do |p|
        "<tr><td><code>#{p[:name]}</code></td><td><code>#{p[:type]}</code></td><td>#{p[:description] || "-"}</td></tr>"
      end&.join || ""

      params_sig = info[:params]&.map { |p| "#{p[:name]}: #{p[:type]}" }&.join(", ") || ""
      type_params = info[:type_params]&.any? ? "<#{info[:type_params].join(", ")}>" : ""

      <<~HTML
        <!DOCTYPE html>
        <html>
        <head>
          <title>#{name} - T-Ruby API</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
            h1 { color: #cc342d; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background: #f6f8fa; }
            pre { background: #f6f8fa; padding: 16px; border-radius: 6px; }
            .meta { color: #6a737d; font-size: 14px; }
            a { color: #0366d6; }
          </style>
        </head>
        <body>
          <a href="../index.html">← Back to Index</a>
          <h1>#{name}</h1>
          #{"<p>#{info[:description]}</p>" if info[:description]}
          <h2>Signature</h2>
          <pre>def #{name}#{type_params}(#{params_sig}): #{info[:return_type] || "void"}</pre>
          #{"<h2>Parameters</h2><table><tr><th>Name</th><th>Type</th><th>Description</th></tr>#{params_html}</table>" unless params_html.empty?}
          <h2>Returns</h2>
          <p><code>#{info[:return_type] || "void"}</code></p>
          <p class="meta">Source: <code>#{info[:source]}</code></p>
        </body>
        </html>
      HTML
    end
  end
end
`,
  "lib/t_ruby/docs_badge_generator.rb": `# frozen_string_literal: true

require "time"
require_relative "docs_example_verifier"

module TRuby
  # Generates badges and reports for documentation verification results.
  #
  # Supports:
  # - Shields.io compatible JSON badges
  # - SVG badge generation
  # - Markdown report generation
  # - JSON report generation
  #
  # @example
  #   generator = DocsBadgeGenerator.new
  #   verifier = DocsExampleVerifier.new
  #   results = verifier.verify_glob("docs/**/*.md")
  #   generator.generate_badge(results, "coverage/docs_badge.json")
  #
  class DocsBadgeGenerator
    # Badge colors based on pass rate
    COLORS = {
      excellent: "brightgreen",   # 95-100%
      good: "green",              # 80-94%
      fair: "yellow",             # 60-79%
      poor: "orange",             # 40-59%
      critical: "red",            # 0-39%
    }.freeze

    def initialize
      @verifier = DocsExampleVerifier.new
    end

    # Generate all outputs
    #
    # @param results [Array<DocsExampleVerifier::VerificationResult>] Results
    # @param output_dir [String] Output directory
    def generate_all(results, output_dir)
      FileUtils.mkdir_p(output_dir)

      generate_badge_json(results, File.join(output_dir, "docs_badge.json"))
      generate_badge_svg(results, File.join(output_dir, "docs_badge.svg"))
      generate_report_json(results, File.join(output_dir, "docs_report.json"))
      generate_report_markdown(results, File.join(output_dir, "docs_report.md"))
    end

    # Generate Shields.io compatible JSON badge
    #
    # @param results [Array<DocsExampleVerifier::VerificationResult>] Results
    # @param output_path [String] Output file path
    def generate_badge_json(results, output_path)
      summary = @verifier.summary(results)
      pass_rate = summary[:pass_rate]

      badge = {
        schemaVersion: 1,
        label: "docs examples",
        message: "#{pass_rate}%",
        color: color_for_rate(pass_rate),
      }

      File.write(output_path, JSON.pretty_generate(badge))
    end

    # Generate SVG badge
    #
    # @param results [Array<DocsExampleVerifier::VerificationResult>] Results
    # @param output_path [String] Output file path
    def generate_badge_svg(results, output_path)
      summary = @verifier.summary(results)
      pass_rate = summary[:pass_rate]
      color = svg_color_for_rate(pass_rate)

      svg = <<~SVG
        <svg xmlns="http://www.w3.org/2000/svg" width="140" height="20">
          <linearGradient id="b" x2="0" y2="100%">
            <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
            <stop offset="1" stop-opacity=".1"/>
          </linearGradient>
          <mask id="a">
            <rect width="140" height="20" rx="3" fill="#fff"/>
          </mask>
          <g mask="url(#a)">
            <path fill="#555" d="M0 0h85v20H0z"/>
            <path fill="#{color}" d="M85 0h55v20H85z"/>
            <path fill="url(#b)" d="M0 0h140v20H0z"/>
          </g>
          <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
            <text x="42.5" y="15" fill="#010101" fill-opacity=".3">docs examples</text>
            <text x="42.5" y="14">docs examples</text>
            <text x="112" y="15" fill="#010101" fill-opacity=".3">#{pass_rate}%</text>
            <text x="112" y="14">#{pass_rate}%</text>
          </g>
        </svg>
      SVG

      File.write(output_path, svg)
    end

    # Generate JSON report
    #
    # @param results [Array<DocsExampleVerifier::VerificationResult>] Results
    # @param output_path [String] Output file path
    def generate_report_json(results, output_path)
      summary = @verifier.summary(results)

      report = {
        generated_at: Time.now.iso8601,
        summary: summary,
        files: group_results_by_file(results),
      }

      File.write(output_path, JSON.pretty_generate(report))
    end

    # Generate Markdown report
    #
    # @param results [Array<DocsExampleVerifier::VerificationResult>] Results
    # @param output_path [String] Output file path
    def generate_report_markdown(results, output_path)
      summary = @verifier.summary(results)
      grouped = group_results_by_file(results)

      markdown = <<~MD
        # Documentation Examples Verification Report

        Generated: #{Time.now.strftime("%Y-%m-%d %H:%M:%S")}

        ## Summary

        | Metric | Value |
        |--------|-------|
        | Total Examples | #{summary[:total]} |
        | Passed | #{summary[:passed]} |
        | Failed | #{summary[:failed]} |
        | Skipped | #{summary[:skipped]} |
        | **Pass Rate** | **#{summary[:pass_rate]}%** |

        ## Results by File

      MD

      grouped.each do |file_path, file_results|
        file_summary = @verifier.summary(file_results)
        status_emoji = file_summary[:failed].zero? ? "✅" : "❌"

        markdown += "### #{status_emoji} #{file_path}\\n\\n"
        markdown += "Pass rate: #{file_summary[:pass_rate]}% (#{file_summary[:passed]}/#{file_summary[:total]})\\n\\n"

        failed_results = file_results.select(&:fail?)
        next unless failed_results.any?

        markdown += "**Failed examples:**\\n\\n"
        failed_results.each do |result|
          markdown += "- Line #{result.line_number}:\\n"
          result.errors.each do |error|
            markdown += "  - #{error}\\n"
          end
        end
        markdown += "\\n"
      end

      File.write(output_path, markdown)
    end

    private

    def color_for_rate(rate)
      case rate
      when 95..100 then COLORS[:excellent]
      when 80...95 then COLORS[:good]
      when 60...80 then COLORS[:fair]
      when 40...60 then COLORS[:poor]
      else COLORS[:critical]
      end
    end

    def svg_color_for_rate(rate)
      case rate
      when 95..100 then "#4c1"      # bright green
      when 80...95 then "#97ca00"   # green
      when 60...80 then "#dfb317"   # yellow
      when 40...60 then "#fe7d37"   # orange
      else "#e05d44"                # red
      end
    end

    def group_results_by_file(results)
      results.group_by(&:file_path)
    end
  end
end
`,
  "lib/t_ruby/docs_example_extractor.rb": `# frozen_string_literal: true

module TRuby
  # Extracts code examples from Markdown documentation files.
  #
  # Supports extracting:
  # - T-Ruby code blocks (\`\`\`trb, \`\`\`t-ruby, \`\`\`ruby with type annotations)
  # - Ruby code blocks for comparison
  # - RBS type definitions
  #
  # @example
  #   extractor = DocsExampleExtractor.new
  #   examples = extractor.extract_from_file("docs/getting-started.md")
  #   examples.each { |ex| puts ex.code }
  #
  class DocsExampleExtractor
    # Represents an extracted code example
    CodeExample = Struct.new(
      :code,           # The code content
      :language,       # Language identifier (trb, ruby, rbs)
      :file_path,      # Source file path
      :line_number,    # Starting line number
      :metadata,       # Optional metadata from code fence
      keyword_init: true
    ) do
      def trb?
        %w[trb t-ruby].include?(language)
      end

      def ruby?
        language == "ruby"
      end

      def rbs?
        language == "rbs"
      end

      def should_verify?
        !metadata&.include?("skip-verify")
      end

      def should_compile?
        !metadata&.include?("no-compile")
      end

      def should_typecheck?
        !metadata&.include?("no-typecheck")
      end
    end

    # Code fence pattern: \`\`\`language title="file.ext" {metadata}
    # Supports Docusaurus format: \`\`\`ruby title="example.trb"
    CODE_FENCE_PATTERN = /^\`\`\`(\\w+)?(?:\\s+title="([^"]*)")?(?:\\s*\\{([^}]*)\\})?/

    # Extract all code examples from a file
    #
    # @param file_path [String] Path to the markdown file
    # @return [Array<CodeExample>] Extracted code examples
    def extract_from_file(file_path)
      content = File.read(file_path, encoding: "UTF-8")
      extract_from_content(content, file_path)
    end

    # Extract all code examples from content
    #
    # @param content [String] Markdown content
    # @param file_path [String] Source file path (for reference)
    # @return [Array<CodeExample>] Extracted code examples
    def extract_from_content(content, file_path = "<string>")
      examples = []
      lines = content.lines
      in_code_block = false
      current_block = nil
      block_start_line = 0

      lines.each_with_index do |line, index|
        line_number = index + 1

        if !in_code_block && (match = line.match(CODE_FENCE_PATTERN))
          in_code_block = true
          block_start_line = line_number
          lang = match[1] || "text"
          title = match[2]
          metadata = match[3]

          # If title ends with .trb, treat as T-Ruby regardless of language tag
          if title&.end_with?(".trb")
            lang = "trb"
          end

          current_block = {
            language: lang,
            metadata: metadata,
            title: title,
            lines: [],
          }
        elsif in_code_block && line.match(/^\`\`\`\\s*$/)
          in_code_block = false

          # Only include relevant languages
          if relevant_language?(current_block[:language])
            examples << CodeExample.new(
              code: current_block[:lines].join,
              language: normalize_language(current_block[:language]),
              file_path: file_path,
              line_number: block_start_line,
              metadata: current_block[:metadata]
            )
          end

          current_block = nil
        elsif in_code_block
          current_block[:lines] << line
        end
      end

      examples
    end

    # Extract from multiple files using glob pattern
    #
    # @param pattern [String] Glob pattern (e.g., "docs/**/*.md")
    # @return [Array<CodeExample>] All extracted examples
    def extract_from_glob(pattern)
      Dir.glob(pattern).flat_map { |file| extract_from_file(file) }
    end

    # Get statistics about extracted examples
    #
    # @param examples [Array<CodeExample>] Code examples
    # @return [Hash] Statistics
    def statistics(examples)
      {
        total: examples.size,
        trb: examples.count(&:trb?),
        ruby: examples.count(&:ruby?),
        rbs: examples.count(&:rbs?),
        verifiable: examples.count(&:should_verify?),
        files: examples.map(&:file_path).uniq.size,
      }
    end

    private

    def relevant_language?(lang)
      %w[trb t-ruby ruby rbs].include?(lang&.downcase)
    end

    def normalize_language(lang)
      case lang&.downcase
      when "t-ruby" then "trb"
      else lang&.downcase || "text"
      end
    end
  end
end
`,
  "lib/t_ruby/docs_example_verifier.rb": `# frozen_string_literal: true

require_relative "docs_example_extractor"

module TRuby
  # Verifies code examples extracted from documentation.
  #
  # Performs:
  # - Syntax validation (parsing)
  # - Type checking (for .trb examples)
  # - Compilation (generates Ruby output)
  #
  # @example
  #   verifier = DocsExampleVerifier.new
  #   results = verifier.verify_file("docs/getting-started.md")
  #   results.each { |r| puts "#{r.status}: #{r.file_path}:#{r.line_number}" }
  #
  class DocsExampleVerifier
    # Result of verifying a single example
    VerificationResult = Struct.new(
      :example,        # The original CodeExample
      :status,         # :pass, :fail, :skip
      :errors,         # Array of error messages
      :output,         # Compiled output (if applicable)
      keyword_init: true
    ) do
      def pass?
        status == :pass
      end

      def fail?
        status == :fail
      end

      def skip?
        status == :skip
      end

      def file_path
        example.file_path
      end

      def line_number
        example.line_number
      end
    end

    def initialize
      @extractor = DocsExampleExtractor.new
      @compiler = TRuby::Compiler.new
    end

    # Verify all examples in a file
    #
    # @param file_path [String] Path to the markdown file
    # @return [Array<VerificationResult>] Results for each example
    def verify_file(file_path)
      examples = @extractor.extract_from_file(file_path)
      examples.map { |example| verify_example(example) }
    end

    # Verify all examples from multiple files
    #
    # @param pattern [String] Glob pattern
    # @return [Array<VerificationResult>] All results
    def verify_glob(pattern)
      examples = @extractor.extract_from_glob(pattern)
      examples.map { |example| verify_example(example) }
    end

    # Verify a single code example
    #
    # @param example [DocsExampleExtractor::CodeExample] The example to verify
    # @return [VerificationResult] The verification result
    def verify_example(example)
      return skip_result(example, "Marked as skip-verify") unless example.should_verify?

      case example.language
      when "trb"
        verify_trb_example(example)
      when "ruby"
        verify_ruby_example(example)
      when "rbs"
        verify_rbs_example(example)
      else
        skip_result(example, "Unknown language: #{example.language}")
      end
    rescue StandardError => e
      fail_result(example, ["Exception: #{e.message}"])
    end

    # Generate a summary report
    #
    # @param results [Array<VerificationResult>] Verification results
    # @return [Hash] Summary statistics
    def summary(results)
      {
        total: results.size,
        passed: results.count(&:pass?),
        failed: results.count(&:fail?),
        skipped: results.count(&:skip?),
        pass_rate: results.empty? ? 0 : (results.count(&:pass?).to_f / results.size * 100).round(2),
      }
    end

    # Print results to stdout
    #
    # @param results [Array<VerificationResult>] Verification results
    # @param verbose [Boolean] Show passing tests too
    def print_results(results, verbose: false)
      results.each do |result|
        next if result.pass? && !verbose

        status_icon = case result.status
                      when :pass then "\\e[32m✓\\e[0m"
                      when :fail then "\\e[31m✗\\e[0m"
                      when :skip then "\\e[33m○\\e[0m"
                      end

        puts "#{status_icon} #{result.file_path}:#{result.line_number}"

        result.errors&.each do |error|
          puts "    #{error}"
        end
      end

      summary_data = summary(results)
      puts
      puts "Results: #{summary_data[:passed]} passed, #{summary_data[:failed]} failed, #{summary_data[:skipped]} skipped"
      puts "Pass rate: #{summary_data[:pass_rate]}%"
    end

    private

    def verify_trb_example(example)
      errors = []

      # Step 1: Parse
      ir_program = nil
      begin
        parser = TRuby::Parser.new(example.code)
        parser.parse
        ir_program = parser.ir_program
      rescue TRuby::ParseError => e
        return fail_result(example, ["Parse error: #{e.message}"])
      end

      # Step 2: Type check (if enabled)
      if example.should_typecheck? && ir_program
        begin
          type_checker = TRuby::TypeChecker.new(use_smt: false)
          result = type_checker.check_program(ir_program)
          if result[:errors]&.any?
            errors.concat(result[:errors].map { |e| "Type error: #{e}" })
          end
        rescue StandardError => e
          errors << "Type check error: #{e.message}"
        end
      end

      # Step 3: Compile (if enabled)
      output = nil
      if example.should_compile?
        begin
          output = @compiler.compile_string(example.code)
        rescue StandardError => e
          errors << "Compile error: #{e.message}"
        end
      end

      errors.empty? ? pass_result(example, output) : fail_result(example, errors)
    end

    def verify_ruby_example(example)
      # For Ruby examples, just validate syntax

      RubyVM::InstructionSequence.compile(example.code)
      pass_result(example)
    rescue SyntaxError => e
      fail_result(example, ["Ruby syntax error: #{e.message}"])
    end

    def verify_rbs_example(example)
      # For RBS, we just do basic validation
      # Full RBS validation would require rbs gem
      if example.code.include?("def ") || example.code.include?("type ") ||
         example.code.include?("interface ") || example.code.include?("class ")
        pass_result(example)
      else
        skip_result(example, "Cannot validate RBS without rbs gem")
      end
    end

    def pass_result(example, output = nil)
      VerificationResult.new(
        example: example,
        status: :pass,
        errors: [],
        output: output
      )
    end

    def fail_result(example, errors)
      VerificationResult.new(
        example: example,
        status: :fail,
        errors: errors,
        output: nil
      )
    end

    def skip_result(example, reason)
      VerificationResult.new(
        example: example,
        status: :skip,
        errors: [reason],
        output: nil
      )
    end
  end
end
`,
  "lib/t_ruby/error_handler.rb": `# frozen_string_literal: true

module TRuby
  class ErrorHandler
    VALID_TYPES = %w[String Integer Float Boolean Array Hash Symbol void nil].freeze
    # Unicode-aware identifier pattern for method/variable names (supports Korean, etc.)
    IDENTIFIER_PATTERN = /[\\w\\p{L}\\p{N}]+[!?]?/

    def initialize(source)
      @source = source
      @lines = source.split("\\n")
      @errors = []
      @functions = {}
      @type_parser = ParserCombinator::TypeParser.new
    end

    def check
      @errors = []
      @functions = {}
      @type_aliases = {}
      @interfaces = {}

      check_type_alias_errors
      check_interface_errors
      check_syntax_errors
      check_method_signature_errors
      check_type_validation
      check_duplicate_definitions

      @errors
    end

    private

    def check_interface_errors
      @lines.each_with_index do |line, idx|
        next unless line.match?(/^\\s*interface\\s+[\\w:]+/)

        match = line.match(/^\\s*interface\\s+([\\w:]+)/)
        next unless match

        interface_name = match[1]

        if @interfaces[interface_name]
          @errors << "Line #{idx + 1}: Interface '#{interface_name}' is already defined at line #{@interfaces[interface_name]}"
        else
          @interfaces[interface_name] = idx + 1
        end
      end
    end

    def check_type_alias_errors
      @lines.each_with_index do |line, idx|
        next unless line.match?(/^\\s*type\\s+\\w+/)

        match = line.match(/^\\s*type\\s+(\\w+)\\s*=\\s*(.+)$/)
        next unless match

        alias_name = match[1]

        if @type_aliases[alias_name]
          @errors << "Line #{idx + 1}: Type alias '#{alias_name}' is already defined at line #{@type_aliases[alias_name]}"
        else
          @type_aliases[alias_name] = idx + 1
        end
      end
    end

    def check_syntax_errors
      @lines.each_with_index do |line, idx|
        next unless line.match?(/^\\s*def\\s+/)

        # Check for unclosed parenthesis
        if line.match?(/def\\s+\\w+\\([^)]*$/) && @lines[(idx + 1)..].none? { |l| l.match?(/\\)/) }
          @errors << "Line #{idx + 1}: Potential unclosed parenthesis in function definition"
        end

        # Check for invalid parameter syntax (e.g., "def test(: String)")
        if line.match?(/def\\s+\\w+\\(\\s*:\\s*\\w+/)
          @errors << "Line #{idx + 1}: Invalid parameter syntax - parameter name missing"
        end
      end
    end

    # New comprehensive method signature validation
    def check_method_signature_errors
      @lines.each_with_index do |line, idx|
        next unless line.match?(/^\\s*def\\s+/)

        check_single_method_signature(line, idx)
      end
    end

    def check_single_method_signature(line, idx)
      # Pattern 1: Check for colon without type (e.g., "def test():")
      if line.match?(/def\\s+\\w+[^:]*\\)\\s*:\\s*$/)
        @errors << "Line #{idx + 1}: Expected type after colon, but found end of line"
        return
      end

      # Pattern 2: Check for text after closing paren without colon (e.g., "def test() something")
      # Use balanced paren matching to find the correct closing paren
      params_end = find_params_closing_paren(line)
      if params_end
        after_params = line[params_end..].strip
        # Check if there's trailing content that's not a return type annotation
        if (match = after_params.match(/^\\)\\s*([^:\\s].+?)\\s*$/))
          trailing = match[1].strip
          # Allow if it's just end-of-line content or a valid Ruby block start
          unless trailing.empty? || trailing.start_with?("#") || trailing == "end"
            @errors << "Line #{idx + 1}: Unexpected token '#{trailing}' after method parameters - did you forget ':'?"
          end
          return
        end
      end

      # Pattern 3: Check for parameter with colon but no type (e.g., "def test(x:)")
      # Skip this check for keyword args group { name:, age: } - they're valid
      params_str = extract_params_string(line)
      # Check each parameter for colon without type
      # Match: "x:" at end, "x:," in middle, or "x: )" with space before closing
      if params_str && !params_str.include?("{") &&
         (params_str.match?(/\\w+:\\s*$/) || params_str.match?(/\\w+:\\s*,/))
        @errors << "Line #{idx + 1}: Expected type after parameter colon"
        return
      end

      # Pattern 4: Extract and validate return type
      if params_end
        after_params = line[params_end..]
        if (match = after_params.match(/\\)\\s*:\\s*(.+?)\\s*$/))
          return_type_str = match[1].strip
          validate_type_expression(return_type_str, idx, "return type")
        end
      end

      # Pattern 5: Extract and validate parameter types
      if params_str
        validate_parameter_types_expression(params_str, idx)
      end
    end

    # Find the position of the closing paren for method parameters (balanced matching)
    def find_params_closing_paren(line)
      start_pos = line.index("(")
      return nil unless start_pos

      depth = 0
      line[start_pos..].each_char.with_index do |char, i|
        case char
        when "("
          depth += 1
        when ")"
          depth -= 1
          return start_pos + i if depth.zero?
        end
      end
      nil
    end

    # Extract the parameters string from a method definition line
    def extract_params_string(line)
      start_pos = line.index("(")
      return nil unless start_pos

      end_pos = find_params_closing_paren(line)
      return nil unless end_pos

      line[(start_pos + 1)...end_pos]
    end

    def validate_type_expression(type_str, line_idx, context = "type")
      return if type_str.nil? || type_str.empty?

      # Check for whitespace in simple type names (e.g., "Str ing")
      if type_str.match?(/^[A-Z][a-z]*\\s+[a-z]+/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - unexpected whitespace in type name"
        return
      end

      # Check for trailing operators (e.g., "String |" or "String &")
      if type_str.match?(/[|&]\\s*$/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - trailing operator"
        return
      end

      # Check for leading operators
      if type_str.match?(/^\\s*[|&]/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - leading operator"
        return
      end

      # Check for double operators (e.g., "String | | Integer")
      if type_str.match?(/[|&]\\s*[|&]/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - consecutive operators"
        return
      end

      # Check for unclosed brackets
      # Note: we need to exclude -> arrow operators when counting < and >
      angle_balance = count_angle_brackets(type_str)
      if angle_balance != 0
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - unbalanced angle brackets"
        return
      end

      if type_str.count("[") != type_str.count("]")
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - unbalanced square brackets"
        return
      end

      if type_str.count("(") != type_str.count(")")
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - unbalanced parentheses"
        return
      end

      # Check for empty generic arguments (e.g., "Array<>")
      if type_str.match?(/<\\s*>/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - empty generic arguments"
        return
      end

      # Check for generic without base type (e.g., "<String>")
      if type_str.match?(/^\\s*</)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - missing base type for generic"
        return
      end

      # Check for missing arrow target in function type
      if type_str.match?(/->\\s*$/)
        @errors << "Line #{line_idx + 1}: Invalid #{context} '#{type_str}' - missing return type after ->"
        return
      end

      # Check for extra tokens after valid type (e.g., "String something_else")
      # Use TypeParser to validate
      result = @type_parser.parse(type_str)
      return unless result[:success]

      remaining = result[:remaining]&.strip
      return if remaining.nil? || remaining.empty?

      # Allow RBS-style square bracket generics (e.g., Hash[Symbol, String])
      # Allow nullable suffix (e.g., String?)
      # Allow array suffix (e.g., [])
      return if remaining.start_with?("[") || remaining.start_with?("?") || remaining == "[]"

      @errors << "Line #{line_idx + 1}: Unexpected token after #{context} '#{type_str}'"
    end

    def validate_parameter_types_expression(params_str, line_idx)
      return if params_str.nil? || params_str.empty?

      # Split parameters handling nested generics
      params = split_parameters(params_str)

      params.each do |param|
        param = param.strip
        next if param.empty?

        # Skip keyword args group: { name: Type, age: Type }
        next if param.start_with?("{")

        # Skip block parameter: &block or &block: Type
        next if param.start_with?("&")

        # Skip rest parameter: *args or *args: Type
        next if param.start_with?("*")

        # Check for param: Type pattern (with optional default value)
        # Match: name: Type or name: Type = default
        next unless (match = param.match(/^(\\w+)\\s*:\\s*(.+)$/))

        param_name = match[1]
        type_and_default = match[2].strip

        if type_and_default.empty?
          @errors << "Line #{line_idx + 1}: Expected type after colon for parameter '#{param_name}'"
          next
        end

        # Extract just the type part (before any '=' for default value)
        type_str = extract_type_from_param(type_and_default)
        next if type_str.nil? || type_str.empty?

        validate_type_expression(type_str, line_idx, "parameter type for '#{param_name}'")
      end
    end

    # Extract type from "Type = default_value" or just "Type"
    def extract_type_from_param(type_and_default)
      # Find the position of '=' that's not inside parentheses/brackets
      depth = 0
      type_and_default.each_char.with_index do |char, i|
        case char
        when "(", "<", "["
          depth += 1
        when ")", ">", "]"
          depth -= 1
        when "="
          # Make sure it's not part of -> operator
          prev_char = i.positive? ? type_and_default[i - 1] : nil
          next if %w[- ! = < >].include?(prev_char)

          return type_and_default[0...i].strip if depth.zero?
        end
      end
      type_and_default
    end

    def split_parameters(params_str)
      result = []
      current = ""
      paren_depth = 0
      bracket_depth = 0
      angle_depth = 0
      brace_depth = 0

      i = 0
      while i < params_str.length
        char = params_str[i]
        next_char = params_str[i + 1]
        prev_char = i.positive? ? params_str[i - 1] : nil

        case char
        when "("
          paren_depth += 1
          current += char
        when ")"
          paren_depth -= 1
          current += char
        when "["
          bracket_depth += 1
          current += char
        when "]"
          bracket_depth -= 1
          current += char
        when "<"
          # Only count as generic if it's not part of operator like <=, <=>
          if next_char != "=" && next_char != ">"
            angle_depth += 1
          end
          current += char
        when ">"
          # Only count as closing generic if we're inside a generic (angle_depth > 0)
          # and it's not part of -> operator
          if angle_depth.positive? && prev_char != "-"
            angle_depth -= 1
          end
          current += char
        when "{"
          brace_depth += 1
          current += char
        when "}"
          brace_depth -= 1
          current += char
        when ","
          if paren_depth.zero? && bracket_depth.zero? && angle_depth.zero? && brace_depth.zero?
            result << current.strip
            current = ""
          else
            current += char
          end
        else
          current += char
        end
        i += 1
      end

      result << current.strip unless current.empty?
      result
    end

    def check_type_validation
      @lines.each_with_index do |line, idx|
        next unless line.match?(/^\\s*def\\s+/)

        # Extract types from function definition - now handle complex types
        match = line.match(/def\\s+\\w+\\s*\\((.*?)\\)\\s*(?::\\s*(.+?))?$/)
        next unless match

        params_str = match[1]
        return_type = match[2]&.strip

        # Check return type if it's a simple type name
        if return_type&.match?(/^\\w+$/) && !(VALID_TYPES.include?(return_type) || @type_aliases.key?(return_type) || @interfaces.key?(return_type))
          @errors << "Line #{idx + 1}: Unknown return type '#{return_type}'"
        end

        # Check parameter types
        check_parameter_types(params_str, idx)
      end
    end

    def check_parameter_types(params_str, line_idx)
      return if params_str.nil? || params_str.empty?

      params = split_parameters(params_str)
      params.each do |param|
        param = param.strip
        match = param.match(/^(\\w+)(?::\\s*(.+))?$/)
        next unless match

        param_type = match[2]&.strip
        next unless param_type

        # Only check simple type names against VALID_TYPES
        next unless param_type.match?(/^\\w+$/)
        next if VALID_TYPES.include?(param_type) || @type_aliases.key?(param_type) || @interfaces.key?(param_type)

        @errors << "Line #{line_idx + 1}: Unknown parameter type '#{param_type}'"
      end
    end

    def check_duplicate_definitions
      current_class = nil
      class_methods = {} # { class_name => { method_name => line_number } }

      @lines.each_with_index do |line, idx|
        # Track class context
        if line.match?(/^\\s*class\\s+(\\w+)/)
          current_class = line.match(/class\\s+(\\w+)/)[1]
          class_methods[current_class] ||= {}
        elsif line.match?(/^\\s*end\\s*$/) && current_class
          # Simple heuristic: top-level 'end' closes current class
          # This is imperfect but handles most cases
          current_class = nil if line.match?(/^end\\s*$/)
        end

        # Use unicode-aware pattern for function names (supports Korean, etc.)
        next unless line.match?(/^\\s*def\\s+#{IDENTIFIER_PATTERN}/)

        func_name = line.match(/def\\s+(#{IDENTIFIER_PATTERN})/)[1]

        if current_class
          # Method inside a class - check within class scope
          methods = class_methods[current_class]
          if methods[func_name]
            @errors << "Line #{idx + 1}: Function '#{func_name}' is already defined at line #{methods[func_name]}"
          else
            methods[func_name] = idx + 1
          end
        elsif @functions[func_name]
          # Top-level function - check global scope
          @errors << "Line #{idx + 1}: Function '#{func_name}' is already defined at line #{@functions[func_name]}"
        else
          @functions[func_name] = idx + 1
        end
      end
    end

    # Count angle brackets excluding those in -> arrow operators
    # Returns the balance (positive if more <, negative if more >)
    def count_angle_brackets(type_str)
      balance = 0
      i = 0
      while i < type_str.length
        char = type_str[i]
        prev_char = i.positive? ? type_str[i - 1] : nil
        next_char = type_str[i + 1]

        case char
        when "<"
          # Skip if it's part of <= or <>
          balance += 1 unless %w[= >].include?(next_char)
        when ">"
          # Skip if it's part of -> arrow operator
          balance -= 1 unless prev_char == "-"
        end
        i += 1
      end
      balance
    end
  end
end
`,
  "lib/t_ruby/error_reporter.rb": `# frozen_string_literal: true

module TRuby
  class ErrorReporter
    attr_reader :diagnostics

    def initialize(formatter: nil)
      @diagnostics = []
      @formatter = formatter || DiagnosticFormatter.new
      @source_cache = {}
    end

    def add(diagnostic)
      @diagnostics << diagnostic
    end

    def add_type_check_error(error, file:, source: nil)
      source ||= load_source(file)
      add(Diagnostic.from_type_check_error(error, file: file, source: source))
    end

    def add_parse_error(error, file:, source: nil)
      source ||= load_source(file)
      add(Diagnostic.from_parse_error(error, file: file, source: source))
    end

    def add_scan_error(error, file:, source: nil)
      source ||= load_source(file)
      add(Diagnostic.from_scan_error(error, file: file, source: source))
    end

    def has_errors?
      @diagnostics.any? { |d| d.severity == Diagnostic::SEVERITY_ERROR }
    end

    def error_count
      @diagnostics.count { |d| d.severity == Diagnostic::SEVERITY_ERROR }
    end

    def report
      @formatter.format_all(@diagnostics)
    end

    def clear
      @diagnostics.clear
      @source_cache.clear
    end

    private

    def load_source(file)
      return nil unless file && File.exist?(file)

      @source_cache[file] ||= File.read(file)
    end
  end
end
`,
  "lib/t_ruby/generic_type_parser.rb": `# frozen_string_literal: true

module TRuby
  class GenericTypeParser
    def initialize(type_string)
      @type_string = type_string.strip
    end

    def parse
      if @type_string.include?("<") && @type_string.include?(">")
        parse_generic
      else
        { type: :simple, value: @type_string }
      end
    end

    private

    def parse_generic
      # Match: BaseName<Params>
      match = @type_string.match(/^(\\w+)<(.+)>$/)
      return { type: :simple, value: @type_string } unless match

      base_name = match[1]
      params_str = match[2]

      # Parse parameters, handling nested generics
      params = parse_params(params_str)

      {
        type: :generic,
        base: base_name,
        params: params,
      }
    end

    def parse_params(params_str)
      # Simple comma-based splitting (doesn't handle nested generics fully)
      # For nested generics like Array<Array<String>>, we need careful parsing
      params = []
      current = ""
      depth = 0

      params_str.each_char do |char|
        case char
        when "<"
          depth += 1
          current += char
        when ">"
          depth -= 1
          current += char
        when ","
          if depth.zero?
            params << current.strip
            current = ""
          else
            current += char
          end
        else
          current += char
        end
      end

      params << current.strip if current.length.positive?
      params
    end
  end
end
`,
  "lib/t_ruby/heredoc_detector.rb": `# frozen_string_literal: true

module TRuby
  # Detects regions that should be skipped during parsing:
  # - Heredoc content
  # - Block comments (=begin/=end)
  class HeredocDetector
    # Heredoc start patterns:
    # <<IDENTIFIER, <<-IDENTIFIER, <<~IDENTIFIER
    # <<'IDENTIFIER', <<"IDENTIFIER"
    HEREDOC_START_PATTERN = /<<([~-])?(['"]?)(\\w+)\\2/

    # Detect all skippable ranges in lines (heredocs and block comments)
    # @param lines [Array<String>] source lines
    # @return [Array<Range>] content ranges to skip (0-indexed)
    def self.detect(lines)
      ranges = []
      i = 0

      while i < lines.length
        line = lines[i]

        # Check for =begin block comment
        if line.strip == "=begin"
          start_line = i
          i += 1

          # Find =end
          while i < lines.length
            break if lines[i].strip == "=end"

            i += 1
          end

          # Range covers from =begin to =end (inclusive)
          ranges << (start_line..i) if i < lines.length
        # Check for heredoc
        elsif (match = line.match(HEREDOC_START_PATTERN))
          delimiter = match[3]
          squiggly = match[1] == "~"
          start_line = i
          i += 1

          # Find closing delimiter
          while i < lines.length
            # For squiggly heredoc or dash heredoc, delimiter can be indented
            # For regular heredoc, delimiter must be at line start
            if squiggly || match[1] == "-"
              break if lines[i].strip == delimiter
            elsif lines[i].chomp == delimiter
              break
            end
            i += 1
          end

          # Range covers content lines (after start, up to and including end delimiter)
          ranges << ((start_line + 1)..i) if i < lines.length
        end

        i += 1
      end

      ranges
    end

    # Check if a line index is inside any skippable region
    # @param line_index [Integer] line index to check
    # @param heredoc_ranges [Array<Range>] ranges from detect()
    # @return [Boolean]
    def self.inside_heredoc?(line_index, heredoc_ranges)
      heredoc_ranges.any? { |range| range.include?(line_index) }
    end
  end
end
`,
  "lib/t_ruby/intersection_type_parser.rb": `# frozen_string_literal: true

module TRuby
  class IntersectionTypeParser
    def initialize(type_string)
      @type_string = type_string.strip
    end

    def parse
      if @type_string.include?("&")
        parse_intersection
      else
        { type: :simple, value: @type_string }
      end
    end

    private

    def parse_intersection
      members = @type_string.split("&").map(&:strip).compact

      {
        type: :intersection,
        members: members,
        has_duplicates: members.length != members.uniq.length,
        unique_members: members.uniq,
      }
    end
  end
end
`,
  "lib/t_ruby/ir.rb": `# frozen_string_literal: true

module TRuby
  module IR
    # Base class for all IR nodes
    class Node
      attr_accessor :location, :type_info, :metadata

      def initialize(location: nil)
        @location = location
        @type_info = nil
        @metadata = {}
      end

      def accept(visitor)
        visitor.visit(self)
      end

      def children
        []
      end

      def transform(&block)
        block.call(self)
      end
    end

    # Program - root node containing all top-level declarations
    class Program < Node
      attr_accessor :declarations, :source_file

      def initialize(declarations: [], source_file: nil, **opts)
        super(**opts)
        @declarations = declarations
        @source_file = source_file
      end

      def children
        @declarations
      end
    end

    # Type alias declaration: type Name = Definition
    class TypeAlias < Node
      attr_accessor :name, :definition, :type_params

      def initialize(name:, definition:, type_params: [], **opts)
        super(**opts)
        @name = name
        @definition = definition
        @type_params = type_params
      end
    end

    # Interface declaration
    class Interface < Node
      attr_accessor :name, :members, :extends, :type_params

      def initialize(name:, members: [], extends: [], type_params: [], **opts)
        super(**opts)
        @name = name
        @members = members
        @extends = extends
        @type_params = type_params
      end

      def children
        @members
      end
    end

    # Interface member (method signature)
    class InterfaceMember < Node
      attr_accessor :name, :type_signature, :optional

      def initialize(name:, type_signature:, optional: false, **opts)
        super(**opts)
        @name = name
        @type_signature = type_signature
        @optional = optional
      end
    end

    # Class declaration
    class ClassDecl < Node
      attr_accessor :name, :superclass, :implements, :type_params, :body, :instance_vars

      def initialize(name:, superclass: nil, implements: [], type_params: [], body: [], instance_vars: [], **opts)
        super(**opts)
        @name = name
        @superclass = superclass
        @implements = implements
        @type_params = type_params
        @body = body
        @instance_vars = instance_vars
      end

      def children
        @body
      end
    end

    # Instance variable declaration
    class InstanceVariable < Node
      attr_accessor :name, :type_annotation

      def initialize(name:, type_annotation: nil, **opts)
        super(**opts)
        @name = name
        @type_annotation = type_annotation
      end
    end

    # Module declaration
    class ModuleDecl < Node
      attr_accessor :name, :body

      def initialize(name:, body: [], **opts)
        super(**opts)
        @name = name
        @body = body
      end

      def children
        @body
      end
    end

    # Method definition
    class MethodDef < Node
      attr_accessor :name, :params, :return_type, :body, :visibility, :type_params

      def initialize(name:, params: [], return_type: nil, body: nil, visibility: :public, type_params: [], **opts)
        super(**opts)
        @name = name
        @params = params
        @return_type = return_type
        @body = body
        @visibility = visibility
        @type_params = type_params
      end

      def children
        [@body].compact
      end
    end

    # Method parameter
    class Parameter < Node
      attr_accessor :name, :type_annotation, :default_value, :kind, :interface_ref

      # kind: :required, :optional, :rest, :keyrest, :block, :keyword
      # :keyword - 키워드 인자 (구조분해): { name: String } → def foo(name:)
      # :keyrest - 더블 스플랫: **opts: Type → def foo(**opts)
      # interface_ref - interface 참조 타입 (예: }: UserParams 부분)
      def initialize(name:, type_annotation: nil, default_value: nil, kind: :required, interface_ref: nil, **opts)
        super(**opts)
        @name = name
        @type_annotation = type_annotation
        @default_value = default_value
        @kind = kind
        @interface_ref = interface_ref
      end
    end

    # Block of statements
    class Block < Node
      attr_accessor :statements

      def initialize(statements: [], **opts)
        super(**opts)
        @statements = statements
      end

      def children
        @statements
      end
    end

    # Variable assignment
    class Assignment < Node
      attr_accessor :target, :value, :type_annotation

      def initialize(target:, value:, type_annotation: nil, **opts)
        super(**opts)
        @target = target
        @value = value
        @type_annotation = type_annotation
      end

      def children
        [@value]
      end
    end

    # Variable reference
    class VariableRef < Node
      attr_accessor :name, :scope

      # scope: :local, :instance, :class, :global
      def initialize(name:, scope: :local, **opts)
        super(**opts)
        @name = name
        @scope = scope
      end
    end

    # Method call
    class MethodCall < Node
      attr_accessor :receiver, :method_name, :arguments, :block, :type_args

      def initialize(method_name:, receiver: nil, arguments: [], block: nil, type_args: [], **opts)
        super(**opts)
        @receiver = receiver
        @method_name = method_name
        @arguments = arguments
        @block = block
        @type_args = type_args
      end

      def children
        ([@receiver, @block] + @arguments).compact
      end
    end

    # Literal values
    class Literal < Node
      attr_accessor :value, :literal_type

      def initialize(value:, literal_type:, **opts)
        super(**opts)
        @value = value
        @literal_type = literal_type
      end
    end

    # Interpolated string (string with #{...} expressions)
    class InterpolatedString < Node
      attr_accessor :parts

      def initialize(parts: [], **opts)
        super(**opts)
        @parts = parts
      end

      def children
        @parts
      end
    end

    # Array literal
    class ArrayLiteral < Node
      attr_accessor :elements, :element_type

      def initialize(elements: [], element_type: nil, **opts)
        super(**opts)
        @elements = elements
        @element_type = element_type
      end

      def children
        @elements
      end
    end

    # Hash literal
    class HashLiteral < Node
      attr_accessor :pairs, :key_type, :value_type

      def initialize(pairs: [], key_type: nil, value_type: nil, **opts)
        super(**opts)
        @pairs = pairs
        @key_type = key_type
        @value_type = value_type
      end
    end

    # Hash pair (key => value)
    class HashPair < Node
      attr_accessor :key, :value

      def initialize(key:, value:, **opts)
        super(**opts)
        @key = key
        @value = value
      end

      def children
        [@key, @value]
      end
    end

    # Conditional (if/unless)
    class Conditional < Node
      attr_accessor :condition, :then_branch, :else_branch, :kind

      # kind: :if, :unless, :ternary
      def initialize(condition:, then_branch:, else_branch: nil, kind: :if, **opts)
        super(**opts)
        @condition = condition
        @then_branch = then_branch
        @else_branch = else_branch
        @kind = kind
      end

      def children
        [@condition, @then_branch, @else_branch].compact
      end
    end

    # Case/when expression
    class CaseExpr < Node
      attr_accessor :subject, :when_clauses, :else_clause

      def initialize(subject: nil, when_clauses: [], else_clause: nil, **opts)
        super(**opts)
        @subject = subject
        @when_clauses = when_clauses
        @else_clause = else_clause
      end

      def children
        ([@subject, @else_clause] + @when_clauses).compact
      end
    end

    # When clause
    class WhenClause < Node
      attr_accessor :patterns, :body

      def initialize(patterns:, body:, **opts)
        super(**opts)
        @patterns = patterns
        @body = body
      end

      def children
        [@body] + @patterns
      end
    end

    # Loop constructs
    class Loop < Node
      attr_accessor :kind, :condition, :body

      # kind: :while, :until, :loop
      def initialize(kind:, body:, condition: nil, **opts)
        super(**opts)
        @kind = kind
        @condition = condition
        @body = body
      end

      def children
        [@condition, @body].compact
      end
    end

    # For loop / each iteration
    class ForLoop < Node
      attr_accessor :variable, :iterable, :body

      def initialize(variable:, iterable:, body:, **opts)
        super(**opts)
        @variable = variable
        @iterable = iterable
        @body = body
      end

      def children
        [@iterable, @body]
      end
    end

    # Return statement
    class Return < Node
      attr_accessor :value

      def initialize(value: nil, **opts)
        super(**opts)
        @value = value
      end

      def children
        [@value].compact
      end
    end

    # Binary operation
    class BinaryOp < Node
      attr_accessor :operator, :left, :right

      def initialize(operator:, left:, right:, **opts)
        super(**opts)
        @operator = operator
        @left = left
        @right = right
      end

      def children
        [@left, @right]
      end
    end

    # Unary operation
    class UnaryOp < Node
      attr_accessor :operator, :operand

      def initialize(operator:, operand:, **opts)
        super(**opts)
        @operator = operator
        @operand = operand
      end

      def children
        [@operand]
      end
    end

    # Type cast / assertion
    class TypeCast < Node
      attr_accessor :expression, :target_type, :kind

      # kind: :as, :assert
      def initialize(expression:, target_type:, kind: :as, **opts)
        super(**opts)
        @expression = expression
        @target_type = target_type
        @kind = kind
      end

      def children
        [@expression]
      end
    end

    # Type guard (is_a?, respond_to?)
    class TypeGuard < Node
      attr_accessor :expression, :type_check, :narrowed_type

      def initialize(expression:, type_check:, narrowed_type: nil, **opts)
        super(**opts)
        @expression = expression
        @type_check = type_check
        @narrowed_type = narrowed_type
      end

      def children
        [@expression]
      end
    end

    # Lambda/Proc definition
    class Lambda < Node
      attr_accessor :params, :body, :return_type

      def initialize(body:, params: [], return_type: nil, **opts)
        super(**opts)
        @params = params
        @body = body
        @return_type = return_type
      end

      def children
        [@body]
      end
    end

    # Begin/rescue/ensure block
    class BeginBlock < Node
      attr_accessor :body, :rescue_clauses, :else_clause, :ensure_clause

      def initialize(body:, rescue_clauses: [], else_clause: nil, ensure_clause: nil, **opts)
        super(**opts)
        @body = body
        @rescue_clauses = rescue_clauses
        @else_clause = else_clause
        @ensure_clause = ensure_clause
      end

      def children
        [@body, @else_clause, @ensure_clause].compact + @rescue_clauses
      end
    end

    # Rescue clause
    class RescueClause < Node
      attr_accessor :exception_types, :variable, :body

      def initialize(body:, exception_types: [], variable: nil, **opts)
        super(**opts)
        @exception_types = exception_types
        @variable = variable
        @body = body
      end

      def children
        [@body]
      end
    end

    # Raw Ruby code (for passthrough)
    class RawCode < Node
      attr_accessor :code

      def initialize(code:, **opts)
        super(**opts)
        @code = code
      end
    end

    #==========================================================================
    # Type Representation Nodes
    #==========================================================================

    # Base type node
    class TypeNode < Node
      def to_rbs
        raise NotImplementedError
      end

      def to_trb
        raise NotImplementedError
      end
    end

    # Simple type (String, Integer, etc.)
    class SimpleType < TypeNode
      attr_accessor :name

      def initialize(name:, **opts)
        super(**opts)
        @name = name
      end

      def to_rbs
        @name
      end

      def to_trb
        @name
      end
    end

    # Generic type (Array<String>, Map<K, V>)
    class GenericType < TypeNode
      attr_accessor :base, :type_args

      def initialize(base:, type_args: [], **opts)
        super(**opts)
        @base = base
        @type_args = type_args
      end

      def to_rbs
        "#{@base}[#{@type_args.map(&:to_rbs).join(", ")}]"
      end

      def to_trb
        "#{@base}<#{@type_args.map(&:to_trb).join(", ")}>"
      end
    end

    # Union type (String | Integer | nil)
    class UnionType < TypeNode
      attr_accessor :types

      def initialize(types: [], **opts)
        super(**opts)
        @types = types
      end

      def to_rbs
        @types.map(&:to_rbs).join(" | ")
      end

      def to_trb
        @types.map(&:to_trb).join(" | ")
      end
    end

    # Intersection type (Readable & Writable)
    class IntersectionType < TypeNode
      attr_accessor :types

      def initialize(types: [], **opts)
        super(**opts)
        @types = types
      end

      def to_rbs
        @types.map(&:to_rbs).join(" & ")
      end

      def to_trb
        @types.map(&:to_trb).join(" & ")
      end
    end

    # Function/Proc type ((String, Integer) -> Boolean)
    class FunctionType < TypeNode
      attr_accessor :param_types, :return_type

      def initialize(return_type:, param_types: [], **opts)
        super(**opts)
        @param_types = param_types
        @return_type = return_type
      end

      def to_rbs
        params = @param_types.map(&:to_rbs).join(", ")
        "^(#{params}) -> #{@return_type.to_rbs}"
      end

      def to_trb
        params = @param_types.map(&:to_trb).join(", ")
        "(#{params}) -> #{@return_type.to_trb}"
      end
    end

    # Tuple type ([String, Integer, Boolean])
    class TupleType < TypeNode
      attr_accessor :element_types

      def initialize(element_types: [], **opts)
        super(**opts)
        @element_types = element_types
      end

      def to_rbs
        "[#{@element_types.map(&:to_rbs).join(", ")}]"
      end

      def to_trb
        "[#{@element_types.map(&:to_trb).join(", ")}]"
      end
    end

    # Nullable type (String?)
    class NullableType < TypeNode
      attr_accessor :inner_type

      def initialize(inner_type:, **opts)
        super(**opts)
        @inner_type = inner_type
      end

      def to_rbs
        inner_rbs = @inner_type.to_rbs
        # Simple types can use ? suffix, complex types need (Type | nil) form
        if @inner_type.is_a?(SimpleType)
          "#{inner_rbs}?"
        else
          "(#{inner_rbs} | nil)"
        end
      end

      def to_trb
        "#{@inner_type.to_trb}?"
      end
    end

    # Literal type (literal value as type)
    class LiteralType < TypeNode
      attr_accessor :value

      def initialize(value:, **opts)
        super(**opts)
        @value = value
      end

      def to_rbs
        @value.inspect
      end

      def to_trb
        @value.inspect
      end
    end

    # Hash literal type: { key: Type, key2: Type }
    class HashLiteralType < TypeNode
      attr_accessor :fields # Array of { name: String, type: TypeNode }

      def initialize(fields:, **opts)
        super(**opts)
        @fields = fields
      end

      def to_rbs
        # Hash literal types in RBS are represented as Hash[Symbol, untyped] or specific record types
        "Hash[Symbol, untyped]"
      end

      def to_trb
        field_strs = @fields.map { |f| "#{f[:name]}: #{f[:type].to_trb}" }
        "{ #{field_strs.join(", ")} }"
      end
    end

    #==========================================================================
    # Visitor Pattern
    #==========================================================================

    class Visitor
      def visit(node)
        method_name = "visit_#{node.class.name.split("::").last.gsub(/([A-Z])/, '_\\1').downcase.sub(/^_/, "")}"
        if respond_to?(method_name)
          send(method_name, node)
        else
          visit_default(node)
        end
      end

      def visit_default(node)
        node.children.each { |child| visit(child) }
      end

      def visit_children(node)
        node.children.each { |child| visit(child) }
      end
    end

    #==========================================================================
    # IR Builder - Converts parsed AST to IR
    #==========================================================================

    class Builder
      def initialize
        @type_registry = {}
      end

      # Build IR from parser output
      def build(parse_result, source: nil)
        # Build type aliases
        declarations = (parse_result[:type_aliases] || []).map do |alias_info|
          build_type_alias(alias_info)
        end

        # Build interfaces
        (parse_result[:interfaces] || []).each do |interface_info|
          declarations << build_interface(interface_info)
        end

        # Build classes
        (parse_result[:classes] || []).each do |class_info|
          declarations << build_class(class_info)
        end

        # Build functions/methods
        (parse_result[:functions] || []).each do |func_info|
          declarations << build_method(func_info)
        end

        Program.new(declarations: declarations, source_file: source)
      end

      # Build from source code
      def build_from_source(source)
        parser = Parser.new(source)
        result = parser.parse
        build(result, source: source)
      end

      private

      def build_type_alias(info)
        TypeAlias.new(
          name: info[:name],
          definition: parse_type(info[:definition])
        )
      end

      def build_interface(info)
        members = (info[:members] || []).map do |member|
          InterfaceMember.new(
            name: member[:name],
            type_signature: parse_type(member[:type])
          )
        end

        Interface.new(
          name: info[:name],
          members: members
        )
      end

      def build_class(info)
        # Build methods
        methods = (info[:methods] || []).map do |method_info|
          build_method(method_info)
        end

        # Build instance variables
        instance_vars = (info[:instance_vars] || []).map do |ivar|
          InstanceVariable.new(
            name: ivar[:name],
            type_annotation: ivar[:type] ? parse_type(ivar[:type]) : nil
          )
        end

        ClassDecl.new(
          name: info[:name],
          superclass: info[:superclass],
          body: methods,
          instance_vars: instance_vars
        )
      end

      def build_method(info)
        params = (info[:params] || []).map do |param|
          Parameter.new(
            name: param[:name],
            type_annotation: param[:type] ? parse_type(param[:type]) : nil
          )
        end

        # 본문 IR이 있으면 사용 (BodyParser에서 파싱됨)
        body = info[:body_ir]

        # Build location string from line/column info
        location = info[:line] && info[:column] ? "#{info[:line]}:#{info[:column]}" : nil

        MethodDef.new(
          name: info[:name],
          params: params,
          return_type: info[:return_type] ? parse_type(info[:return_type]) : nil,
          body: body,
          visibility: info[:visibility] || :public,
          location: location
        )
      end

      def parse_type(type_str)
        return nil unless type_str

        type_str = type_str.strip
        return nil if type_str.empty?

        # Use ParserCombinator::TypeParser for all type parsing
        # Supports: simple types, generics, array shorthand, union, intersection, function types
        @type_parser ||= TRuby::ParserCombinator::TypeParser.new
        result = @type_parser.parse(type_str)
        return result[:type] if result[:success]

        # Fallback for unparseable types - return as SimpleType
        SimpleType.new(name: type_str)
      end
    end

    #==========================================================================
    # Code Generator - Converts IR to Ruby code
    #==========================================================================

    class CodeGenerator < Visitor
      attr_reader :output

      def initialize
        @output = []
        @indent = 0
      end

      def generate(program)
        @output = []
        visit(program)
        @output.join("\\n")
      end

      def visit_program(node)
        node.declarations.each do |decl|
          visit(decl)
          @output << ""
        end
      end

      def visit_type_alias(node)
        # Type aliases are erased in Ruby output
        emit_comment("type #{node.name} = #{node.definition.to_trb}")
      end

      def visit_interface(node)
        # Interfaces are erased in Ruby output
        emit_comment("interface #{node.name}")
        node.members.each do |member|
          emit_comment("  #{member.name}: #{member.type_signature.to_trb}")
        end
        emit_comment("end")
      end

      def visit_method_def(node)
        params_str = node.params.map(&:name).join(", ")
        emit("def #{node.name}(#{params_str})")
        @indent += 1

        if node.body
          visit(node.body)
        end

        @indent -= 1
        emit("end")
      end

      def visit_block(node)
        node.statements.each { |stmt| visit(stmt) }
      end

      def visit_assignment(node)
        emit("#{node.target} = #{generate_expression(node.value)}")
      end

      def visit_return(node)
        if node.value
          emit("return #{generate_expression(node.value)}")
        else
          emit("return")
        end
      end

      def visit_conditional(node)
        keyword = node.kind == :unless ? "unless" : "if"
        emit("#{keyword} #{generate_expression(node.condition)}")
        @indent += 1
        visit(node.then_branch) if node.then_branch
        @indent -= 1

        if node.else_branch
          emit("else")
          @indent += 1
          visit(node.else_branch)
          @indent -= 1
        end

        emit("end")
      end

      def visit_raw_code(node)
        node.code.each_line do |line|
          emit(line.rstrip)
        end
      end

      private

      def emit(text)
        @output << (("  " * @indent) + text)
      end

      def emit_comment(text)
        emit("# #{text}")
      end

      def generate_expression(node)
        case node
        when Literal
          node.value.inspect
        when VariableRef
          node.name
        when MethodCall
          args = node.arguments.map { |a| generate_expression(a) }.join(", ")
          if node.receiver
            "#{generate_expression(node.receiver)}.#{node.method_name}(#{args})"
          else
            "#{node.method_name}(#{args})"
          end
        when BinaryOp
          "(#{generate_expression(node.left)} #{node.operator} #{generate_expression(node.right)})"
        when UnaryOp
          "#{node.operator}#{generate_expression(node.operand)}"
        else
          node.to_s
        end
      end
    end

    #==========================================================================
    # RBS Generator - Converts IR to RBS type definitions
    #==========================================================================

    class RBSGenerator < Visitor
      attr_reader :output

      def initialize(enable_inference: true)
        @output = []
        @indent = 0
        @enable_inference = enable_inference
        @inferrer = TRuby::ASTTypeInferrer.new if enable_inference
        @class_env = nil # 현재 클래스의 타입 환경
      end

      def generate(program)
        @output = []
        visit(program)
        @output.join("\\n")
      end

      def visit_program(node)
        node.declarations.each do |decl|
          visit(decl)
          @output << ""
        end
      end

      def visit_type_alias(node)
        emit("type #{node.name} = #{node.definition.to_rbs}")
      end

      def visit_interface(node)
        emit("interface _#{node.name}")
        @indent += 1

        node.members.each do |member|
          visit(member)
        end

        @indent -= 1
        emit("end")
      end

      def visit_interface_member(node)
        emit("def #{node.name}: #{node.type_signature.to_rbs}")
      end

      def visit_method_def(node)
        params = node.params.map do |param|
          type = param.type_annotation&.to_rbs || "untyped"
          "#{param.name}: #{type}"
        end.join(", ")

        # 반환 타입: 명시적 타입 > 추론된 타입 > untyped
        return_type = node.return_type&.to_rbs

        # initialize 메서드는 특별 처리: 명시적 타입이 없으면 void
        # Ruby에서 initialize는 생성자이며, 실제 인스턴스 생성은 Class.new가 담당
        if node.name == "initialize" && return_type.nil?
          return_type = "void"
        elsif return_type.nil? && @enable_inference && @inferrer && node.body
          # 명시적 반환 타입이 없으면 추론 시도
          inferred = @inferrer.infer_method_return_type(node, @class_env)
          return_type = inferred if inferred && inferred != "untyped"
        end

        return_type ||= "untyped"
        visibility_prefix = format_visibility(node.visibility)
        emit("#{visibility_prefix}def #{node.name}: (#{params}) -> #{return_type}")
      end

      def visit_class_decl(node)
        emit("class #{node.name}")
        @indent += 1

        # 클래스 타입 환경 생성
        @class_env = TRuby::TypeEnv.new if @enable_inference

        # 인스턴스 변수 타입 등록
        (node.instance_vars || []).each do |ivar|
          if @class_env && ivar.type_annotation
            @class_env.define_instance_var("@#{ivar.name}", ivar.type_annotation.to_rbs)
          end

          # Emit instance variables first
          visit_instance_variable(ivar)
        end

        # Add blank line between ivars and methods if both exist
        @output << "" if node.instance_vars&.any? && node.body&.any?

        # Emit methods
        node.body.each { |member| visit(member) }

        @class_env = nil
        @indent -= 1
        emit("end")
      end

      def visit_instance_variable(node)
        type = node.type_annotation&.to_rbs || "untyped"
        emit("@#{node.name}: #{type}")
      end

      private

      def emit(text)
        @output << (("  " * @indent) + text)
      end

      def format_visibility(visibility)
        # RBS only supports private visibility, not protected
        # See: https://github.com/ruby/rbs/issues/579
        case visibility
        when :private
          "private "
        else
          ""
        end
      end
    end

    #==========================================================================
    # Optimization Passes
    #==========================================================================

    module Passes
      # Base class for optimization passes
      class Pass
        attr_reader :name, :changes_made

        def initialize(name)
          @name = name
          @changes_made = 0
        end

        def run(program)
          @changes_made = 0
          transform(program)
          { program: program, changes: @changes_made }
        end

        def transform(node)
          raise NotImplementedError
        end
      end

      # Dead code elimination
      class DeadCodeElimination < Pass
        def initialize
          super("dead_code_elimination")
        end

        def transform(node)
          case node
          when Program
            node.declarations = node.declarations.map { |d| transform(d) }.compact
          when Block
            node.statements = eliminate_dead_statements(node.statements)
            node.statements.each { |stmt| transform(stmt) }
          when MethodDef
            transform(node.body) if node.body
          end

          node
        end

        private

        def eliminate_dead_statements(statements)
          result = []
          found_return = false

          statements.each do |stmt|
            if found_return
              @changes_made += 1
              next
            end

            result << stmt
            found_return = true if stmt.is_a?(Return)
          end

          result
        end
      end

      # Constant folding
      class ConstantFolding < Pass
        def initialize
          super("constant_folding")
        end

        def transform(node)
          case node
          when Program
            node.declarations.each { |d| transform(d) }
          when MethodDef
            transform(node.body) if node.body
          when Block
            node.statements = node.statements.map { |s| fold_constants(s) }
          when BinaryOp
            fold_binary_op(node)
          end

          node
        end

        private

        def fold_constants(node)
          case node
          when BinaryOp
            fold_binary_op(node)
          when Assignment
            node.value = fold_constants(node.value)
            node
          when Return
            node.value = fold_constants(node.value) if node.value
            node
          else
            node
          end
        end

        def fold_binary_op(node)
          return node unless node.is_a?(BinaryOp)

          left = fold_constants(node.left)
          right = fold_constants(node.right)

          if left.is_a?(Literal) && right.is_a?(Literal)
            result = evaluate_op(node.operator, left.value, right.value)
            if result
              @changes_made += 1
              return Literal.new(value: result, literal_type: result.class.to_s.downcase.to_sym)
            end
          end

          node.left = left
          node.right = right
          node
        end

        def evaluate_op(op, left, right)
          return nil unless left.is_a?(Numeric) && right.is_a?(Numeric)

          case op
          when "+" then left + right
          when "-" then left - right
          when "*" then left * right
          when "/" then right.zero? ? nil : left / right
          when "%" then right.zero? ? nil : left % right
          when "**" then left**right
          end
        rescue StandardError
          nil
        end
      end

      # Type annotation cleanup
      class TypeAnnotationCleanup < Pass
        def initialize
          super("type_annotation_cleanup")
        end

        def transform(node)
          case node
          when Program
            node.declarations.each { |d| transform(d) }
          when MethodDef
            # Remove redundant type annotations
            node.params.each do |param|
              if param.type_annotation && redundant_annotation?(param)
                param.type_annotation = nil
                @changes_made += 1
              end
            end
          end

          node
        end

        private

        def redundant_annotation?(_param)
          # Consider annotation redundant if it matches the default/inferred type
          false
        end
      end

      # Unused declaration removal
      class UnusedDeclarationRemoval < Pass
        def initialize
          super("unused_declaration_removal")
        end

        def transform(node)
          return node unless node.is_a?(Program)

          used_types = collect_used_types(node)

          node.declarations = node.declarations.select do |decl|
            case decl
            when TypeAlias
              if used_types.include?(decl.name)
                true
              else
                @changes_made += 1
                false
              end
            else
              true
            end
          end

          node
        end

        private

        def collect_used_types(program)
          used = Set.new

          program.declarations.each do |decl|
            case decl
            when MethodDef
              collect_types_from_method(decl, used)
            when Interface
              decl.members.each do |member|
                collect_types_from_type(member.type_signature, used)
              end
            end
          end

          used
        end

        def collect_types_from_method(method, used)
          method.params.each do |param|
            collect_types_from_type(param.type_annotation, used) if param.type_annotation
          end
          collect_types_from_type(method.return_type, used) if method.return_type
        end

        def collect_types_from_type(type_node, used)
          case type_node
          when SimpleType
            used.add(type_node.name)
          when GenericType
            used.add(type_node.base)
            type_node.type_args.each { |arg| collect_types_from_type(arg, used) }
          when UnionType, IntersectionType
            type_node.types.each { |t| collect_types_from_type(t, used) }
          when NullableType
            collect_types_from_type(type_node.inner_type, used)
          when FunctionType
            type_node.param_types.each { |t| collect_types_from_type(t, used) }
            collect_types_from_type(type_node.return_type, used)
          end
        end
      end
    end

    #==========================================================================
    # Optimizer - Runs optimization passes
    #==========================================================================

    class Optimizer
      DEFAULT_PASSES = [
        Passes::DeadCodeElimination,
        Passes::ConstantFolding,
        Passes::TypeAnnotationCleanup,
        Passes::UnusedDeclarationRemoval,
      ].freeze

      attr_reader :passes, :stats

      def initialize(passes: DEFAULT_PASSES)
        @passes = passes.map(&:new)
        @stats = {}
      end

      def optimize(program, max_iterations: 10)
        @stats = { iterations: 0, total_changes: 0, pass_stats: {} }

        max_iterations.times do |i|
          @stats[:iterations] = i + 1
          changes_this_iteration = 0

          @passes.each do |pass|
            result = pass.run(program)
            program = result[:program]
            changes_this_iteration += result[:changes]

            @stats[:pass_stats][pass.name] ||= 0
            @stats[:pass_stats][pass.name] += result[:changes]
          end

          @stats[:total_changes] += changes_this_iteration
          break if changes_this_iteration.zero?
        end

        { program: program, stats: @stats }
      end
    end
  end
end
`,
  "lib/t_ruby/lsp_server.rb": `# frozen_string_literal: true

require "json"

module TRuby
  # LSP (Language Server Protocol) Server for T-Ruby
  # Provides IDE integration with autocomplete, diagnostics, and navigation
  class LSPServer
    VERSION = "0.1.0"

    # LSP Error codes
    module ErrorCodes
      PARSE_ERROR = -32_700
      INVALID_REQUEST = -32_600
      METHOD_NOT_FOUND = -32_601
      INVALID_PARAMS = -32_602
      INTERNAL_ERROR = -32_603
      SERVER_NOT_INITIALIZED = -32_002
      UNKNOWN_ERROR_CODE = -32_001
    end

    # LSP Completion item kinds
    module CompletionItemKind
      TEXT = 1
      METHOD = 2
      FUNCTION = 3
      CONSTRUCTOR = 4
      FIELD = 5
      VARIABLE = 6
      CLASS = 7
      INTERFACE = 8
      MODULE = 9
      PROPERTY = 10
      UNIT = 11
      VALUE = 12
      ENUM = 13
      KEYWORD = 14
      SNIPPET = 15
      COLOR = 16
      FILE = 17
      REFERENCE = 18
      FOLDER = 19
      ENUM_MEMBER = 20
      CONSTANT = 21
      STRUCT = 22
      EVENT = 23
      OPERATOR = 24
      TYPE_PARAMETER = 25
    end

    # LSP Diagnostic severity
    module DiagnosticSeverity
      ERROR = 1
      WARNING = 2
      INFORMATION = 3
      HINT = 4
    end

    # Semantic Token Types (LSP 3.16+)
    module SemanticTokenTypes
      NAMESPACE = 0
      TYPE = 1
      CLASS = 2
      ENUM = 3
      INTERFACE = 4
      STRUCT = 5
      TYPE_PARAMETER = 6
      PARAMETER = 7
      VARIABLE = 8
      PROPERTY = 9
      ENUM_MEMBER = 10
      EVENT = 11
      FUNCTION = 12
      METHOD = 13
      MACRO = 14
      KEYWORD = 15
      MODIFIER = 16
      COMMENT = 17
      STRING = 18
      NUMBER = 19
      REGEXP = 20
      OPERATOR = 21
    end

    # Semantic Token Modifiers (bit flags)
    module SemanticTokenModifiers
      DECLARATION = 0x01
      DEFINITION = 0x02
      READONLY = 0x04
      STATIC = 0x08
      DEPRECATED = 0x10
      ABSTRACT = 0x20
      ASYNC = 0x40
      MODIFICATION = 0x80
      DOCUMENTATION = 0x100
      DEFAULT_LIBRARY = 0x200
    end

    # Token type names for capability registration
    SEMANTIC_TOKEN_TYPES = %w[
      namespace type class enum interface struct typeParameter
      parameter variable property enumMember event function method
      macro keyword modifier comment string number regexp operator
    ].freeze

    # Token modifier names
    SEMANTIC_TOKEN_MODIFIERS = %w[
      declaration definition readonly static deprecated
      abstract async modification documentation defaultLibrary
    ].freeze

    # Built-in types for completion
    BUILT_IN_TYPES = %w[String Integer Boolean Array Hash Symbol void nil].freeze

    # Type keywords for completion
    TYPE_KEYWORDS = %w[type interface def end].freeze

    def initialize(input: $stdin, output: $stdout)
      @input = input
      @output = output
      @documents = {}
      @initialized = false
      @shutdown_requested = false
      @type_alias_registry = TypeAliasRegistry.new
      # Use Compiler for unified diagnostics (same as CLI)
      @compiler = Compiler.new
    end

    # Main run loop for the LSP server
    def run
      loop do
        message = read_message
        break if message.nil?

        response = handle_message(message)
        send_response(response) if response
      end
    end

    # Read a single LSP message from input
    def read_message
      # Read headers
      headers = {}
      loop do
        line = @input.gets
        return nil if line.nil?

        line = line.strip
        break if line.empty?

        if line =~ /^([^:]+):\\s*(.+)$/
          headers[Regexp.last_match(1)] = Regexp.last_match(2)
        end
      end

      content_length = headers["Content-Length"]&.to_i
      return nil unless content_length&.positive?

      # Read content
      content = @input.read(content_length)
      return nil if content.nil?

      JSON.parse(content)
    rescue JSON::ParserError => e
      { "error" => "Parse error: #{e.message}" }
    end

    # Send a response message
    def send_response(response)
      return if response.nil?

      content = JSON.generate(response)
      message = "Content-Length: #{content.bytesize}\\r\\n\\r\\n#{content}"
      @output.write(message)
      @output.flush
    end

    # Send a notification (no response expected)
    def send_notification(method, params)
      notification = {
        "jsonrpc" => "2.0",
        "method" => method,
        "params" => params,
      }
      send_response(notification)
    end

    # Handle an incoming message
    def handle_message(message)
      return error_response(nil, ErrorCodes::PARSE_ERROR, "Parse error") if message["error"]

      method = message["method"]
      params = message["params"] || {}
      id = message["id"]

      # Check if server is initialized for non-init methods
      if !@initialized && method != "initialize" && method != "exit"
        return error_response(id, ErrorCodes::SERVER_NOT_INITIALIZED, "Server not initialized")
      end

      result = dispatch_method(method, params, id)

      # For notifications (no id), don't send a response
      return nil if id.nil?

      if result.is_a?(Hash) && result[:error]
        error_response(id, result[:error][:code], result[:error][:message])
      else
        success_response(id, result)
      end
    end

    private

    def dispatch_method(method, params, _id)
      case method
      when "initialize"
        handle_initialize(params)
      when "initialized"
        handle_initialized(params)
      when "shutdown"
        handle_shutdown
      when "exit"
        handle_exit
      when "textDocument/didOpen"
        handle_did_open(params)
      when "textDocument/didChange"
        handle_did_change(params)
      when "textDocument/didClose"
        handle_did_close(params)
      when "textDocument/completion"
        handle_completion(params)
      when "textDocument/hover"
        handle_hover(params)
      when "textDocument/definition"
        handle_definition(params)
      when "textDocument/semanticTokens/full"
        handle_semantic_tokens_full(params)
      when "textDocument/diagnostic"
        handle_diagnostic(params)
      else
        { error: { code: ErrorCodes::METHOD_NOT_FOUND, message: "Method not found: #{method}" } }
      end
    end

    # === LSP Lifecycle Methods ===

    def handle_initialize(params)
      @initialized = true
      @root_uri = params["rootUri"]
      @workspace_folders = params["workspaceFolders"]

      {
        "capabilities" => {
          "textDocumentSync" => {
            "openClose" => true,
            "change" => 1, # Full sync
            "save" => { "includeText" => true },
          },
          "completionProvider" => {
            "triggerCharacters" => [":", "<", "|", "&"],
            "resolveProvider" => false,
          },
          "hoverProvider" => true,
          "definitionProvider" => true,
          "diagnosticProvider" => {
            "interFileDependencies" => false,
            "workspaceDiagnostics" => false,
          },
          "semanticTokensProvider" => {
            "legend" => {
              "tokenTypes" => SEMANTIC_TOKEN_TYPES,
              "tokenModifiers" => SEMANTIC_TOKEN_MODIFIERS,
            },
            "full" => true,
            "range" => false,
          },
        },
        "serverInfo" => {
          "name" => "t-ruby-lsp",
          "version" => VERSION,
        },
      }
    end

    def handle_initialized(_params)
      # Server is now fully initialized
      nil
    end

    def handle_shutdown
      @shutdown_requested = true
      nil
    end

    def handle_exit
      exit(@shutdown_requested ? 0 : 1)
    end

    # === Document Synchronization ===

    def handle_did_open(params)
      text_document = params["textDocument"]
      uri = text_document["uri"]
      text = text_document["text"]

      @documents[uri] = {
        text: text,
        version: text_document["version"],
      }

      # Parse and send diagnostics
      publish_diagnostics(uri, text)
      nil
    end

    def handle_did_change(params)
      text_document = params["textDocument"]
      uri = text_document["uri"]
      changes = params["contentChanges"]

      # For full sync, take the last change
      if changes && !changes.empty?
        @documents[uri] = {
          text: changes.last["text"],
          version: text_document["version"],
        }

        # Re-parse and send diagnostics
        publish_diagnostics(uri, changes.last["text"])
      end
      nil
    end

    def handle_did_close(params)
      uri = params["textDocument"]["uri"]
      @documents.delete(uri)

      # Clear diagnostics
      send_notification("textDocument/publishDiagnostics", {
                          "uri" => uri,
                          "diagnostics" => [],
                        })
      nil
    end

    # === Diagnostics ===

    # Handle pull-based diagnostics (LSP 3.17+)
    def handle_diagnostic(params)
      uri = params.dig("textDocument", "uri")
      return { "kind" => "full", "items" => [] } unless uri

      doc = @documents[uri]
      return { "kind" => "full", "items" => [] } unless doc

      text = doc[:text]
      return { "kind" => "full", "items" => [] } unless text

      diagnostics = analyze_document(text)
      { "kind" => "full", "items" => diagnostics }
    end

    def publish_diagnostics(uri, text)
      diagnostics = analyze_document(text)

      send_notification("textDocument/publishDiagnostics", {
                          "uri" => uri,
                          "diagnostics" => diagnostics,
                        })
    end

    def analyze_document(text, uri: nil)
      # Use unified Compiler.analyze for diagnostics
      # This ensures CLI and LSP show the same errors
      file_path = uri ? uri_to_path(uri) : "<source>"
      compiler_diagnostics = @compiler.analyze(text, file: file_path)

      # Convert TRuby::Diagnostic objects to LSP diagnostic format
      compiler_diagnostics.map { |d| diagnostic_to_lsp(d) }
    end

    # Convert TRuby::Diagnostic to LSP diagnostic format
    def diagnostic_to_lsp(diagnostic)
      # LSP uses 0-based line numbers
      line = (diagnostic.line || 1) - 1
      line = 0 if line.negative?

      col = (diagnostic.column || 1) - 1
      col = 0 if col.negative?

      end_col = diagnostic.end_column ? diagnostic.end_column - 1 : col + 1

      severity = case diagnostic.severity
                 when :error then DiagnosticSeverity::ERROR
                 when :warning then DiagnosticSeverity::WARNING
                 when :info then DiagnosticSeverity::INFORMATION
                 else DiagnosticSeverity::ERROR
                 end

      lsp_diag = {
        "range" => {
          "start" => { "line" => line, "character" => col },
          "end" => { "line" => line, "character" => end_col },
        },
        "severity" => severity,
        "source" => "t-ruby",
        "message" => diagnostic.message,
      }

      # Add error code if available
      lsp_diag["code"] = diagnostic.code if diagnostic.code

      lsp_diag
    end

    def uri_to_path(uri)
      # Convert file:// URI to filesystem path
      return uri unless uri.start_with?("file://")

      uri.sub(%r{^file://}, "")
    end

    def create_diagnostic(line, message, severity)
      {
        "range" => {
          "start" => { "line" => line, "character" => 0 },
          "end" => { "line" => line, "character" => 1000 },
        },
        "severity" => severity,
        "source" => "t-ruby",
        "message" => message,
      }
    end

    # === Completion ===

    def handle_completion(params)
      uri = params["textDocument"]["uri"]
      position = params["position"]

      document = @documents[uri]
      return { "items" => [] } unless document

      text = document[:text]
      lines = text.split("\\n")
      line = lines[position["line"]] || ""
      char_pos = position["character"]

      # Get the text before cursor
      prefix = line[0...char_pos] || ""

      completions = []

      # Context-aware completion
      case prefix
      when /:\\s*$/
        # After colon - suggest types
        completions.concat(type_completions)
      when /\\|\\s*$/
        # After pipe - suggest types for union
        completions.concat(type_completions)
      when /&\\s*$/
        # After ampersand - suggest types for intersection
        completions.concat(type_completions)
      when /<\\s*$/
        # Inside generic - suggest types
        completions.concat(type_completions)
      when /^\\s*$/
        # Start of line - suggest keywords
        completions.concat(keyword_completions)
      when /^\\s*def\\s+\\w*$/
        # Function definition - no completion needed
        completions = []
      when /^\\s*type\\s+\\w*$/
        # Type alias definition - no completion needed
        completions = []
      when /^\\s*interface\\s+\\w*$/
        # Interface definition - no completion needed
        completions = []
      else
        # Default - suggest all
        completions.concat(type_completions)
        completions.concat(keyword_completions)
      end

      # Add document-specific completions
      completions.concat(document_type_completions(text))

      { "items" => completions }
    end

    def type_completions
      BUILT_IN_TYPES.map do |type|
        {
          "label" => type,
          "kind" => CompletionItemKind::CLASS,
          "detail" => "Built-in type",
          "documentation" => "T-Ruby built-in type: #{type}",
        }
      end
    end

    def keyword_completions
      TYPE_KEYWORDS.map do |keyword|
        {
          "label" => keyword,
          "kind" => CompletionItemKind::KEYWORD,
          "detail" => "Keyword",
          "documentation" => keyword_documentation(keyword),
        }
      end
    end

    def keyword_documentation(keyword)
      case keyword
      when "type"
        "Define a type alias: type AliasName = TypeDefinition"
      when "interface"
        "Define an interface: interface Name ... end"
      when "def"
        "Define a function with type annotations: def name(param: Type): ReturnType"
      when "end"
        "End a block (interface, class, method, etc.)"
      else
        keyword
      end
    end

    def document_type_completions(text)
      parser = Parser.new(text)
      result = parser.parse

      # Add type aliases from the document
      completions = (result[:type_aliases] || []).map do |alias_info|
        {
          "label" => alias_info[:name],
          "kind" => CompletionItemKind::CLASS,
          "detail" => "Type alias",
          "documentation" => "type #{alias_info[:name]} = #{alias_info[:definition]}",
        }
      end

      # Add interfaces from the document
      (result[:interfaces] || []).each do |interface_info|
        completions << {
          "label" => interface_info[:name],
          "kind" => CompletionItemKind::INTERFACE,
          "detail" => "Interface",
          "documentation" => "interface #{interface_info[:name]}",
        }
      end

      completions
    end

    # === Hover ===

    def handle_hover(params)
      uri = params["textDocument"]["uri"]
      position = params["position"]

      document = @documents[uri]
      return nil unless document

      text = document[:text]
      lines = text.split("\\n")
      line = lines[position["line"]] || ""
      char_pos = position["character"]

      # Find the word at cursor position
      word = extract_word_at_position(line, char_pos)
      return nil if word.nil? || word.empty?

      hover_info = get_hover_info(word, text)
      return nil unless hover_info

      {
        "contents" => {
          "kind" => "markdown",
          "value" => hover_info,
        },
        "range" => word_range(position["line"], line, char_pos, word),
      }
    end

    def extract_word_at_position(line, char_pos)
      return nil if char_pos > line.length

      # Find word boundaries
      start_pos = char_pos
      end_pos = char_pos

      # Move start back to word start
      start_pos -= 1 while start_pos.positive? && line[start_pos - 1] =~ /[\\w<>]/

      # Move end forward to word end
      end_pos += 1 while end_pos < line.length && line[end_pos] =~ /[\\w<>]/

      return nil if start_pos == end_pos

      line[start_pos...end_pos]
    end

    def word_range(line_num, line, char_pos, word)
      start_pos = line.index(word) || char_pos
      end_pos = start_pos + word.length

      {
        "start" => { "line" => line_num, "character" => start_pos },
        "end" => { "line" => line_num, "character" => end_pos },
      }
    end

    def get_hover_info(word, text)
      # Check if it's a built-in type
      if BUILT_IN_TYPES.include?(word)
        return "**#{word}** - Built-in T-Ruby type"
      end

      # Check if it's a type alias
      parser = Parser.new(text)
      result = parser.parse

      (result[:type_aliases] || []).each do |alias_info|
        if alias_info[:name] == word
          return "**Type Alias**\\n\\n\`\`\`ruby\\ntype #{alias_info[:name]} = #{alias_info[:definition]}\\n\`\`\`"
        end
      end

      # Check if it's an interface
      (result[:interfaces] || []).each do |interface_info|
        if interface_info[:name] == word
          members = interface_info[:members].map { |m| "  #{m[:name]}: #{m[:type]}" }.join("\\n")
          return "**Interface**\\n\\n\`\`\`ruby\\ninterface #{interface_info[:name]}\\n#{members}\\nend\\n\`\`\`"
        end
      end

      # Check if it's a function
      (result[:functions] || []).each do |func|
        next unless func[:name] == word

        params = func[:params].map { |p| "#{p[:name]}: #{p[:type] || "untyped"}" }.join(", ")
        return_type = func[:return_type] || "void"
        return "**Function**\\n\\n\`\`\`ruby\\ndef #{func[:name]}(#{params}): #{return_type}\\n\`\`\`"
      end

      nil
    end

    # === Definition ===

    def handle_definition(params)
      uri = params["textDocument"]["uri"]
      position = params["position"]

      document = @documents[uri]
      return nil unless document

      text = document[:text]
      lines = text.split("\\n")
      line = lines[position["line"]] || ""
      char_pos = position["character"]

      word = extract_word_at_position(line, char_pos)
      return nil if word.nil? || word.empty?

      # Find definition location
      location = find_definition(word, text, uri)
      return nil unless location

      location
    end

    def find_definition(word, text, uri)
      lines = text.split("\\n")

      # Search for type alias definition
      lines.each_with_index do |line, idx|
        if line.match?(/^\\s*type\\s+#{Regexp.escape(word)}\\s*=/)
          return {
            "uri" => uri,
            "range" => {
              "start" => { "line" => idx, "character" => 0 },
              "end" => { "line" => idx, "character" => line.length },
            },
          }
        end

        # Search for interface definition
        if line.match?(/^\\s*interface\\s+#{Regexp.escape(word)}\\s*$/)
          return {
            "uri" => uri,
            "range" => {
              "start" => { "line" => idx, "character" => 0 },
              "end" => { "line" => idx, "character" => line.length },
            },
          }
        end

        # Search for function definition
        if line.match?(/^\\s*def\\s+#{Regexp.escape(word)}\\s*\\(/)
          return {
            "uri" => uri,
            "range" => {
              "start" => { "line" => idx, "character" => 0 },
              "end" => { "line" => idx, "character" => line.length },
            },
          }
        end
      end

      nil
    end

    # === Semantic Tokens ===

    def handle_semantic_tokens_full(params)
      uri = params["textDocument"]["uri"]
      document = @documents[uri]
      return { "data" => [] } unless document

      text = document[:text]
      tokens = generate_semantic_tokens(text)

      { "data" => tokens }
    end

    def generate_semantic_tokens(text)
      lines = text.split("\\n")

      # Parse the document to get IR
      parser = Parser.new(text)
      parse_result = parser.parse
      parser.ir_program

      # Collect all tokens from parsing
      raw_tokens = []

      # Process type aliases
      (parse_result[:type_aliases] || []).each do |alias_info|
        lines.each_with_index do |line, line_idx|
          next unless (match = line.match(/^\\s*type\\s+(#{Regexp.escape(alias_info[:name])})\\s*=/))

          # 'type' keyword
          type_pos = line.index("type")
          raw_tokens << [line_idx, type_pos, 4, SemanticTokenTypes::KEYWORD, SemanticTokenModifiers::DECLARATION]

          # Type name
          name_pos = match.begin(1)
          raw_tokens << [line_idx, name_pos, alias_info[:name].length, SemanticTokenTypes::TYPE, SemanticTokenModifiers::DEFINITION]

          # Type definition (after =)
          add_type_tokens(raw_tokens, line, line_idx, alias_info[:definition])
        end
      end

      # Process interfaces
      (parse_result[:interfaces] || []).each do |interface_info|
        lines.each_with_index do |line, line_idx|
          if (match = line.match(/^\\s*interface\\s+(#{Regexp.escape(interface_info[:name])})/))
            # 'interface' keyword
            interface_pos = line.index("interface")
            raw_tokens << [line_idx, interface_pos, 9, SemanticTokenTypes::KEYWORD, SemanticTokenModifiers::DECLARATION]

            # Interface name
            name_pos = match.begin(1)
            raw_tokens << [line_idx, name_pos, interface_info[:name].length, SemanticTokenTypes::INTERFACE, SemanticTokenModifiers::DEFINITION]
          end

          # Interface members
          interface_info[:members]&.each do |member|
            next unless (match = line.match(/^\\s*(#{Regexp.escape(member[:name])})\\s*:\\s*/))

            prop_pos = match.begin(1)
            raw_tokens << [line_idx, prop_pos, member[:name].length, SemanticTokenTypes::PROPERTY, 0]

            # Member type
            add_type_tokens(raw_tokens, line, line_idx, member[:type])
          end
        end
      end

      # Process functions
      (parse_result[:functions] || []).each do |func|
        lines.each_with_index do |line, line_idx|
          next unless (match = line.match(/^\\s*def\\s+(#{Regexp.escape(func[:name])})\\s*\\(/))

          # 'def' keyword
          def_pos = line.index("def")
          raw_tokens << [line_idx, def_pos, 3, SemanticTokenTypes::KEYWORD, 0]

          # Function name
          name_pos = match.begin(1)
          raw_tokens << [line_idx, name_pos, func[:name].length, SemanticTokenTypes::FUNCTION, SemanticTokenModifiers::DEFINITION]

          # Parameters
          func[:params]&.each do |param|
            next unless (param_match = line.match(/\\b(#{Regexp.escape(param[:name])})\\s*(?::\\s*)?/))

            param_pos = param_match.begin(1)
            raw_tokens << [line_idx, param_pos, param[:name].length, SemanticTokenTypes::PARAMETER, 0]

            # Parameter type if present
            if param[:type]
              add_type_tokens(raw_tokens, line, line_idx, param[:type])
            end
          end

          # Return type
          if func[:return_type]
            add_type_tokens(raw_tokens, line, line_idx, func[:return_type])
          end
        end
      end

      # Process 'end' keywords
      lines.each_with_index do |line, line_idx|
        if (match = line.match(/^\\s*(end)\\s*$/))
          end_pos = match.begin(1)
          raw_tokens << [line_idx, end_pos, 3, SemanticTokenTypes::KEYWORD, 0]
        end
      end

      # Sort tokens by line, then by character position
      raw_tokens.sort_by! { |t| [t[0], t[1]] }

      # Convert to delta encoding
      encode_tokens(raw_tokens)
    end

    def add_type_tokens(raw_tokens, line, line_idx, type_str)
      return unless type_str

      # Find position of the type in the line
      pos = line.index(type_str)
      return unless pos

      # Handle built-in types
      if BUILT_IN_TYPES.include?(type_str)
        raw_tokens << [line_idx, pos, type_str.length, SemanticTokenTypes::TYPE, SemanticTokenModifiers::DEFAULT_LIBRARY]
        return
      end

      # Handle generic types like Array<String>
      if type_str.include?("<")
        if (match = type_str.match(/^(\\w+)<(.+)>$/))
          base = match[1]
          base_pos = line.index(base, pos)
          if base_pos
            modifier = BUILT_IN_TYPES.include?(base) ? SemanticTokenModifiers::DEFAULT_LIBRARY : 0
            raw_tokens << [line_idx, base_pos, base.length, SemanticTokenTypes::TYPE, modifier]
          end
          # Recursively process type arguments
          # (simplified - just mark them as types)
          args = match[2]
          args.split(/[,\\s]+/).each do |arg|
            arg = arg.strip.gsub(/[<>]/, "")
            next if arg.empty?

            arg_pos = line.index(arg, pos)
            if arg_pos
              modifier = BUILT_IN_TYPES.include?(arg) ? SemanticTokenModifiers::DEFAULT_LIBRARY : 0
              raw_tokens << [line_idx, arg_pos, arg.length, SemanticTokenTypes::TYPE, modifier]
            end
          end
        end
        return
      end

      # Handle union types
      if type_str.include?("|")
        type_str.split("|").map(&:strip).each do |t|
          t_pos = line.index(t, pos)
          if t_pos
            modifier = BUILT_IN_TYPES.include?(t) ? SemanticTokenModifiers::DEFAULT_LIBRARY : 0
            raw_tokens << [line_idx, t_pos, t.length, SemanticTokenTypes::TYPE, modifier]
          end
        end
        return
      end

      # Handle intersection types
      if type_str.include?("&")
        type_str.split("&").map(&:strip).each do |t|
          t_pos = line.index(t, pos)
          if t_pos
            modifier = BUILT_IN_TYPES.include?(t) ? SemanticTokenModifiers::DEFAULT_LIBRARY : 0
            raw_tokens << [line_idx, t_pos, t.length, SemanticTokenTypes::TYPE, modifier]
          end
        end
        return
      end

      # Simple type
      raw_tokens << [line_idx, pos, type_str.length, SemanticTokenTypes::TYPE, 0]
    end

    def encode_tokens(raw_tokens)
      encoded = []
      prev_line = 0
      prev_char = 0

      raw_tokens.each do |token|
        line, char, length, token_type, modifiers = token

        delta_line = line - prev_line
        delta_char = delta_line.zero? ? char - prev_char : char

        encoded << delta_line
        encoded << delta_char
        encoded << length
        encoded << token_type
        encoded << modifiers

        prev_line = line
        prev_char = char
      end

      encoded
    end

    # === Response Helpers ===

    def success_response(id, result)
      {
        "jsonrpc" => "2.0",
        "id" => id,
        "result" => result,
      }
    end

    def error_response(id, code, message)
      {
        "jsonrpc" => "2.0",
        "id" => id,
        "error" => {
          "code" => code,
          "message" => message,
        },
      }
    end
  end
end
`,
  "lib/t_ruby/package_manager.rb": `# frozen_string_literal: true

require "json"
require "fileutils"
require "net/http"
require "uri"
require "time"

module TRuby
  # Semantic version parsing and comparison
  class SemanticVersion
    include Comparable

    attr_reader :major, :minor, :patch, :prerelease

    VERSION_REGEX = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-(.+))?$/

    def initialize(version_string)
      match = VERSION_REGEX.match(version_string.to_s)
      raise ArgumentError, "Invalid version: #{version_string}" unless match

      @major = match[1].to_i
      @minor = match[2].to_i
      @patch = match[3].to_i
      @prerelease = match[4]
    end

    def <=>(other)
      return nil unless other.is_a?(SemanticVersion)

      result = [@major, @minor, @patch] <=> [other.major, other.minor, other.patch]
      return result unless result.zero?

      # Both have same version, compare prerelease
      return 0 if @prerelease.nil? && other.prerelease.nil?
      return 1 if @prerelease.nil? # Release > prerelease
      return -1 if other.prerelease.nil?

      @prerelease <=> other.prerelease
    end

    def satisfies?(constraint)
      VersionConstraint.new(constraint).satisfied_by?(self)
    end

    def to_s
      base = "#{@major}.#{@minor}.#{@patch}"
      @prerelease ? "#{base}-#{@prerelease}" : base
    end

    def self.parse(str)
      new(str)
    rescue ArgumentError
      nil
    end
  end

  # Version constraint (^1.0.0, ~>1.0, >=1.0.0 <2.0.0)
  class VersionConstraint
    attr_reader :constraints

    def initialize(constraint_string)
      @constraints = parse_constraints(constraint_string)
    end

    def satisfied_by?(version)
      version = SemanticVersion.new(version) if version.is_a?(String)
      @constraints.all? { |op, target| check_constraint(version, op, target) }
    end

    private

    def parse_constraints(str)
      constraints = []
      parts = str.split(/\\s+/)

      i = 0
      while i < parts.length
        part = parts[i]

        case part
        when /^\\^(.+)$/ # Caret range: ^1.2.3 means >=1.2.3 <2.0.0
          version = SemanticVersion.new(Regexp.last_match(1))
          constraints << [:>=, version]
          constraints << [:<, SemanticVersion.new("#{version.major + 1}.0.0")]
        when /^~(.+)$/, /^~>(.+)$/ # Tilde range: ~1.2.3 means >=1.2.3 <1.3.0
          version = SemanticVersion.new(Regexp.last_match(1))
          constraints << [:>=, version]
          constraints << [:<, SemanticVersion.new("#{version.major}.#{version.minor + 1}.0")]
        when /^>=(.+)$/
          constraints << [:>=, SemanticVersion.new(Regexp.last_match(1))]
        when /^<=(.+)$/
          constraints << [:<=, SemanticVersion.new(Regexp.last_match(1))]
        when /^>(.+)$/
          constraints << [:>, SemanticVersion.new(Regexp.last_match(1))]
        when /^<(.+)$/
          constraints << [:<, SemanticVersion.new(Regexp.last_match(1))]
        when /^=(.+)$/, /^(\\d+\\.\\d+\\.\\d+.*)$/
          constraints << [:==, SemanticVersion.new(Regexp.last_match(1))]
        when "*"
          # Match any version
        end

        i += 1
      end

      constraints
    end

    def check_constraint(version, operator, target)
      version.send(operator, target)
    end
  end

  # Package manifest (.trb-manifest.json)
  class PackageManifest
    MANIFEST_FILE = ".trb-manifest.json"

    attr_accessor :name, :version, :description, :author, :license, :types, :dependencies, :dev_dependencies,
                  :repository, :keywords, :main

    def initialize(data = {})
      @name = data[:name] || data["name"]
      @version = data[:version] || data["version"] || "0.0.0"
      @description = data[:description] || data["description"]
      @author = data[:author] || data["author"]
      @license = data[:license] || data["license"]
      @types = data[:types] || data["types"] || "lib/types/**/*.d.trb"
      @dependencies = data[:dependencies] || data["dependencies"] || {}
      @dev_dependencies = data[:dev_dependencies] || data["devDependencies"] || {}
      @repository = data[:repository] || data["repository"]
      @keywords = data[:keywords] || data["keywords"] || []
      @main = data[:main] || data["main"]
    end

    def to_h
      {
        name: @name,
        version: @version,
        description: @description,
        author: @author,
        license: @license,
        types: @types,
        dependencies: @dependencies,
        devDependencies: @dev_dependencies,
        repository: @repository,
        keywords: @keywords,
        main: @main,
      }.compact
    end

    def to_json(*_args)
      JSON.pretty_generate(to_h)
    end

    def save(path = MANIFEST_FILE)
      File.write(path, to_json)
    end

    def self.load(path = MANIFEST_FILE)
      return nil unless File.exist?(path)

      data = JSON.parse(File.read(path))
      new(data)
    rescue JSON::ParserError
      nil
    end

    def valid?
      !@name.nil? && !@name.empty? && !@version.nil?
    end

    def add_dependency(name, version)
      @dependencies[name] = version
    end

    def add_dev_dependency(name, version)
      @dev_dependencies[name] = version
    end

    def remove_dependency(name)
      @dependencies.delete(name)
    end
  end

  # Dependency resolver
  class DependencyResolver
    attr_reader :resolved, :conflicts

    def initialize(registry = nil)
      @registry = registry || PackageRegistry.new
      @resolved = {}
      @conflicts = []
      @in_progress = Set.new
    end

    # Resolve all dependencies for a manifest
    def resolve(manifest)
      @resolved = {}
      @conflicts = []

      manifest.dependencies.each do |name, version_constraint|
        resolve_package(name, version_constraint)
      end

      { resolved: @resolved, conflicts: @conflicts }
    end

    # Check for circular dependencies
    def check_circular(manifest)
      visited = Set.new
      path = []

      check_circular_recursive(manifest.name, manifest.dependencies, visited, path)
    end

    private

    def resolve_package(name, constraint)
      return if @resolved.key?(name)

      if @in_progress.include?(name)
        @conflicts << "Circular dependency detected: #{name}"
        return
      end

      @in_progress.add(name)

      # Find matching version
      available = @registry.get_versions(name)
      matching = find_matching_version(available, constraint)

      if matching
        @resolved[name] = matching

        # Resolve transitive dependencies
        pkg_info = @registry.get_package(name, matching)
        if pkg_info && pkg_info[:dependencies]
          pkg_info[:dependencies].each do |dep_name, dep_constraint|
            resolve_package(dep_name, dep_constraint)
          end
        end
      else
        @conflicts << "No matching version for #{name} (#{constraint})"
      end

      @in_progress.delete(name)
    end

    def find_matching_version(versions, constraint)
      constraint_obj = VersionConstraint.new(constraint)
      versions
        .map { |v| SemanticVersion.parse(v) }
        .compact
        .select { |v| constraint_obj.satisfied_by?(v) }
        .max
        &.to_s
    end

    def check_circular_recursive(name, deps, visited, path)
      return [] if deps.nil? || deps.empty?

      if path.include?(name)
        cycle_start = path.index(name)
        return [path[cycle_start..] + [name]]
      end

      return [] if visited.include?(name)

      visited.add(name)
      path.push(name)

      cycles = []
      deps.each_key do |dep_name|
        pkg = @registry.get_package(dep_name, "*")
        if pkg
          cycles.concat(check_circular_recursive(dep_name, pkg[:dependencies] || {}, visited, path.dup))
        end
      end

      path.pop
      cycles
    end
  end

  # Remote registry client (RubyGems.org style API)
  class RemoteRegistry
    DEFAULT_REGISTRY_URL = "https://rubygems.org/api/v1"
    TYPE_REGISTRY_URL = "https://types.ruby-lang.org/api/v1" # Hypothetical type registry

    attr_reader :registry_url, :cache_dir

    def initialize(registry_url: nil, cache_dir: nil)
      @registry_url = registry_url || TYPE_REGISTRY_URL
      @cache_dir = cache_dir || File.join(Dir.home, ".trb-cache")
      @http_cache = {}
      FileUtils.mkdir_p(@cache_dir)
    end

    # Search for type packages
    def search(query, page: 1, per_page: 30)
      uri = URI("#{@registry_url}/search.json")
      uri.query = URI.encode_www_form(query: query, page: page, per_page: per_page)

      response = fetch_json(uri)
      return [] unless response

      response.map do |pkg|
        {
          name: pkg["name"],
          version: pkg["version"],
          downloads: pkg["downloads"],
          summary: pkg["info"] || pkg["summary"],
        }
      end
    rescue StandardError => e
      warn "Registry search failed: #{e.message}"
      []
    end

    # Get package info
    def info(name)
      uri = URI("#{@registry_url}/gems/#{name}.json")
      response = fetch_json(uri)
      return nil unless response

      {
        name: response["name"],
        version: response["version"],
        authors: response["authors"],
        summary: response["info"],
        homepage: response["homepage_uri"],
        source_code: response["source_code_uri"],
        documentation: response["documentation_uri"],
        licenses: response["licenses"],
        dependencies: parse_dependencies(response["dependencies"]),
      }
    rescue StandardError => e
      warn "Failed to fetch package info: #{e.message}"
      nil
    end

    # Get all versions of a package
    def versions(name)
      uri = URI("#{@registry_url}/versions/#{name}.json")
      response = fetch_json(uri)
      return [] unless response

      response.map do |v|
        {
          number: v["number"],
          created_at: v["created_at"],
          prerelease: v["prerelease"],
          sha: v["sha"],
        }
      end
    rescue StandardError => e
      warn "Failed to fetch versions: #{e.message}"
      []
    end

    # Download package
    def download(name, version, target_dir = nil)
      target = target_dir || File.join(@cache_dir, name, version)
      FileUtils.mkdir_p(target)

      # Download from registry
      uri = URI("#{@registry_url}/gems/#{name}-#{version}.gem")

      gem_path = File.join(target, "#{name}-#{version}.gem")
      download_file(uri, gem_path)

      # Extract type definitions
      extract_types(gem_path, target)

      target
    rescue StandardError => e
      warn "Download failed: #{e.message}"
      nil
    end

    # Push package to registry
    def push(gem_path, api_key:)
      uri = URI("#{@registry_url}/gems")

      request = Net::HTTP::Post.new(uri)
      request["Authorization"] = api_key
      request["Content-Type"] = "application/octet-stream"
      request.body = File.binread(gem_path)

      response = send_request(uri, request)

      case response
      when Net::HTTPSuccess
        { success: true, message: response.body }
      else
        { success: false, message: response.body }
      end
    rescue StandardError => e
      { success: false, message: e.message }
    end

    # Yank (unpublish) a version
    def yank(name, version, api_key:)
      uri = URI("#{@registry_url}/gems/yank")

      request = Net::HTTP::Delete.new(uri)
      request["Authorization"] = api_key
      request.set_form_data(gem_name: name, version: version)

      response = send_request(uri, request)

      case response
      when Net::HTTPSuccess
        { success: true }
      else
        { success: false, message: response.body }
      end
    rescue StandardError => e
      { success: false, message: e.message }
    end

    # Get API key info
    def api_key_info(api_key)
      uri = URI("#{@registry_url}/api_key.json")

      request = Net::HTTP::Get.new(uri)
      request["Authorization"] = api_key

      response = send_request(uri, request)

      case response
      when Net::HTTPSuccess
        JSON.parse(response.body)
      end
    rescue StandardError
      nil
    end

    private

    def fetch_json(uri)
      cached = @http_cache[uri.to_s]
      if cached && Time.now - cached[:time] < 300 # 5 min cache
        return cached[:data]
      end

      response = Net::HTTP.get_response(uri)
      return nil unless response.is_a?(Net::HTTPSuccess)

      data = JSON.parse(response.body)
      @http_cache[uri.to_s] = { data: data, time: Time.now }
      data
    rescue JSON::ParserError
      nil
    end

    def download_file(uri, path)
      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == "https") do |http|
        request = Net::HTTP::Get.new(uri)
        http.request(request) do |response|
          File.open(path, "wb") do |file|
            response.read_body { |chunk| file.write(chunk) }
          end
        end
      end
    end

    def send_request(uri, request)
      Net::HTTP.start(uri.host, uri.port, use_ssl: uri.scheme == "https") do |http|
        http.request(request)
      end
    end

    def parse_dependencies(deps)
      return {} unless deps

      result = {}
      (deps["runtime"] || []).each do |dep|
        result[dep["name"]] = dep["requirements"]
      end
      result
    end

    def extract_types(_gem_path, target_dir)
      # In a real implementation, would extract .d.trb files from gem
      # For now, just create marker
      File.write(File.join(target_dir, ".extracted"), Time.now.iso8601)
    end
  end

  # Package registry (local or remote)
  class PackageRegistry
    attr_reader :packages, :local_path, :remote

    def initialize(local_path: nil, remote_url: nil)
      @local_path = local_path || ".trb-packages"
      @remote_url = remote_url
      @packages = {}
      @remote = RemoteRegistry.new(registry_url: remote_url) if remote_url
      FileUtils.mkdir_p(@local_path) if @local_path
    end

    # Register a package
    def register(manifest)
      @packages[manifest.name] ||= {}
      @packages[manifest.name][manifest.version] = {
        dependencies: manifest.dependencies,
        types: manifest.types,
      }
    end

    # Get available versions
    def get_versions(name)
      @packages[name]&.keys || []
    end

    # Get specific package info
    def get_package(name, version)
      return nil unless @packages[name]

      if version == "*"
        latest = get_versions(name).map { |v| SemanticVersion.parse(v) }.compact.max
        return nil unless latest

        version = latest.to_s
      end

      @packages[name][version]
    end

    # Load package from local directory
    def load_local(package_dir)
      manifest_path = File.join(package_dir, PackageManifest::MANIFEST_FILE)
      return nil unless File.exist?(manifest_path)

      manifest = PackageManifest.load(manifest_path)
      register(manifest) if manifest&.valid?
      manifest
    end

    # Install package to local cache
    def install(name, version, target_dir = nil)
      target = target_dir || File.join(@local_path, name, version)
      FileUtils.mkdir_p(target)

      pkg = get_package(name, version)
      return nil unless pkg

      # Copy type definitions
      pkg[:types] || "**/*.d.trb"
      # In real implementation, would download from registry

      { name: name, version: version, path: target }
    end

    # Search packages by keyword
    def search(keyword)
      @packages.select do |name, versions|
        name.include?(keyword) ||
          versions.values.any? { |v| v[:keywords]&.include?(keyword) }
      end.keys
    end
  end

  # Package manager main class
  class PackageManager
    attr_reader :manifest, :registry, :resolver

    def initialize(project_dir: ".")
      @project_dir = project_dir
      @manifest = PackageManifest.load(File.join(project_dir, PackageManifest::MANIFEST_FILE))
      @registry = PackageRegistry.new(local_path: File.join(project_dir, ".trb-packages"))
      @resolver = DependencyResolver.new(@registry)
    end

    # Initialize a new package
    def init(name: nil)
      @manifest = PackageManifest.new(
        name: name || File.basename(@project_dir),
        version: "0.1.0",
        types: "lib/types/**/*.d.trb"
      )
      @manifest.save(File.join(@project_dir, PackageManifest::MANIFEST_FILE))
      @manifest
    end

    # Add a dependency
    def add(name, version = "*", dev: false)
      ensure_manifest!

      if dev
        @manifest.add_dev_dependency(name, version)
      else
        @manifest.add_dependency(name, version)
      end

      @manifest.save(File.join(@project_dir, PackageManifest::MANIFEST_FILE))

      # Resolve and install
      install
    end

    # Remove a dependency
    def remove(name)
      ensure_manifest!
      @manifest.remove_dependency(name)
      @manifest.save(File.join(@project_dir, PackageManifest::MANIFEST_FILE))
    end

    # Install all dependencies
    def install
      ensure_manifest!

      result = @resolver.resolve(@manifest)

      if result[:conflicts].any?
        raise "Dependency conflicts: #{result[:conflicts].join(", ")}"
      end

      installed = []
      result[:resolved].each do |name, version|
        pkg = @registry.install(name, version)
        installed << pkg if pkg
      end

      # Generate lockfile
      generate_lockfile(result[:resolved])

      installed
    end

    # Update dependencies
    def update(name = nil)
      ensure_manifest!

      if name
        # Update specific package
        current = @manifest.dependencies[name]
        if current
          @manifest.dependencies[name] = "*" # Get latest
          result = @resolver.resolve(@manifest)
          if result[:resolved][name]
            @manifest.dependencies[name] = "^#{result[:resolved][name]}"
            @manifest.save(File.join(@project_dir, PackageManifest::MANIFEST_FILE))
          end
        end
      else
        # Update all
        @manifest.dependencies.each_key do |dep_name|
          update(dep_name)
        end
      end

      install
    end

    # List installed packages
    def list
      lockfile_path = File.join(@project_dir, ".trb-lock.json")
      return {} unless File.exist?(lockfile_path)

      JSON.parse(File.read(lockfile_path))
    rescue JSON::ParserError
      {}
    end

    # Publish package (stub - would integrate with real registry)
    def publish
      ensure_manifest!

      unless @manifest.valid?
        raise "Invalid manifest: missing name or version"
      end

      # Validate package
      validate_package

      # In real implementation, would upload to registry
      {
        name: @manifest.name,
        version: @manifest.version,
        status: :published,
      }
    end

    # Create deprecation notice
    def deprecate(version, message)
      ensure_manifest!

      {
        package: @manifest.name,
        version: version,
        deprecated: true,
        message: message,
      }
    end

    private

    def ensure_manifest!
      unless @manifest
        raise "No manifest found. Run 'init' first."
      end
    end

    def generate_lockfile(resolved)
      lockfile = {
        lockfileVersion: 1,
        packages: resolved,
        generatedAt: Time.now.iso8601,
      }

      File.write(
        File.join(@project_dir, ".trb-lock.json"),
        JSON.pretty_generate(lockfile)
      )
    end

    def validate_package
      errors = []

      errors << "Missing package name" unless @manifest.name
      errors << "Invalid version" unless SemanticVersion.parse(@manifest.version)

      # Check for type files
      types_pattern = @manifest.types || "**/*.d.trb"
      types_files = Dir.glob(File.join(@project_dir, types_pattern))
      errors << "No type definition files found" if types_files.empty?

      raise errors.join(", ") unless errors.empty?
    end
  end
end
`,
  "lib/t_ruby/parser.rb": `# frozen_string_literal: true

module TRuby
  # Enhanced Parser using Parser Combinator for complex type expressions
  # Maintains backward compatibility with original Parser interface
  class Parser
    # Type names that are recognized as valid
    VALID_TYPES = %w[String Integer Boolean Array Hash Symbol void nil].freeze

    # Pattern for method/variable names that supports Unicode characters
    # \\p{L} matches any Unicode letter, \\p{N} matches any Unicode number
    IDENTIFIER_CHAR = '[\\p{L}\\p{N}_]'
    # Method names can end with ? or !
    METHOD_NAME_PATTERN = "#{IDENTIFIER_CHAR}+[?!]?".freeze
    # Visibility modifiers for method definitions
    VISIBILITY_PATTERN = '(?:(?:private|protected|public)\\s+)?'

    # TODO: Replace regex-based parsing with TokenDeclarationParser
    # See: lib/t_ruby/parser_combinator/token/token_declaration_parser.rb

    attr_reader :source, :ir_program

    def initialize(source, parse_body: true)
      @source = source
      @lines = source.split("\\n")
      @parse_body = parse_body
      @type_parser = ParserCombinator::TypeParser.new
      @body_parser = ParserCombinator::TokenBodyParser.new if parse_body
      @ir_program = nil
    end

    def parse
      functions = []
      type_aliases = []
      interfaces = []
      classes = []
      i = 0

      # Pre-detect heredoc regions to skip
      heredoc_ranges = HeredocDetector.detect(@lines)

      while i < @lines.length
        # Skip lines inside heredoc content
        if HeredocDetector.inside_heredoc?(i, heredoc_ranges)
          i += 1
          next
        end

        line = @lines[i]

        # Match type alias definitions
        if line.match?(/^\\s*type\\s+\\w+/)
          alias_info = parse_type_alias(line)
          type_aliases << alias_info if alias_info
        end

        # Match interface definitions
        if line.match?(/^\\s*interface\\s+\\w+/)
          interface_info, next_i = parse_interface(i)
          if interface_info
            interfaces << interface_info
            i = next_i
            next
          end
        end

        # Match class definitions
        if line.match?(/^\\s*class\\s+\\w+/)
          class_info, next_i = parse_class(i)
          if class_info
            classes << class_info
            i = next_i
            next
          end
        end

        # Match function definitions (top-level only, not inside class)
        if line.match?(/^\\s*#{VISIBILITY_PATTERN}def\\s+#{IDENTIFIER_CHAR}+/)
          func_info, next_i = parse_function_with_body(i)
          if func_info
            functions << func_info
            i = next_i
            next
          end
        end

        i += 1
      end

      result = {
        type: :success,
        functions: functions,
        type_aliases: type_aliases,
        interfaces: interfaces,
        classes: classes,
      }

      # Build IR
      builder = IR::Builder.new
      @ir_program = builder.build(result, source: @source)

      result
    rescue Scanner::ScanError => e
      raise ParseError.new(e.message, line: e.line, column: e.column)
    end

    # Parse to IR directly (new API)
    def parse_to_ir
      parse unless @ir_program
      @ir_program
    end

    # Parse a type expression using combinator
    def parse_type(type_string)
      result = @type_parser.parse(type_string)
      result[:success] ? result[:type] : nil
    end

    private

    # 최상위 함수를 본문까지 포함하여 파싱
    def parse_function_with_body(start_index)
      line = @lines[start_index]
      func_info = parse_function_definition(line, line_number: start_index + 1)
      return [nil, start_index] unless func_info

      # Add location info (1-based line number, column is 1 + indentation)
      def_indent = line.match(/^(\\s*)/)[1].length
      func_info[:line] = start_index + 1
      func_info[:column] = def_indent + 1

      i = start_index + 1
      body_start = i
      body_end = i

      # end 키워드 찾기
      while i < @lines.length
        current_line = @lines[i]

        if current_line.match?(/^\\s*end\\s*$/)
          end_indent = current_line.match(/^(\\s*)/)[1].length
          if end_indent <= def_indent
            body_end = i
            break
          end
        end

        i += 1
      end

      # 본문 파싱 (parse_body 옵션이 활성화된 경우)
      if @parse_body && @body_parser && body_start < body_end
        func_info[:body_ir] = @body_parser.parse(@lines, body_start, body_end)
        func_info[:body_range] = { start: body_start, end: body_end }
      end

      [func_info, i]
    end

    def parse_type_alias(line)
      match = line.match(/^\\s*type\\s+(\\w+)\\s*=\\s*(.+?)\\s*$/)
      return nil unless match

      alias_name = match[1]
      definition = match[2].strip

      # Use combinator for complex type parsing
      type_result = @type_parser.parse(definition)
      if type_result[:success]
        return {
          name: alias_name,
          definition: definition,
          ir_type: type_result[:type],
        }
      end

      {
        name: alias_name,
        definition: definition,
      }
    end

    def parse_function_definition(line, line_number: 1) # rubocop:disable Lint/UnusedMethodArgument
      # Match methods with or without parentheses
      # def foo(params): Type   - with params and return type
      # def foo(): Type         - no params but with return type
      # def foo(params)         - with params, no return type
      # def foo                  - no params, no return type
      # Also supports visibility modifiers: private def, protected def, public def

      match = line.match(/^\\s*(?:(private|protected|public)\\s+)?def\\s+(#{METHOD_NAME_PATTERN})\\s*(?:\\((.*?)\\))?\\s*(?::\\s*(.+?))?\\s*$/)
      return nil unless match

      visibility = match[1] ? match[1].to_sym : :public
      function_name = match[2]
      params_str = match[3] || ""
      return_type_str = match[4]&.strip

      # Validate return type if present
      if return_type_str
        return_type_str = validate_and_extract_type(return_type_str)
      end

      params = parse_parameters(params_str)

      result = {
        name: function_name,
        params: params,
        return_type: return_type_str,
        visibility: visibility,
      }

      # Parse return type with combinator
      if return_type_str
        type_result = @type_parser.parse(return_type_str)
        result[:ir_return_type] = type_result[:type] if type_result[:success]
      end

      result
    end

    # Validate type string and return nil if invalid
    def validate_and_extract_type(type_str)
      return nil if type_str.nil? || type_str.empty?

      # Check for whitespace in simple type names that would be invalid
      # Pattern: Capital letter followed by lowercase, then space, then more lowercase
      # e.g., "Str ing", "Int eger", "Bool ean"
      if type_str.match?(/^[A-Z][a-z]*\\s+[a-z]+/)
        return nil
      end

      # Check for trailing operators
      return nil if type_str.match?(/[|&]\\s*$/)

      # Check for leading operators
      return nil if type_str.match?(/^\\s*[|&]/)

      # Check for unbalanced brackets
      return nil if type_str.count("<") != type_str.count(">")
      return nil if type_str.count("[") != type_str.count("]")
      return nil if type_str.count("(") != type_str.count(")")

      # Check for empty generic arguments
      return nil if type_str.match?(/<\\s*>/)

      type_str
    end

    def parse_parameters(params_str)
      return [] if params_str.empty?

      parameters = []
      param_list = split_params(params_str)

      param_list.each do |param|
        param = param.strip

        # 1. 더블 스플랫: **name: Type
        if param.start_with?("**")
          param_info = parse_double_splat_parameter(param)
          parameters << param_info if param_info
        # 2. 키워드 인자 그룹: { ... } 또는 { ... }: InterfaceName
        elsif param.start_with?("{")
          keyword_params = parse_keyword_args_group(param)
          parameters.concat(keyword_params) if keyword_params
        # 3. Hash 리터럴: name: { ... }
        elsif param.match?(/^\\w+:\\s*\\{/)
          param_info = parse_hash_literal_parameter(param)
          parameters << param_info if param_info
        # 4. 일반 위치 인자: name: Type 또는 name: Type = default
        else
          param_info = parse_single_parameter(param)
          parameters << param_info if param_info
        end
      end

      parameters
    end

    def split_params(params_str)
      # Handle nested generics, braces, brackets
      result = []
      current = ""
      depth = 0
      brace_depth = 0

      params_str.each_char do |char|
        case char
        when "<", "[", "("
          depth += 1
          current += char
        when ">", "]", ")"
          depth -= 1
          current += char
        when "{"
          brace_depth += 1
          current += char
        when "}"
          brace_depth -= 1
          current += char
        when ","
          if depth.zero? && brace_depth.zero?
            result << current.strip
            current = ""
          else
            current += char
          end
        else
          current += char
        end
      end

      result << current.strip unless current.empty?
      result
    end

    # 더블 스플랫 파라미터 파싱: **opts: Type
    def parse_double_splat_parameter(param)
      # **name: Type
      match = param.match(/^\\*\\*(\\w+)(?::\\s*(.+?))?$/)
      return nil unless match

      param_name = match[1]
      type_str = match[2]&.strip

      result = {
        name: param_name,
        type: type_str,
        kind: :keyrest,
      }

      if type_str
        type_result = @type_parser.parse(type_str)
        result[:ir_type] = type_result[:type] if type_result[:success]
      end

      result
    end

    # 키워드 인자 그룹 파싱: { name: String, age: Integer = 0 } 또는 { name:, age: 0 }: InterfaceName
    def parse_keyword_args_group(param)
      # { ... }: InterfaceName 형태 확인
      # 또는 { ... } 만 있는 형태 (인라인 타입)
      interface_match = param.match(/^\\{(.+)\\}\\s*:\\s*(\\w+)\\s*$/)
      inline_match = param.match(/^\\{(.+)\\}\\s*$/) unless interface_match

      if interface_match
        inner_content = interface_match[1]
        interface_name = interface_match[2]
        parse_keyword_args_with_interface(inner_content, interface_name)
      elsif inline_match
        inner_content = inline_match[1]
        parse_keyword_args_inline(inner_content)
      end
    end

    # interface 참조 키워드 인자 파싱: { name:, age: 0 }: UserParams
    def parse_keyword_args_with_interface(inner_content, interface_name)
      parameters = []
      parts = split_keyword_args(inner_content)

      parts.each do |part|
        part = part.strip
        next if part.empty?

        # name: default_value 또는 name: 형태
        next unless part.match?(/^(\\w+):\\s*(.*)$/)

        match = part.match(/^(\\w+):\\s*(.*)$/)
        param_name = match[1]
        default_value = match[2].strip
        default_value = nil if default_value.empty?

        parameters << {
          name: param_name,
          type: nil, # interface에서 타입을 가져옴
          default_value: default_value,
          kind: :keyword,
          interface_ref: interface_name,
        }
      end

      parameters
    end

    # 인라인 타입 키워드 인자 파싱: { name: String, age: Integer = 0 }
    def parse_keyword_args_inline(inner_content)
      parameters = []
      parts = split_keyword_args(inner_content)

      parts.each do |part|
        part = part.strip
        next if part.empty?

        # name: Type = default 또는 name: Type 형태
        next unless part.match?(/^(\\w+):\\s*(.+)$/)

        match = part.match(/^(\\w+):\\s*(.+)$/)
        param_name = match[1]
        type_and_default = match[2].strip

        # Type = default 분리
        type_str, default_value = split_type_and_default(type_and_default)

        result = {
          name: param_name,
          type: type_str,
          default_value: default_value,
          kind: :keyword,
        }

        if type_str
          type_result = @type_parser.parse(type_str)
          result[:ir_type] = type_result[:type] if type_result[:success]
        end

        parameters << result
      end

      parameters
    end

    # 키워드 인자 내부를 콤마로 분리 (중첩된 제네릭/배열/해시 고려)
    def split_keyword_args(content)
      StringUtils.split_by_comma(content)
    end

    # 타입과 기본값 분리: "String = 0" -> ["String", "0"]
    def split_type_and_default(type_and_default)
      StringUtils.split_type_and_default(type_and_default)
    end

    # Hash 리터럴 파라미터 파싱: config: { host: String, port: Integer }
    def parse_hash_literal_parameter(param)
      # name: { ... } 또는 name: { ... }: InterfaceName
      match = param.match(/^(\\w+):\\s*(\\{.+\\})(?::\\s*(\\w+))?$/)
      return nil unless match

      param_name = match[1]
      hash_type = match[2]
      interface_name = match[3]

      result = {
        name: param_name,
        type: interface_name || hash_type,
        kind: :required,
        hash_type_def: hash_type, # 원본 해시 타입 정의 저장
      }

      result[:interface_ref] = interface_name if interface_name

      result
    end

    def parse_single_parameter(param)
      # name: Type = default 또는 name: Type 또는 name
      # 기본값이 있는 경우 먼저 처리
      type_str = nil
      default_value = nil

      if param.include?(":")
        match = param.match(/^(\\w+):\\s*(.+)$/)
        return nil unless match

        param_name = match[1]
        type_and_default = match[2].strip
        type_str, default_value = split_type_and_default(type_and_default)
      else
        # 타입 없이 이름만 있는 경우
        param_name = param.strip
      end

      result = {
        name: param_name,
        type: type_str,
        default_value: default_value,
        kind: default_value ? :optional : :required,
      }

      # Parse type with combinator
      if type_str
        type_result = @type_parser.parse(type_str)
        result[:ir_type] = type_result[:type] if type_result[:success]
      end

      result
    end

    def parse_class(start_index)
      line = @lines[start_index]
      match = line.match(/^\\s*class\\s+(\\w+)(?:\\s*<\\s*(\\w+))?/)
      return [nil, start_index] unless match

      class_name = match[1]
      superclass = match[2]
      methods = []
      instance_vars = []
      i = start_index + 1
      class_indent = line.match(/^(\\s*)/)[1].length
      class_end = i

      # 먼저 클래스의 끝을 찾음
      temp_i = i
      while temp_i < @lines.length
        current_line = @lines[temp_i]
        if current_line.match?(/^\\s*end\\s*$/)
          end_indent = current_line.match(/^(\\s*)/)[1].length
          if end_indent <= class_indent
            class_end = temp_i
            break
          end
        end
        temp_i += 1
      end

      while i < class_end
        current_line = @lines[i]

        # Match method definitions inside class
        if current_line.match?(/^\\s*#{VISIBILITY_PATTERN}def\\s+#{IDENTIFIER_CHAR}+/)
          method_info, next_i = parse_method_in_class(i, class_end)
          if method_info
            methods << method_info
            i = next_i
            next
          end
        end

        i += 1
      end

      # 메서드 본문에서 인스턴스 변수 추출
      methods.each do |method_info|
        extract_instance_vars_from_body(method_info[:body_ir], instance_vars)
      end

      # Try to infer instance variable types from initialize parameters
      init_method = methods.find { |m| m[:name] == "initialize" }
      if init_method
        instance_vars.each do |ivar|
          # Find matching parameter (e.g., @name = name)
          matching_param = init_method[:params]&.find { |p| p[:name] == ivar[:name] }
          ivar[:type] = matching_param[:type] if matching_param && matching_param[:type]
          ivar[:ir_type] = matching_param[:ir_type] if matching_param && matching_param[:ir_type]
        end
      end

      [{
        name: class_name,
        superclass: superclass,
        methods: methods,
        instance_vars: instance_vars,
      }, class_end,]
    end

    # 클래스 내부의 메서드를 본문까지 포함하여 파싱
    def parse_method_in_class(start_index, class_end)
      line = @lines[start_index]
      method_info = parse_function_definition(line, line_number: start_index + 1)
      return [nil, start_index] unless method_info

      # Add location info (1-based line number, column is 1 + indentation)
      def_indent = line.match(/^(\\s*)/)[1].length
      method_info[:line] = start_index + 1
      method_info[:column] = def_indent + 1

      i = start_index + 1
      body_start = i
      body_end = i

      # 메서드의 end 키워드 찾기
      while i < class_end
        current_line = @lines[i]

        if current_line.match?(/^\\s*end\\s*$/)
          end_indent = current_line.match(/^(\\s*)/)[1].length
          if end_indent <= def_indent
            body_end = i
            break
          end
        end

        i += 1
      end

      # 본문 파싱 (parse_body 옵션이 활성화된 경우)
      if @parse_body && @body_parser && body_start < body_end
        method_info[:body_ir] = @body_parser.parse(@lines, body_start, body_end)
        method_info[:body_range] = { start: body_start, end: body_end }
      end

      [method_info, i]
    end

    # 본문 IR에서 인스턴스 변수 추출
    def extract_instance_vars_from_body(body_ir, instance_vars)
      return unless body_ir.is_a?(IR::Block)

      body_ir.statements.each do |stmt|
        case stmt
        when IR::Assignment
          if stmt.target.start_with?("@") && !stmt.target.start_with?("@@")
            ivar_name = stmt.target[1..] # @ 제거
            unless instance_vars.any? { |iv| iv[:name] == ivar_name }
              instance_vars << { name: ivar_name }
            end
          end
        when IR::Block
          extract_instance_vars_from_body(stmt, instance_vars)
        end
      end
    end

    def parse_interface(start_index)
      line = @lines[start_index]
      match = line.match(/^\\s*interface\\s+([\\w:]+)/)
      return [nil, start_index] unless match

      interface_name = match[1]
      members = []
      i = start_index + 1

      while i < @lines.length
        current_line = @lines[i]
        break if current_line.match?(/^\\s*end\\s*$/)

        if current_line.match?(/^\\s*[\\w!?]+\\s*:\\s*/)
          member_match = current_line.match(/^\\s*([\\w!?]+)\\s*:\\s*(.+?)\\s*$/)
          if member_match
            member = {
              name: member_match[1],
              type: member_match[2].strip,
            }

            # Parse member type with combinator
            type_result = @type_parser.parse(member[:type])
            member[:ir_type] = type_result[:type] if type_result[:success]

            members << member
          end
        end

        i += 1
      end

      [{ name: interface_name, members: members }, i]
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/alternative.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Alternative: try first, if fails try second
    class Alternative < Parser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(input, position = 0)
        result = @left.parse(input, position)
        return result if result.success?

        @right.parse(input, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/chain_left.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Chainl: left-associative chain
    class ChainLeft < Parser
      def initialize(term, op)
        @term = term
        @op = op
      end

      def parse(input, position = 0)
        first = @term.parse(input, position)
        return first if first.failure?

        result = first.value
        current_pos = first.position

        loop do
          op_result = @op.parse(input, current_pos)
          break if op_result.failure?

          term_result = @term.parse(input, op_result.position)
          break if term_result.failure?

          result = op_result.value.call(result, term_result.value)
          current_pos = term_result.position
        end

        ParseResult.success(result, input, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/choice.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Choice: try multiple parsers in order
    class Choice < Parser
      def initialize(*parsers)
        @parsers = parsers
      end

      def parse(input, position = 0)
        best_error = nil
        best_position = position

        @parsers.each do |parser|
          result = parser.parse(input, position)
          return result if result.success?

          if result.position >= best_position
            best_error = result.error
            best_position = result.position
          end
        end

        ParseResult.failure(best_error || "No alternative matched", input, best_position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/flat_map.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # FlatMap (bind)
    class FlatMap < Parser
      def initialize(parser, func)
        @parser = parser
        @func = func
      end

      def parse(input, position = 0)
        result = @parser.parse(input, position)
        return result if result.failure?

        next_parser = @func.call(result.value)
        next_parser.parse(input, result.position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/label.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Label for error messages
    class Label < Parser
      def initialize(parser, name)
        @parser = parser
        @name = name
      end

      def parse(input, position = 0)
        result = @parser.parse(input, position)
        if result.failure?
          ParseResult.failure("Expected #{@name}", input, position)
        else
          result
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/lookahead.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Lookahead: check without consuming
    class Lookahead < Parser
      def initialize(parser)
        @parser = parser
      end

      def parse(input, position = 0)
        result = @parser.parse(input, position)
        if result.success?
          ParseResult.success(result.value, input, position)
        else
          result
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/many.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Many: zero or more
    class Many < Parser
      def initialize(parser)
        @parser = parser
      end

      def parse(input, position = 0)
        results = []
        current_pos = position

        loop do
          result = @parser.parse(input, current_pos)
          break if result.failure?

          results << result.value
          break if result.position == current_pos # Prevent infinite loop

          current_pos = result.position
        end

        ParseResult.success(results, input, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/many1.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Many1: one or more
    class Many1 < Parser
      def initialize(parser)
        @parser = parser
      end

      def parse(input, position = 0)
        first = @parser.parse(input, position)
        return first if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          result = @parser.parse(input, current_pos)
          break if result.failure?

          results << result.value
          break if result.position == current_pos

          current_pos = result.position
        end

        ParseResult.success(results, input, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/map.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Map result
    class Map < Parser
      def initialize(parser, func)
        @parser = parser
        @func = func
      end

      def parse(input, position = 0)
        @parser.parse(input, position).map(&@func)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/not_followed_by.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Not followed by
    class NotFollowedBy < Parser
      def initialize(parser)
        @parser = parser
      end

      def parse(input, position = 0)
        result = @parser.parse(input, position)
        if result.failure?
          ParseResult.success(nil, input, position)
        else
          ParseResult.failure("Unexpected match", input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/optional.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Optional: zero or one
    class Optional < Parser
      def initialize(parser)
        @parser = parser
      end

      def parse(input, position = 0)
        result = @parser.parse(input, position)
        if result.success?
          result
        else
          ParseResult.success(nil, input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/sep_by.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Separated by delimiter
    class SepBy < Parser
      def initialize(parser, delimiter)
        @parser = parser
        @delimiter = delimiter
      end

      def parse(input, position = 0)
        first = @parser.parse(input, position)
        return ParseResult.success([], input, position) if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          delim_result = @delimiter.parse(input, current_pos)
          break if delim_result.failure?

          item_result = @parser.parse(input, delim_result.position)
          break if item_result.failure?

          results << item_result.value
          current_pos = item_result.position
        end

        ParseResult.success(results, input, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/sep_by1.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Separated by 1 (at least one)
    class SepBy1 < Parser
      def initialize(parser, delimiter)
        @parser = parser
        @delimiter = delimiter
      end

      def parse(input, position = 0)
        first = @parser.parse(input, position)
        return first if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          delim_result = @delimiter.parse(input, current_pos)
          break if delim_result.failure?

          item_result = @parser.parse(input, delim_result.position)
          break if item_result.failure?

          results << item_result.value
          current_pos = item_result.position
        end

        ParseResult.success(results, input, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/sequence.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Sequence two parsers
    class Sequence < Parser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(input, position = 0)
        result1 = @left.parse(input, position)
        return result1 if result1.failure?

        result2 = @right.parse(input, result1.position)
        return result2 if result2.failure?

        ParseResult.success([result1.value, result2.value], input, result2.position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/combinators/skip_right.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Skip right: parse both, return left
    class SkipRight < Parser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(input, position = 0)
        result1 = @left.parse(input, position)
        return result1 if result1.failure?

        result2 = @right.parse(input, result1.position)
        return result2 if result2.failure?

        ParseResult.success(result1.value, input, result2.position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/declaration_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Declaration Parser - Parse T-Ruby declarations
    class DeclarationParser
      include DSL

      def initialize
        @type_parser = TypeParser.new
        build_parsers
      end

      def parse(input)
        result = @declaration.parse(input.strip)
        if result.success?
          { success: true, declarations: result.value }
        else
          { success: false, error: result.error, position: result.position }
        end
      end

      def parse_file(input)
        result = @program.parse(input)
        if result.success?
          { success: true, declarations: result.value.compact }
        else
          { success: false, error: result.error, position: result.position }
        end
      end

      private

      def build_parsers
        # Type expression (delegate to TypeParser)
        lazy { parse_type_inline }

        # Keywords
        kw_type = lexeme(string("type"))
        kw_interface = lexeme(string("interface"))
        kw_def = lexeme(string("def"))
        kw_end = lexeme(string("end"))
        lexeme(string("class"))
        lexeme(string("module"))

        # Type alias: type Name = Definition
        type_alias = (
          kw_type >>
          lexeme(identifier) <<
          lexeme(char("=")) >>
          regex(/[^\\n]+/).map(&:strip)
        ).map do |((_, name), definition)|
          type_result = @type_parser.parse(definition)
          if type_result[:success]
            IR::TypeAlias.new(name: name, definition: type_result[:type])
          end
        end

        # Interface member: name: Type
        interface_member = (
          lexeme(identifier) <<
          lexeme(char(":")) >>
          regex(/[^\\n]+/).map(&:strip)
        ).map do |(name, type_str)|
          type_result = @type_parser.parse(type_str)
          if type_result[:success]
            IR::InterfaceMember.new(name: name, type_signature: type_result[:type])
          end
        end

        # Interface: interface Name ... end
        interface_body = (interface_member << (newline | spaces)).many

        interface_decl = (
          kw_interface >>
          lexeme(identifier) <<
          (newline | spaces) >>
          interface_body <<
          kw_end
        ).map do |((_, name), members)|
          IR::Interface.new(name: name, members: members.compact)
        end

        # Parameter: name: Type or name
        param = (
          identifier >>
          (lexeme(char(":")) >> regex(/[^,)]+/).map(&:strip)).optional
        ).map do |(name, type_str)|
          type_node = if type_str
                        type_str_val = type_str.is_a?(Array) ? type_str.last : type_str
                        result = @type_parser.parse(type_str_val)
                        result[:success] ? result[:type] : nil
                      end
          IR::Parameter.new(name: name, type_annotation: type_node)
        end

        # Parameters list
        params_list = (
          lexeme(char("(")) >>
          param.sep_by(lexeme(char(","))) <<
          lexeme(char(")"))
        ).map { |(_, params)| params }

        # Return type annotation
        return_type = (
          lexeme(char(":")) >>
          regex(/[^\\n]+/).map(&:strip)
        ).map { |(_, type_str)| type_str }.optional

        # Method definition: def name(params): ReturnType
        method_def = (
          kw_def >>
          identifier >>
          params_list.optional >>
          return_type
        ).map do |(((_, name), params), ret_str)|
          ret_type = if ret_str
                       result = @type_parser.parse(ret_str)
                       result[:success] ? result[:type] : nil
                     end
          IR::MethodDef.new(
            name: name,
            params: params || [],
            return_type: ret_type
          )
        end

        # Any declaration
        @declaration = choice(
          type_alias,
          interface_decl,
          method_def
        )

        # Line (declaration or empty)
        line = (@declaration << (newline | eof)) | (spaces >> newline).map { nil }

        # Program (multiple declarations)
        @program = line.many
      end

      def parse_type_inline
        Lazy.new { @type_parser.instance_variable_get(:@type_expr) }
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/dsl.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # DSL Module - Convenience methods
    module DSL
      def literal(str)
        Literal.new(str)
      end

      def regex(pattern, description = nil)
        Regex.new(pattern, description)
      end

      def satisfy(description = "character", &predicate)
        Satisfy.new(predicate, description)
      end

      def char(c)
        Literal.new(c)
      end

      def string(str)
        Literal.new(str)
      end

      def eof
        EndOfInput.new
      end

      def pure(value)
        Pure.new(value)
      end

      def fail(message)
        Fail.new(message)
      end

      def lazy(&)
        Lazy.new(&)
      end

      def choice(*parsers)
        Choice.new(*parsers)
      end

      def sequence(*parsers)
        parsers.reduce { |acc, p| acc >> p }
      end

      # Common character parsers
      def digit
        satisfy("digit") { |c| c =~ /[0-9]/ }
      end

      def letter
        satisfy("letter") { |c| c =~ /[a-zA-Z]/ }
      end

      def alphanumeric
        satisfy("alphanumeric") { |c| c =~ /[a-zA-Z0-9]/ }
      end

      def whitespace
        satisfy("whitespace") { |c| c =~ /\\s/ }
      end

      def spaces
        whitespace.many.map(&:join)
      end

      def spaces1
        whitespace.many1.map(&:join)
      end

      def newline
        char("\\n") | string("\\r\\n")
      end

      def identifier
        (letter >> (alphanumeric | char("_")).many).map do |(first, rest)|
          first + rest.join
        end
      end

      def integer
        (char("-").optional >> digit.many1).map do |(sign, digits)|
          num = digits.join.to_i
          sign ? -num : num
        end
      end

      def float
        regex(/-?\\d+\\.\\d+/, "float").map(&:to_f)
      end

      def quoted_string(quote = '"')
        content = satisfy("string character") { |c| c != quote && c != "\\\\" }
        escape = (char("\\\\") >> satisfy("escape char")).map { |(_bs, c)| c }

        (char(quote) >> (content | escape).many.map(&:join) << char(quote)).map { |(_, str)| str }
      end

      # Skip whitespace around parser
      def lexeme(parser)
        (spaces >> parser << spaces).map { |(_, val)| val }
      end

      # Chain for left-associative operators
      def chainl(term, op)
        ChainLeft.new(term, op)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/parse_error.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Error Reporting
    class ParseError
      attr_reader :message, :position, :line, :column, :input

      def initialize(message:, position:, input:)
        @message = message
        @position = position
        @input = input
        @line, @column = calculate_line_column
      end

      def to_s
        "Parse error at line #{@line}, column #{@column}: #{@message}"
      end

      def context(lines_before: 2, lines_after: 1)
        input_lines = @input.split("\\n")
        start_line = [@line - lines_before - 1, 0].max
        end_line = [@line + lines_after - 1, input_lines.length - 1].min

        result = []
        (start_line..end_line).each do |i|
          prefix = i == @line - 1 ? ">>> " : "    "
          result << "#{prefix}#{i + 1}: #{input_lines[i]}"

          if i == @line - 1
            result << "    #{" " * (@column + @line.to_s.length + 1)}^"
          end
        end

        result.join("\\n")
      end

      private

      def calculate_line_column
        lines = @input[0...@position].split("\\n", -1)
        line = lines.length
        column = lines.last&.length || 0
        [line, column + 1]
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/parse_result.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Parse result - either success or failure
    class ParseResult
      attr_reader :value, :remaining, :position, :error

      def initialize(success:, value: nil, remaining: "", position: 0, error: nil)
        @success = success
        @value = value
        @remaining = remaining
        @position = position
        @error = error
      end

      def success?
        @success
      end

      def failure?
        !@success
      end

      def self.success(value, remaining, position)
        new(success: true, value: value, remaining: remaining, position: position)
      end

      def self.failure(error, remaining, position)
        new(success: false, error: error, remaining: remaining, position: position)
      end

      def map
        return self if failure?

        ParseResult.success(yield(value), remaining, position)
      end

      def flat_map
        return self if failure?

        yield(value, remaining, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Base parser class for string-based parsing
    class Parser
      def parse(input, position = 0)
        raise NotImplementedError
      end

      # Combinators as methods

      # Sequence: run this parser, then the other
      def >>(other)
        Sequence.new(self, other)
      end

      # Alternative: try this parser, if it fails try the other
      def |(other)
        Alternative.new(self, other)
      end

      # Map: transform the result
      def map(&block)
        Map.new(self, block)
      end

      # FlatMap: transform with another parser
      def flat_map(&block)
        FlatMap.new(self, block)
      end

      # Many: zero or more repetitions
      def many
        Many.new(self)
      end

      # Many1: one or more repetitions
      def many1
        Many1.new(self)
      end

      # Optional: zero or one
      def optional
        Optional.new(self)
      end

      # Separated by: parse items separated by delimiter
      def sep_by(delimiter)
        SepBy.new(self, delimiter)
      end

      # Separated by 1: at least one item
      def sep_by1(delimiter)
        SepBy1.new(self, delimiter)
      end

      # Between: parse between left and right delimiters
      def between(left, right)
        (left >> self << right).map { |(_, val)| val }
      end

      # Skip right: parse both, keep left result
      def <<(other)
        SkipRight.new(self, other)
      end

      # Label: add a descriptive label for error messages
      def label(name)
        Label.new(self, name)
      end

      # Lookahead: check without consuming
      def lookahead
        Lookahead.new(self)
      end

      # Not: succeed only if parser fails
      def not_followed_by
        NotFollowedBy.new(self)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/end_of_input.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Parse end of input
    class EndOfInput < Parser
      def parse(input, position = 0)
        if position >= input.length
          ParseResult.success(nil, input, position)
        else
          ParseResult.failure("Expected end of input", input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/fail.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Always fail
    class Fail < Parser
      def initialize(message)
        @message = message
      end

      def parse(input, position = 0)
        ParseResult.failure(@message, input, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/lazy.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Lazy parser (for recursive grammars)
    class Lazy < Parser
      def initialize(&block)
        @block = block
        @parser = nil
      end

      def parse(input, position = 0)
        @parser ||= @block.call
        @parser.parse(input, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/literal.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Parse a literal string
    class Literal < Parser
      def initialize(string)
        @string = string
      end

      def parse(input, position = 0)
        remaining = input[position..]
        if remaining&.start_with?(@string)
          ParseResult.success(@string, input, position + @string.length)
        else
          ParseResult.failure("Expected '#{@string}'", input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/pure.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Always succeed with a value
    class Pure < Parser
      def initialize(value)
        @value = value
      end

      def parse(input, position = 0)
        ParseResult.success(@value, input, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/regex.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Parse using regex
    class Regex < Parser
      def initialize(pattern, description = nil)
        @pattern = pattern.is_a?(Regexp) ? pattern : Regexp.new("^#{pattern}")
        @description = description || @pattern.inspect
      end

      def parse(input, position = 0)
        remaining = input[position..]
        match = @pattern.match(remaining)

        if match&.begin(0)&.zero?
          matched = match[0]
          ParseResult.success(matched, input, position + matched.length)
        else
          ParseResult.failure("Expected #{@description}", input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/primitives/satisfy.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Parse a single character matching predicate
    class Satisfy < Parser
      def initialize(predicate, description = "character")
        @predicate = predicate
        @description = description
      end

      def parse(input, position = 0)
        if position < input.length && @predicate.call(input[position])
          ParseResult.success(input[position], input, position + 1)
        else
          ParseResult.failure("Expected #{@description}", input, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/expression_parser.rb": `# frozen_string_literal: true

require "set"

module TRuby
  module ParserCombinator
    # Expression Parser - Parse expressions into IR nodes
    # Uses Pratt parser (operator precedence parsing) for correct precedence
    class ExpressionParser
      include TokenDSL

      # Operator precedence levels (higher = binds tighter)
      PRECEDENCE = {
        or_or: 1,      # ||
        and_and: 2,    # &&
        eq_eq: 3,      # ==
        bang_eq: 3,    # !=
        lt: 4,         # <
        gt: 4,         # >
        lt_eq: 4,      # <=
        gt_eq: 4,      # >=
        spaceship: 4,  # <=>
        pipe: 5,       # | (bitwise or)
        amp: 6,        # & (bitwise and)
        plus: 7,       # +
        minus: 7,      # -
        star: 8,       # *
        slash: 8,      # /
        percent: 8,    # %
        star_star: 9,  # ** (right-associative)
      }.freeze

      # Right-associative operators
      RIGHT_ASSOC = Set.new([:star_star]).freeze

      # Token type to operator symbol mapping
      OPERATOR_SYMBOLS = {
        or_or: :"||",
        and_and: :"&&",
        eq_eq: :==,
        bang_eq: :!=,
        lt: :<,
        gt: :>,
        lt_eq: :<=,
        gt_eq: :>=,
        spaceship: :<=>,
        plus: :+,
        minus: :-,
        star: :*,
        slash: :/,
        percent: :%,
        star_star: :**,
        pipe: :|,
        amp: :&,
      }.freeze

      def parse_expression(tokens, position = 0)
        parse_precedence(tokens, position, 0)
      end

      private

      def parse_precedence(tokens, position, min_precedence)
        result = parse_unary(tokens, position)
        return result if result.failure?

        left = result.value
        pos = result.position

        loop do
          break if pos >= tokens.length || tokens[pos].type == :eof

          operator_type = tokens[pos].type
          precedence = PRECEDENCE[operator_type]
          break unless precedence && precedence >= min_precedence

          pos += 1 # consume operator

          # Handle right associativity
          next_min = RIGHT_ASSOC.include?(operator_type) ? precedence : precedence + 1
          right_result = parse_precedence(tokens, pos, next_min)
          return right_result if right_result.failure?

          right = right_result.value
          pos = right_result.position

          left = IR::BinaryOp.new(
            operator: OPERATOR_SYMBOLS[operator_type],
            left: left,
            right: right
          )
        end

        # 삼항 연산자: condition ? then_branch : else_branch
        if pos < tokens.length && tokens[pos].type == :question
          pos += 1 # consume '?'

          then_result = parse_expression(tokens, pos)
          return then_result if then_result.failure?

          pos = then_result.position

          unless tokens[pos]&.type == :colon
            return TokenParseResult.failure("Expected ':' in ternary operator", tokens, pos)
          end

          pos += 1 # consume ':'

          else_result = parse_expression(tokens, pos)
          return else_result if else_result.failure?

          left = IR::Conditional.new(
            kind: :ternary,
            condition: left,
            then_branch: then_result.value,
            else_branch: else_result.value
          )
          pos = else_result.position
        end

        TokenParseResult.success(left, tokens, pos)
      end

      def parse_unary(tokens, position)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        token = tokens[position]

        case token.type
        when :bang
          result = parse_unary(tokens, position + 1)
          return result if result.failure?

          node = IR::UnaryOp.new(operator: :!, operand: result.value)
          TokenParseResult.success(node, tokens, result.position)
        when :minus
          result = parse_unary(tokens, position + 1)
          return result if result.failure?

          # For negative number literals, we could fold them
          node = if result.value.is_a?(IR::Literal) && result.value.literal_type == :integer
                   IR::Literal.new(value: -result.value.value, literal_type: :integer)
                 elsif result.value.is_a?(IR::Literal) && result.value.literal_type == :float
                   IR::Literal.new(value: -result.value.value, literal_type: :float)
                 else
                   IR::UnaryOp.new(operator: :-, operand: result.value)
                 end
          TokenParseResult.success(node, tokens, result.position)
        else
          parse_postfix(tokens, position)
        end
      end

      def parse_postfix(tokens, position)
        result = parse_primary(tokens, position)
        return result if result.failure?

        left = result.value
        pos = result.position

        loop do
          break if pos >= tokens.length || tokens[pos].type == :eof

          case tokens[pos].type
          when :dot
            # Method call with receiver: obj.method or obj.method(args)
            pos += 1
            return TokenParseResult.failure("Expected method name after '.'", tokens, pos) if pos >= tokens.length

            method_token = tokens[pos]
            unless method_token.type == :identifier || keywords.key?(method_token.value)
              return TokenParseResult.failure("Expected method name", tokens, pos)
            end

            method_name = method_token.value
            pos += 1

            # Check for arguments
            args = []
            if pos < tokens.length && tokens[pos].type == :lparen
              args_result = parse_arguments(tokens, pos)
              return args_result if args_result.failure?

              args = args_result.value
              pos = args_result.position
            end

            left = IR::MethodCall.new(
              receiver: left,
              method_name: method_name,
              arguments: args
            )
          when :lbracket
            # Array access: arr[index]
            pos += 1
            index_result = parse_expression(tokens, pos)
            return index_result if index_result.failure?

            pos = index_result.position
            return TokenParseResult.failure("Expected ']'", tokens, pos) unless tokens[pos]&.type == :rbracket

            pos += 1

            left = IR::MethodCall.new(
              receiver: left,
              method_name: "[]",
              arguments: [index_result.value]
            )
          when :lparen
            # Function call without explicit receiver (left is identifier -> method call)
            break unless left.is_a?(IR::VariableRef) && left.scope == :local

            args_result = parse_arguments(tokens, pos)
            return args_result if args_result.failure?

            left = IR::MethodCall.new(
              method_name: left.name,
              arguments: args_result.value
            )
            pos = args_result.position

          else
            break
          end
        end

        TokenParseResult.success(left, tokens, pos)
      end

      def parse_primary(tokens, position)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        token = tokens[position]

        case token.type
        when :integer
          node = IR::Literal.new(value: token.value.to_i, literal_type: :integer)
          TokenParseResult.success(node, tokens, position + 1)

        when :float
          node = IR::Literal.new(value: token.value.to_f, literal_type: :float)
          TokenParseResult.success(node, tokens, position + 1)

        when :string
          # Remove quotes from string value
          value = token.value[1..-2]
          node = IR::Literal.new(value: value, literal_type: :string)
          TokenParseResult.success(node, tokens, position + 1)

        when :string_start
          # Interpolated string: string_start, string_content*, string_end
          parse_interpolated_string(tokens, position)

        when :symbol
          # Remove : from symbol value
          value = token.value[1..].to_sym
          node = IR::Literal.new(value: value, literal_type: :symbol)
          TokenParseResult.success(node, tokens, position + 1)

        when true
          node = IR::Literal.new(value: true, literal_type: :boolean)
          TokenParseResult.success(node, tokens, position + 1)

        when false
          node = IR::Literal.new(value: false, literal_type: :boolean)
          TokenParseResult.success(node, tokens, position + 1)

        when :nil
          node = IR::Literal.new(value: nil, literal_type: :nil)
          TokenParseResult.success(node, tokens, position + 1)

        when :identifier
          node = IR::VariableRef.new(name: token.value, scope: :local)
          TokenParseResult.success(node, tokens, position + 1)

        when :constant
          node = IR::VariableRef.new(name: token.value, scope: :constant)
          TokenParseResult.success(node, tokens, position + 1)

        when :ivar
          node = IR::VariableRef.new(name: token.value, scope: :instance)
          TokenParseResult.success(node, tokens, position + 1)

        when :cvar
          node = IR::VariableRef.new(name: token.value, scope: :class)
          TokenParseResult.success(node, tokens, position + 1)

        when :gvar
          node = IR::VariableRef.new(name: token.value, scope: :global)
          TokenParseResult.success(node, tokens, position + 1)

        when :lparen
          # Parenthesized expression
          result = parse_expression(tokens, position + 1)
          return result if result.failure?

          pos = result.position
          return TokenParseResult.failure("Expected ')'", tokens, pos) unless tokens[pos]&.type == :rparen

          TokenParseResult.success(result.value, tokens, pos + 1)

        when :lbracket
          # Array literal
          parse_array_literal(tokens, position)

        when :lbrace
          # Hash literal
          parse_hash_literal(tokens, position)

        else
          TokenParseResult.failure("Unexpected token: #{token.type}", tokens, position)
        end
      end

      def parse_arguments(tokens, position)
        return TokenParseResult.failure("Expected '('", tokens, position) unless tokens[position]&.type == :lparen

        position += 1

        args = []

        # Empty arguments
        if tokens[position]&.type == :rparen
          return TokenParseResult.success(args, tokens, position + 1)
        end

        # Parse first argument
        result = parse_argument(tokens, position)
        return result if result.failure?

        args << result.value
        position = result.position

        # Parse remaining arguments
        while tokens[position]&.type == :comma
          position += 1
          result = parse_argument(tokens, position)
          return result if result.failure?

          args << result.value
          position = result.position
        end

        return TokenParseResult.failure("Expected ')'", tokens, position) unless tokens[position]&.type == :rparen

        TokenParseResult.success(args, tokens, position + 1)
      end

      # Parse a single argument (handles splat, double splat, and keyword arguments)
      def parse_argument(tokens, position)
        # Double splat argument: **expr
        if tokens[position]&.type == :star_star
          position += 1
          expr_result = parse_expression(tokens, position)
          return expr_result if expr_result.failure?

          # Wrap in a splat node (we'll use MethodCall with special name for now)
          node = IR::MethodCall.new(
            method_name: "**",
            arguments: [expr_result.value]
          )
          return TokenParseResult.success(node, tokens, expr_result.position)
        end

        # Single splat argument: *expr
        if tokens[position]&.type == :star
          position += 1
          expr_result = parse_expression(tokens, position)
          return expr_result if expr_result.failure?

          node = IR::MethodCall.new(
            method_name: "*",
            arguments: [expr_result.value]
          )
          return TokenParseResult.success(node, tokens, expr_result.position)
        end

        # Keyword argument: name: value
        if tokens[position]&.type == :identifier && tokens[position + 1]&.type == :colon
          key_name = tokens[position].value
          position += 2 # skip identifier and colon

          value_result = parse_expression(tokens, position)
          return value_result if value_result.failure?

          # Create a hash pair for keyword argument
          key = IR::Literal.new(value: key_name.to_sym, literal_type: :symbol)
          node = IR::HashPair.new(key: key, value: value_result.value)
          return TokenParseResult.success(node, tokens, value_result.position)
        end

        # Regular expression argument
        parse_expression(tokens, position)
      end

      def parse_array_literal(tokens, position)
        return TokenParseResult.failure("Expected '['", tokens, position) unless tokens[position]&.type == :lbracket

        position += 1

        elements = []

        # Empty array
        if tokens[position]&.type == :rbracket
          node = IR::ArrayLiteral.new(elements: elements)
          return TokenParseResult.success(node, tokens, position + 1)
        end

        # Parse first element
        result = parse_expression(tokens, position)
        return result if result.failure?

        elements << result.value
        position = result.position

        # Parse remaining elements
        while tokens[position]&.type == :comma
          position += 1
          result = parse_expression(tokens, position)
          return result if result.failure?

          elements << result.value
          position = result.position
        end

        return TokenParseResult.failure("Expected ']'", tokens, position) unless tokens[position]&.type == :rbracket

        node = IR::ArrayLiteral.new(elements: elements)
        TokenParseResult.success(node, tokens, position + 1)
      end

      def parse_hash_literal(tokens, position)
        return TokenParseResult.failure("Expected '{'", tokens, position) unless tokens[position]&.type == :lbrace

        position += 1

        pairs = []

        # Empty hash
        if tokens[position]&.type == :rbrace
          node = IR::HashLiteral.new(pairs: pairs)
          return TokenParseResult.success(node, tokens, position + 1)
        end

        # Parse first pair
        pair_result = parse_hash_pair(tokens, position)
        return pair_result if pair_result.failure?

        pairs << pair_result.value
        position = pair_result.position

        # Parse remaining pairs
        while tokens[position]&.type == :comma
          position += 1
          pair_result = parse_hash_pair(tokens, position)
          return pair_result if pair_result.failure?

          pairs << pair_result.value
          position = pair_result.position
        end

        return TokenParseResult.failure("Expected '}'", tokens, position) unless tokens[position]&.type == :rbrace

        node = IR::HashLiteral.new(pairs: pairs)
        TokenParseResult.success(node, tokens, position + 1)
      end

      def parse_hash_pair(tokens, position)
        # Handle symbol key shorthand: key: value
        if tokens[position]&.type == :identifier && tokens[position + 1]&.type == :colon
          key = IR::Literal.new(value: tokens[position].value.to_sym, literal_type: :symbol)
          position += 2 # skip identifier and colon
        else
          # Parse key expression
          key_result = parse_expression(tokens, position)
          return key_result if key_result.failure?

          key = key_result.value
          position = key_result.position

          # Expect => or :
          return TokenParseResult.failure("Expected ':' or '=>' in hash pair", tokens, position) unless tokens[position]&.type == :colon

          position += 1

        end

        # Parse value expression
        value_result = parse_expression(tokens, position)
        return value_result if value_result.failure?

        pair = IR::HashPair.new(key: key, value: value_result.value)
        TokenParseResult.success(pair, tokens, value_result.position)
      end

      def parse_interpolated_string(tokens, position)
        # string_start token contains the opening quote
        position += 1

        parts = []

        while position < tokens.length
          token = tokens[position]

          case token.type
          when :string_content
            parts << IR::Literal.new(value: token.value, literal_type: :string)
            position += 1
          when :interpolation_start
            # Skip #{ and parse expression
            position += 1
            expr_result = parse_expression(tokens, position)
            return expr_result if expr_result.failure?

            parts << expr_result.value
            position = expr_result.position

            # Expect interpolation_end (})
            return TokenParseResult.failure("Expected '}'", tokens, position) unless tokens[position]&.type == :interpolation_end

            position += 1

          when :string_end
            position += 1
            break
          else
            return TokenParseResult.failure("Unexpected token in string: #{token.type}", tokens, position)
          end
        end

        # Create interpolated string node
        node = IR::InterpolatedString.new(parts: parts)
        TokenParseResult.success(node, tokens, position)
      end

      def keywords
        @keywords ||= TRuby::Scanner::KEYWORDS
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/statement_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Statement Parser - Parse statements into IR nodes
    class StatementParser
      include TokenDSL

      def initialize
        @expression_parser = ExpressionParser.new
      end

      def parse_statement(tokens, position = 0)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        # Skip newlines
        position = skip_newlines(tokens, position)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        token = tokens[position]

        case token.type
        when :return
          parse_return(tokens, position)
        when :if
          parse_if(tokens, position)
        when :unless
          parse_unless(tokens, position)
        when :while
          parse_while(tokens, position)
        when :until
          parse_until(tokens, position)
        when :case
          parse_case(tokens, position)
        when :begin
          parse_begin(tokens, position)
        else
          # Could be assignment or expression
          parse_assignment_or_expression(tokens, position)
        end
      end

      def parse_block(tokens, position = 0)
        statements = []

        loop do
          position = skip_newlines(tokens, position)
          break if position >= tokens.length

          token = tokens[position]
          break if token.type == :eof
          break if %i[end else elsif when rescue ensure].include?(token.type)

          result = parse_statement(tokens, position)
          break if result.failure?

          statements << result.value
          position = result.position
        end

        node = IR::Block.new(statements: statements)
        TokenParseResult.success(node, tokens, position)
      end

      private

      def skip_newlines(tokens, position)
        position += 1 while position < tokens.length && %i[newline comment].include?(tokens[position].type)
        position
      end

      def parse_return(tokens, position)
        position += 1 # consume 'return'

        # Check if there's a return value
        position = skip_newlines_if_not_modifier(tokens, position)

        if position >= tokens.length ||
           tokens[position].type == :eof ||
           tokens[position].type == :newline ||
           end_of_statement?(tokens, position)
          node = IR::Return.new(value: nil)
          return TokenParseResult.success(node, tokens, position)
        end

        # Parse return value expression
        expr_result = @expression_parser.parse_expression(tokens, position)
        return expr_result if expr_result.failure?

        # Check for modifier
        modifier_result = parse_modifier(tokens, expr_result.position, IR::Return.new(value: expr_result.value))
        return modifier_result if modifier_result.success? && modifier_result.value.is_a?(IR::Conditional)

        node = IR::Return.new(value: expr_result.value)
        TokenParseResult.success(node, tokens, expr_result.position)
      end

      def parse_if(tokens, position)
        position += 1 # consume 'if'

        # Parse condition
        cond_result = @expression_parser.parse_expression(tokens, position)
        return cond_result if cond_result.failure?

        position = cond_result.position

        # Skip newline after condition
        position = skip_newlines(tokens, position)

        # Parse then branch
        then_result = parse_block(tokens, position)
        position = then_result.position
        position = skip_newlines(tokens, position)

        # Check for elsif or else
        else_branch = nil
        if position < tokens.length && tokens[position].type == :elsif
          elsif_result = parse_if(tokens, position) # Reuse if parsing for elsif
          return elsif_result if elsif_result.failure?

          else_branch = elsif_result.value
          position = elsif_result.position
        elsif position < tokens.length && tokens[position].type == :else
          position += 1 # consume 'else'
          position = skip_newlines(tokens, position)
          else_result = parse_block(tokens, position)
          else_branch = else_result.value
          position = else_result.position
          position = skip_newlines(tokens, position)
        end

        # Expect 'end' (unless it was an elsif chain)
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::Conditional.new(
          kind: :if,
          condition: cond_result.value,
          then_branch: then_result.value,
          else_branch: else_branch
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_unless(tokens, position)
        position += 1 # consume 'unless'

        # Parse condition
        cond_result = @expression_parser.parse_expression(tokens, position)
        return cond_result if cond_result.failure?

        position = cond_result.position

        # Skip newline
        position = skip_newlines(tokens, position)

        # Parse then branch
        then_result = parse_block(tokens, position)
        position = then_result.position
        position = skip_newlines(tokens, position)

        # Check for else
        else_branch = nil
        if position < tokens.length && tokens[position].type == :else
          position += 1
          position = skip_newlines(tokens, position)
          else_result = parse_block(tokens, position)
          else_branch = else_result.value
          position = else_result.position
          position = skip_newlines(tokens, position)
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::Conditional.new(
          kind: :unless,
          condition: cond_result.value,
          then_branch: then_result.value,
          else_branch: else_branch
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_while(tokens, position)
        position += 1 # consume 'while'

        # Parse condition
        cond_result = @expression_parser.parse_expression(tokens, position)
        return cond_result if cond_result.failure?

        position = cond_result.position

        # Skip newline
        position = skip_newlines(tokens, position)

        # Parse body
        body_result = parse_block(tokens, position)
        position = body_result.position
        position = skip_newlines(tokens, position)

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::Loop.new(
          kind: :while,
          condition: cond_result.value,
          body: body_result.value
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_until(tokens, position)
        position += 1 # consume 'until'

        # Parse condition
        cond_result = @expression_parser.parse_expression(tokens, position)
        return cond_result if cond_result.failure?

        position = cond_result.position

        # Skip newline
        position = skip_newlines(tokens, position)

        # Parse body
        body_result = parse_block(tokens, position)
        position = body_result.position
        position = skip_newlines(tokens, position)

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::Loop.new(
          kind: :until,
          condition: cond_result.value,
          body: body_result.value
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_case(tokens, position)
        position += 1 # consume 'case'

        # Parse subject (optional)
        subject = nil
        position = skip_newlines(tokens, position)

        if position < tokens.length && tokens[position].type != :when
          subj_result = @expression_parser.parse_expression(tokens, position)
          if subj_result.success?
            subject = subj_result.value
            position = subj_result.position
          end
        end

        position = skip_newlines(tokens, position)

        # Parse when clauses
        when_clauses = []
        while position < tokens.length && tokens[position].type == :when
          when_result = parse_when_clause(tokens, position)
          return when_result if when_result.failure?

          when_clauses << when_result.value
          position = when_result.position
          position = skip_newlines(tokens, position)
        end

        # Parse else clause
        else_clause = nil
        if position < tokens.length && tokens[position].type == :else
          position += 1
          position = skip_newlines(tokens, position)
          else_result = parse_block(tokens, position)
          else_clause = else_result.value
          position = else_result.position
          position = skip_newlines(tokens, position)
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::CaseExpr.new(
          subject: subject,
          when_clauses: when_clauses,
          else_clause: else_clause
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_when_clause(tokens, position)
        position += 1 # consume 'when'

        # Parse patterns (comma-separated)
        patterns = []
        loop do
          pattern_result = @expression_parser.parse_expression(tokens, position)
          return pattern_result if pattern_result.failure?

          patterns << pattern_result.value
          position = pattern_result.position

          break unless tokens[position]&.type == :comma

          position += 1
        end

        position = skip_newlines(tokens, position)

        # Parse body
        body_result = parse_block(tokens, position)
        position = body_result.position

        node = IR::WhenClause.new(patterns: patterns, body: body_result.value)
        TokenParseResult.success(node, tokens, position)
      end

      def parse_begin(tokens, position)
        position += 1 # consume 'begin'
        position = skip_newlines(tokens, position)

        # Parse body
        body_result = parse_block(tokens, position)
        position = body_result.position
        position = skip_newlines(tokens, position)

        # Parse rescue clauses
        rescue_clauses = []
        while position < tokens.length && tokens[position].type == :rescue
          rescue_result = parse_rescue_clause(tokens, position)
          return rescue_result if rescue_result.failure?

          rescue_clauses << rescue_result.value
          position = rescue_result.position
          position = skip_newlines(tokens, position)
        end

        # Parse else clause (runs if no exception)
        else_clause = nil
        if position < tokens.length && tokens[position].type == :else
          position += 1
          position = skip_newlines(tokens, position)
          else_result = parse_block(tokens, position)
          else_clause = else_result.value
          position = else_result.position
          position = skip_newlines(tokens, position)
        end

        # Parse ensure clause
        ensure_clause = nil
        if position < tokens.length && tokens[position].type == :ensure
          position += 1
          position = skip_newlines(tokens, position)
          ensure_result = parse_block(tokens, position)
          ensure_clause = ensure_result.value
          position = ensure_result.position
          position = skip_newlines(tokens, position)
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::BeginBlock.new(
          body: body_result.value,
          rescue_clauses: rescue_clauses,
          else_clause: else_clause,
          ensure_clause: ensure_clause
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_rescue_clause(tokens, position)
        position += 1 # consume 'rescue'

        exception_types = []
        variable = nil

        # Check for exception types and variable binding
        # Format: rescue ExType, ExType2 => var or rescue => var
        # Parse exception types
        if position < tokens.length && !%i[newline hash_rocket].include?(tokens[position].type) && (tokens[position].type == :constant)
          loop do
            if tokens[position].type == :constant
              exception_types << tokens[position].value
              position += 1
            end
            break unless tokens[position]&.type == :comma

            position += 1
          end
        end

        # Check for => var binding
        if position < tokens.length && tokens[position].type == :hash_rocket
          position += 1
          if tokens[position]&.type == :identifier
            variable = tokens[position].value
            position += 1
          end
        end

        position = skip_newlines(tokens, position)

        # Parse body
        body_result = parse_block(tokens, position)
        position = body_result.position

        node = IR::RescueClause.new(
          exception_types: exception_types,
          variable: variable,
          body: body_result.value
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_assignment_or_expression(tokens, position)
        # Check for typed assignment: name: Type = value
        if tokens[position].type == :identifier &&
           tokens[position + 1]&.type == :colon &&
           tokens[position + 2]&.type == :constant
          return parse_typed_assignment(tokens, position)
        end

        # Check for simple assignment patterns
        if assignable_token?(tokens[position])
          next_pos = position + 1

          # Simple assignment: x = value
          if tokens[next_pos]&.type == :eq
            return parse_simple_assignment(tokens, position)
          end

          # Compound assignment: x += value, x -= value, etc.
          if compound_assignment_token?(tokens[next_pos])
            return parse_compound_assignment(tokens, position)
          end
        end

        # Parse as expression
        expr_result = @expression_parser.parse_expression(tokens, position)
        return expr_result if expr_result.failure?

        # Check for statement modifiers
        parse_modifier(tokens, expr_result.position, expr_result.value)
      end

      def parse_typed_assignment(tokens, position)
        target = tokens[position].value
        position += 2 # skip identifier and colon

        # Parse type annotation (simple constant for now)
        type_annotation = IR::SimpleType.new(name: tokens[position].value)
        position += 1

        # Expect '='
        return TokenParseResult.failure("Expected '='", tokens, position) unless tokens[position]&.type == :eq

        position += 1

        # Parse value
        value_result = @expression_parser.parse_expression(tokens, position)
        return value_result if value_result.failure?

        node = IR::Assignment.new(
          target: target,
          value: value_result.value,
          type_annotation: type_annotation
        )
        TokenParseResult.success(node, tokens, value_result.position)
      end

      def parse_simple_assignment(tokens, position)
        target = tokens[position].value
        position += 2 # skip variable and '='

        # Check for statement expressions (case, if, begin, etc.) as value
        value_result = case tokens[position]&.type
                       when :case
                         parse_case(tokens, position)
                       when :if
                         parse_if(tokens, position)
                       when :unless
                         parse_unless(tokens, position)
                       when :begin
                         parse_begin(tokens, position)
                       else
                         @expression_parser.parse_expression(tokens, position)
                       end
        return value_result if value_result.failure?

        node = IR::Assignment.new(target: target, value: value_result.value)
        TokenParseResult.success(node, tokens, value_result.position)
      end

      def parse_compound_assignment(tokens, position)
        target = tokens[position].value
        op_token = tokens[position + 1]
        position += 2 # skip variable and operator

        # Map compound operator to binary operator
        op_map = {
          plus_eq: :+,
          minus_eq: :-,
          star_eq: :*,
          slash_eq: :/,
          percent_eq: :%,
        }
        binary_op = op_map[op_token.type]

        # Parse right-hand side
        rhs_result = @expression_parser.parse_expression(tokens, position)
        return rhs_result if rhs_result.failure?

        # Create expanded form: x = x + value
        target_ref = IR::VariableRef.new(name: target, scope: infer_scope(target))
        binary_expr = IR::BinaryOp.new(
          operator: binary_op,
          left: target_ref,
          right: rhs_result.value
        )

        node = IR::Assignment.new(target: target, value: binary_expr)

        # Check for statement modifiers
        parse_modifier(tokens, rhs_result.position, node)
      end

      def parse_modifier(tokens, position, statement)
        return TokenParseResult.success(statement, tokens, position) if position >= tokens.length

        token = tokens[position]
        case token.type
        when :if
          position += 1
          cond_result = @expression_parser.parse_expression(tokens, position)
          return cond_result if cond_result.failure?

          then_branch = statement.is_a?(IR::Block) ? statement : IR::Block.new(statements: [statement])
          node = IR::Conditional.new(
            kind: :if,
            condition: cond_result.value,
            then_branch: then_branch
          )
          TokenParseResult.success(node, tokens, cond_result.position)

        when :unless
          position += 1
          cond_result = @expression_parser.parse_expression(tokens, position)
          return cond_result if cond_result.failure?

          then_branch = statement.is_a?(IR::Block) ? statement : IR::Block.new(statements: [statement])
          node = IR::Conditional.new(
            kind: :unless,
            condition: cond_result.value,
            then_branch: then_branch
          )
          TokenParseResult.success(node, tokens, cond_result.position)

        when :while
          position += 1
          cond_result = @expression_parser.parse_expression(tokens, position)
          return cond_result if cond_result.failure?

          body = statement.is_a?(IR::Block) ? statement : IR::Block.new(statements: [statement])
          node = IR::Loop.new(
            kind: :while,
            condition: cond_result.value,
            body: body
          )
          TokenParseResult.success(node, tokens, cond_result.position)

        when :until
          position += 1
          cond_result = @expression_parser.parse_expression(tokens, position)
          return cond_result if cond_result.failure?

          body = statement.is_a?(IR::Block) ? statement : IR::Block.new(statements: [statement])
          node = IR::Loop.new(
            kind: :until,
            condition: cond_result.value,
            body: body
          )
          TokenParseResult.success(node, tokens, cond_result.position)

        else
          TokenParseResult.success(statement, tokens, position)
        end
      end

      def assignable_token?(token)
        return false unless token

        %i[identifier ivar cvar gvar].include?(token.type)
      end

      def compound_assignment_token?(token)
        return false unless token

        %i[plus_eq minus_eq star_eq slash_eq percent_eq].include?(token.type)
      end

      def end_of_statement?(tokens, position)
        return true if position >= tokens.length

        %i[newline eof end else elsif when rescue ensure].include?(tokens[position].type)
      end

      def skip_newlines_if_not_modifier(tokens, position)
        # Don't skip newlines if next token after newline is a modifier
        if tokens[position]&.type == :newline
          next_pos = position + 1
          next_pos += 1 while next_pos < tokens.length && tokens[next_pos].type == :newline
          # If next meaningful token is a modifier, return original position
          if next_pos < tokens.length && %i[if unless while until].include?(tokens[next_pos].type)
            return position
          end
        end
        skip_newlines(tokens, position)
      end

      def infer_scope(name)
        case name[0]
        when "@"
          name[1] == "@" ? :class : :instance
        when "$"
          :global
        else
          :local
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_alternative.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Alternative: try first, if fails try second
    class TokenAlternative < TokenParser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(tokens, position = 0)
        result = @left.parse(tokens, position)
        return result if result.success?

        @right.parse(tokens, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_body_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Token-based body parser - replaces regex-based BodyParser
    # Provides the same interface as BodyParser.parse(lines, start_line, end_line)
    class TokenBodyParser
      def initialize
        @statement_parser = StatementParser.new
      end

      # Parse method body from lines array
      # @param lines [Array<String>] source code lines
      # @param start_line [Integer] starting line index (0-based)
      # @param end_line [Integer] ending line index (exclusive)
      # @return [IR::Block] parsed block of statements
      def parse(lines, start_line, end_line)
        # Extract the body source
        body_lines = lines[start_line...end_line]
        source = body_lines.join("\\n")

        return IR::Block.new(statements: []) if source.strip.empty?

        # Scan and parse
        scanner = TRuby::Scanner.new(source)
        tokens = scanner.scan_all

        result = @statement_parser.parse_block(tokens, 0)

        if result.success?
          result.value
        else
          # Fallback to empty block on parse failure
          IR::Block.new(statements: [])
        end
      end

      # Parse a single expression string
      # @param expr [String] expression to parse
      # @return [IR::Node] parsed expression node
      def parse_expression(expr)
        return nil if expr.nil? || expr.strip.empty?

        scanner = TRuby::Scanner.new(expr)
        tokens = scanner.scan_all

        expression_parser = ExpressionParser.new
        result = expression_parser.parse_expression(tokens, 0)

        result.success? ? result.value : IR::RawCode.new(code: expr)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_declaration_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Token Declaration Parser - Parse top-level declarations
    class TokenDeclarationParser
      include TokenDSL

      # Parse error with location info
      class ParseError
        attr_reader :message, :line, :column, :token

        def initialize(message, token: nil)
          @message = message
          @token = token
          @line = token&.line || 1
          @column = token&.column || 1
        end

        def to_s
          "Line #{@line}, Column #{@column}: #{@message}"
        end
      end

      attr_reader :errors

      def initialize
        @statement_parser = StatementParser.new
        @expression_parser = ExpressionParser.new
        @errors = []
      end

      def parse_declaration(tokens, position = 0)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        position = skip_newlines(tokens, position)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        token = tokens[position]

        case token.type
        when :def
          parse_method_def(tokens, position)
        when :public, :private, :protected
          parse_visibility_method(tokens, position)
        when :class
          parse_class(tokens, position)
        when :module
          parse_module(tokens, position)
        when :type
          parse_type_alias(tokens, position)
        when :interface
          parse_interface(tokens, position)
        else
          TokenParseResult.failure("Expected declaration, got #{token.type}", tokens, position)
        end
      end

      def parse_program(tokens, position = 0)
        declarations = []
        @errors = []

        loop do
          position = skip_newlines(tokens, position)
          break if position >= tokens.length
          break if tokens[position].type == :eof

          token = tokens[position]

          # Check if this looks like a declaration keyword
          unless declaration_keyword?(token.type)
            # Not a declaration - skip to next line (top-level expression is allowed)
            position = skip_to_next_line(tokens, position)
            next
          end

          result = parse_declaration(tokens, position)

          if result.failure?
            # Collect error and try to recover
            # Use result.position for accurate error location (where the error actually occurred)
            error_pos = result.position
            error_token = tokens[error_pos] if error_pos < tokens.length
            @errors << ParseError.new(result.error, token: error_token)

            # Try to skip to next declaration (find next 'def', 'class', etc.)
            position = skip_to_next_declaration(tokens, position)
            next
          end

          declarations << result.value
          position = result.position
        end

        program = IR::Program.new(declarations: declarations)
        TokenParseResult.success(program, tokens, position)
      end

      # Check if parsing encountered any errors
      def has_errors?
        !@errors.empty?
      end

      private

      def skip_newlines(tokens, position)
        position += 1 while position < tokens.length && %i[newline comment].include?(tokens[position].type)
        position
      end

      # Check if token type is a declaration keyword
      def declaration_keyword?(type)
        %i[def class module type interface public private protected].include?(type)
      end

      # Skip to the next line (for top-level expressions)
      def skip_to_next_line(tokens, position)
        while position < tokens.length
          break if tokens[position].type == :newline

          position += 1
        end
        position += 1 if position < tokens.length # skip the newline itself
        position
      end

      # Skip to the next top-level declaration keyword for error recovery
      def skip_to_next_declaration(tokens, position)
        declaration_keywords = %i[def class module type interface public private protected]

        # First, skip the current token
        position += 1

        while position < tokens.length
          token = tokens[position]

          # Found a declaration keyword at start of line (or after newline)
          if declaration_keywords.include?(token.type)
            # Check if this is at start of a logical line
            prev_token = tokens[position - 1] if position.positive?
            if prev_token.nil? || prev_token.type == :newline
              return position
            end
          end

          # Skip to next line if we hit newline
          if token.type == :newline
            position += 1
            # Skip comments and blank lines
            position = skip_newlines(tokens, position)
            next
          end

          position += 1
        end

        position
      end

      def parse_method_def(tokens, position, visibility: :public)
        # Capture def token's location before consuming
        def_token = tokens[position]
        def_line = def_token.line
        def_column = def_token.column

        position += 1 # consume 'def'

        # Parse method name (identifier or operator)
        return TokenParseResult.failure("Expected method name", tokens, position) if position >= tokens.length

        method_name = tokens[position].value
        position += 1

        # Check for unexpected tokens after method name (indicates space in method name)
        if position < tokens.length
          next_token = tokens[position]
          # After method name, only these are valid: ( : newline end
          # If we see an identifier, it means there was a space in the method name
          if next_token.type == :identifier
            return TokenParseResult.failure(
              "Unexpected token '#{next_token.value}' after method name '#{method_name}' - method names cannot contain spaces",
              tokens,
              position
            )
          end
        end

        # Parse parameters
        params = []
        if position < tokens.length && tokens[position].type == :lparen
          position += 1 # consume (

          # Parse parameter list
          unless tokens[position].type == :rparen
            loop do
              param_result = parse_parameter(tokens, position)
              return param_result if param_result.failure?

              # Handle keyword args group which returns an array
              if param_result.value.is_a?(Array)
                params.concat(param_result.value)
              else
                params << param_result.value
              end
              position = param_result.position

              break unless tokens[position]&.type == :comma

              position += 1
            end
          end

          return TokenParseResult.failure("Expected ')'", tokens, position) unless tokens[position]&.type == :rparen

          position += 1
        end

        # Parse return type
        return_type = nil
        if position < tokens.length && tokens[position].type == :colon
          colon_token = tokens[position]

          # Check: no space allowed before colon (method name or ) must be adjacent to :)
          prev_token = tokens[position - 1]
          if prev_token && prev_token.end_pos < colon_token.start_pos
            return TokenParseResult.failure(
              "No space allowed before ':' for return type annotation",
              tokens,
              position
            )
          end

          position += 1

          # Check: space required after colon before type name
          if position < tokens.length
            type_token = tokens[position]
            if colon_token.end_pos == type_token.start_pos
              return TokenParseResult.failure(
                "Space required after ':' before return type",
                tokens,
                position
              )
            end
          end

          type_result = parse_type(tokens, position)
          return type_result if type_result.failure?

          return_type = type_result.value
          position = type_result.position
        elsif position < tokens.length && tokens[position].type == :symbol
          # Handle case where :TypeName was scanned as a symbol (no space after colon)
          # In method definition context, this is a syntax error
          symbol_token = tokens[position]
          type_name = symbol_token.value[1..] # Remove leading ':'

          # Only if it looks like a type name (starts with uppercase)
          if type_name =~ /^[A-Z]/
            # Check: no space allowed before colon
            prev_token = tokens[position - 1]
            if prev_token && prev_token.end_pos < symbol_token.start_pos
              return TokenParseResult.failure(
                "No space allowed before ':' for return type annotation",
                tokens,
                position
              )
            end

            # Error: space required after colon
            return TokenParseResult.failure(
              "Space required after ':' before return type",
              tokens,
              position
            )
          end
        end

        position = skip_newlines(tokens, position)

        # Parse body
        body_result = @statement_parser.parse_block(tokens, position)
        position = body_result.position
        position = skip_newlines(tokens, position)

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::MethodDef.new(
          name: method_name,
          params: params,
          return_type: return_type,
          body: body_result.value,
          visibility: visibility,
          location: "#{def_line}:#{def_column}"
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_visibility_method(tokens, position)
        visibility = tokens[position].type
        position += 1

        if position < tokens.length && tokens[position].type == :def
          parse_method_def(tokens, position, visibility: visibility)
        else
          TokenParseResult.failure("Expected 'def' after visibility modifier", tokens, position)
        end
      end

      def parse_parameter(tokens, position)
        return TokenParseResult.failure("Expected parameter", tokens, position) if position >= tokens.length

        # Check for different parameter types
        case tokens[position].type
        when :lbrace
          # Keyword args group: { name: Type, age: Type = default }
          return parse_keyword_args_group(tokens, position)

        when :star
          # Splat parameter *args
          position += 1
          return TokenParseResult.failure("Expected parameter name after *", tokens, position) if position >= tokens.length

          name = tokens[position].value
          position += 1

          # Check for type annotation: *args: Type
          type_annotation = nil
          if position < tokens.length && tokens[position].type == :colon
            position += 1
            type_result = parse_type(tokens, position)
            return type_result if type_result.failure?

            type_annotation = type_result.value
            position = type_result.position
          end

          param = IR::Parameter.new(name: name, kind: :rest, type_annotation: type_annotation)
          return TokenParseResult.success(param, tokens, position)

        when :star_star
          # Double splat **opts or **opts: Type
          position += 1
          return TokenParseResult.failure("Expected parameter name after **", tokens, position) if position >= tokens.length

          name = tokens[position].value
          position += 1

          # Check for type annotation: **opts: Type
          type_annotation = nil
          if position < tokens.length && tokens[position].type == :colon
            position += 1
            type_result = parse_type(tokens, position)
            return type_result if type_result.failure?

            type_annotation = type_result.value
            position = type_result.position
          end

          param = IR::Parameter.new(name: name, kind: :keyrest, type_annotation: type_annotation)
          return TokenParseResult.success(param, tokens, position)

        when :amp
          # Block parameter &block or &block: Type
          position += 1
          return TokenParseResult.failure("Expected parameter name after &", tokens, position) if position >= tokens.length

          name = tokens[position].value
          position += 1

          # Check for type annotation: &block: Type
          type_annotation = nil
          if position < tokens.length && tokens[position].type == :colon
            position += 1
            type_result = parse_type(tokens, position)
            return type_result if type_result.failure?

            type_annotation = type_result.value
            position = type_result.position
          end

          param = IR::Parameter.new(name: name, kind: :block, type_annotation: type_annotation)
          return TokenParseResult.success(param, tokens, position)
        end

        # Regular parameter: name or name: Type or name: Type = default
        name = tokens[position].value
        position += 1

        type_annotation = nil
        default_value = nil

        if position < tokens.length && tokens[position].type == :colon
          position += 1

          # Check if next token is a type (constant/identifier) or a default value
          if position < tokens.length
            type_result = parse_type(tokens, position)
            return type_result if type_result.failure?

            type_annotation = type_result.value
            position = type_result.position
          end
        end

        # Check for default value: = expression
        if position < tokens.length && tokens[position].type == :eq
          position += 1
          # Skip the default value expression (parse until comma, rparen, or newline)
          position = skip_default_value(tokens, position)
          default_value = true # Just mark that there's a default value
        end

        kind = default_value ? :optional : :required
        param = IR::Parameter.new(name: name, type_annotation: type_annotation, default_value: default_value, kind: kind)
        TokenParseResult.success(param, tokens, position)
      end

      # Parse keyword args group: { name: Type, age: Type = default } or { name:, age: default }: InterfaceName
      def parse_keyword_args_group(tokens, position)
        position += 1 # consume '{'

        params = []
        while position < tokens.length && tokens[position].type != :rbrace
          # Skip newlines inside braces
          position = skip_newlines(tokens, position)
          break if position >= tokens.length || tokens[position].type == :rbrace

          # Parse each keyword arg: name: Type or name: Type = default or name: or name: default
          return TokenParseResult.failure("Expected parameter name", tokens, position) unless tokens[position].type == :identifier

          name = tokens[position].value
          position += 1

          type_annotation = nil
          default_value = nil

          if position < tokens.length && tokens[position].type == :colon
            position += 1

            # Check what follows the colon
            if position < tokens.length
              next_token = tokens[position]

              # If it's a type (constant), parse the type
              if next_token.type == :constant
                type_result = parse_type(tokens, position)
                unless type_result.failure?
                  type_annotation = type_result.value
                  position = type_result.position
                end
              elsif next_token.type != :comma && next_token.type != :rbrace && next_token.type != :newline
                # Ruby-style default value (without =): name: default_value
                # e.g., { name:, limit: 10 }: InterfaceName
                position = skip_default_value_in_braces(tokens, position)
                default_value = true
              end
              # If next_token is comma/rbrace/newline, it's shorthand \`name:\` with no type or default
            end
          end

          # Check for default value: = expression (T-Ruby style with equals sign)
          if position < tokens.length && tokens[position].type == :eq
            position += 1
            position = skip_default_value_in_braces(tokens, position)
            default_value = true
          end

          params << IR::Parameter.new(name: name, type_annotation: type_annotation, default_value: default_value, kind: :keyword)

          # Skip comma
          if position < tokens.length && tokens[position].type == :comma
            position += 1
          end

          position = skip_newlines(tokens, position)
        end

        return TokenParseResult.failure("Expected '}'", tokens, position) unless position < tokens.length && tokens[position].type == :rbrace

        position += 1 # consume '}'

        # Check for interface type annotation: { ... }: InterfaceName
        interface_type = nil
        if position < tokens.length && tokens[position].type == :colon
          position += 1
          type_result = parse_type(tokens, position)
          unless type_result.failure?
            interface_type = type_result.value
            position = type_result.position
          end
        end

        # If there's an interface type, set it as interface_ref for each param
        if interface_type
          params.each { |p| p.interface_ref = interface_type }
        end

        # Return the array of keyword params wrapped in a result
        # We'll handle this specially in parse_method_def
        TokenParseResult.success(params, tokens, position)
      end

      # Skip a default value expression (until comma, rparen, or newline)
      def skip_default_value(tokens, position)
        depth = 0
        while position < tokens.length
          token = tokens[position]
          case token.type
          when :lparen, :lbracket, :lbrace
            depth += 1
          when :rparen
            return position if depth.zero?

            depth -= 1
          when :rbracket, :rbrace
            depth -= 1
          when :comma
            return position if depth.zero?
          when :newline
            return position if depth.zero?
          end
          position += 1
        end
        position
      end

      # Skip a default value expression inside braces (until comma, rbrace, or newline)
      def skip_default_value_in_braces(tokens, position)
        depth = 0
        while position < tokens.length
          token = tokens[position]
          case token.type
          when :lparen, :lbracket
            depth += 1
          when :rparen, :rbracket
            depth -= 1
          when :lbrace
            depth += 1
          when :rbrace
            return position if depth.zero?

            depth -= 1
          when :comma
            return position if depth.zero?
          when :newline
            return position if depth.zero?
          end
          position += 1
        end
        position
      end

      def parse_class(tokens, position)
        position += 1 # consume 'class'

        # Parse class name
        return TokenParseResult.failure("Expected class name", tokens, position) if position >= tokens.length

        class_name = tokens[position].value
        position += 1

        # Check for superclass
        superclass = nil
        if position < tokens.length && tokens[position].type == :lt
          position += 1
          superclass = tokens[position].value
          position += 1
        end

        position = skip_newlines(tokens, position)

        # Parse class body (methods and instance variables)
        body = []
        instance_vars = []

        loop do
          position = skip_newlines(tokens, position)
          break if position >= tokens.length
          break if tokens[position].type == :end

          if tokens[position].type == :ivar && tokens[position + 1]&.type == :colon
            # Instance variable declaration: @name: Type
            ivar_result = parse_instance_var_decl(tokens, position)
            return ivar_result if ivar_result.failure?

            instance_vars << ivar_result.value
            position = ivar_result.position
          elsif %i[def public private protected].include?(tokens[position].type)
            method_result = parse_declaration(tokens, position)
            return method_result if method_result.failure?

            body << method_result.value
            position = method_result.position
          else
            break
          end
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::ClassDecl.new(
          name: class_name,
          superclass: superclass,
          body: body,
          instance_vars: instance_vars
        )
        TokenParseResult.success(node, tokens, position)
      end

      def parse_instance_var_decl(tokens, position)
        # @name: Type
        name = tokens[position].value[1..] # remove @ prefix
        position += 2 # skip @name and :

        type_result = parse_type(tokens, position)
        return type_result if type_result.failure?

        node = IR::InstanceVariable.new(name: name, type_annotation: type_result.value)
        TokenParseResult.success(node, tokens, type_result.position)
      end

      def parse_module(tokens, position)
        position += 1 # consume 'module'

        # Parse module name
        return TokenParseResult.failure("Expected module name", tokens, position) if position >= tokens.length

        module_name = tokens[position].value
        position += 1

        position = skip_newlines(tokens, position)

        # Parse module body
        body = []

        loop do
          position = skip_newlines(tokens, position)
          break if position >= tokens.length
          break if tokens[position].type == :end

          break unless %i[def public private protected].include?(tokens[position].type)

          method_result = parse_declaration(tokens, position)
          return method_result if method_result.failure?

          body << method_result.value
          position = method_result.position
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::ModuleDecl.new(name: module_name, body: body)
        TokenParseResult.success(node, tokens, position)
      end

      def parse_type_alias(tokens, position)
        position += 1 # consume 'type'

        # Parse type name
        return TokenParseResult.failure("Expected type name", tokens, position) if position >= tokens.length

        type_name = tokens[position].value
        position += 1

        # Expect '='
        return TokenParseResult.failure("Expected '='", tokens, position) unless tokens[position]&.type == :eq

        position += 1

        # Parse type definition
        type_result = parse_type(tokens, position)
        return type_result if type_result.failure?

        node = IR::TypeAlias.new(name: type_name, definition: type_result.value)
        TokenParseResult.success(node, tokens, type_result.position)
      end

      def parse_interface(tokens, position)
        position += 1 # consume 'interface'

        # Parse interface name
        return TokenParseResult.failure("Expected interface name", tokens, position) if position >= tokens.length

        interface_name = tokens[position].value
        position += 1

        position = skip_newlines(tokens, position)

        # Parse interface members
        members = []

        loop do
          position = skip_newlines(tokens, position)
          break if position >= tokens.length
          break if tokens[position].type == :end

          member_result = parse_interface_member(tokens, position)
          break if member_result.failure?

          members << member_result.value
          position = member_result.position
        end

        # Expect 'end'
        if position < tokens.length && tokens[position].type == :end
          position += 1
        end

        node = IR::Interface.new(name: interface_name, members: members)
        TokenParseResult.success(node, tokens, position)
      end

      def parse_interface_member(tokens, position)
        # name: Type
        return TokenParseResult.failure("Expected member name", tokens, position) if position >= tokens.length

        name = tokens[position].value
        position += 1

        return TokenParseResult.failure("Expected ':'", tokens, position) unless tokens[position]&.type == :colon

        position += 1

        type_result = parse_type(tokens, position)
        return type_result if type_result.failure?

        node = IR::InterfaceMember.new(name: name, type_signature: type_result.value)
        TokenParseResult.success(node, tokens, type_result.position)
      end

      def parse_type(tokens, position)
        return TokenParseResult.failure("Expected type", tokens, position) if position >= tokens.length

        # Parse primary type
        result = parse_primary_type(tokens, position)
        return result if result.failure?

        type = result.value
        position = result.position

        # Check for union type
        types = [type]
        while position < tokens.length && tokens[position].type == :pipe
          position += 1
          next_result = parse_primary_type(tokens, position)
          return next_result if next_result.failure?

          types << next_result.value
          position = next_result.position
        end

        if types.length > 1
          node = IR::UnionType.new(types: types)
          TokenParseResult.success(node, tokens, position)
        else
          TokenParseResult.success(type, tokens, position)
        end
      end

      def parse_primary_type(tokens, position)
        return TokenParseResult.failure("Expected type", tokens, position) if position >= tokens.length

        # Check for function type: -> ReturnType
        if tokens[position].type == :arrow
          position += 1
          return_result = parse_primary_type(tokens, position)
          return return_result if return_result.failure?

          node = IR::FunctionType.new(param_types: [], return_type: return_result.value)
          return TokenParseResult.success(node, tokens, return_result.position)
        end

        # Check for tuple type: (Type, Type) -> ReturnType
        # or parenthesized type: (String | Integer)[]
        if tokens[position].type == :lparen
          position += 1
          param_types = []

          unless tokens[position].type == :rparen
            loop do
              type_result = parse_type(tokens, position)
              return type_result if type_result.failure?

              param_types << type_result.value
              position = type_result.position

              break unless tokens[position]&.type == :comma

              position += 1
            end
          end

          return TokenParseResult.failure("Expected ')'", tokens, position) unless tokens[position]&.type == :rparen

          position += 1

          # Check for function arrow
          if position < tokens.length && tokens[position].type == :arrow
            position += 1
            return_result = parse_primary_type(tokens, position)
            return return_result if return_result.failure?

            node = IR::FunctionType.new(param_types: param_types, return_type: return_result.value)
            return TokenParseResult.success(node, tokens, return_result.position)
          elsif param_types.length == 1
            # Single type in parentheses: (String | Integer)
            # Check for postfix operators like [] or ?
            type = param_types[0]
            return parse_postfix_type_operators(tokens, position, type)
          else
            node = IR::TupleType.new(element_types: param_types)
            return TokenParseResult.success(node, tokens, position)
          end
        end

        # Check for hash literal type: { key: Type, key2: Type }
        if tokens[position].type == :lbrace
          return parse_hash_literal_type(tokens, position)
        end

        # Simple type or generic type
        type_name = tokens[position].value
        position += 1

        # Handle type names ending with ? (e.g., "String?" scanned as single token)
        # This happens because Ruby allows ? in method/identifier names
        is_nullable_from_name = type_name.end_with?("?")
        if is_nullable_from_name
          type_name = type_name.chomp("?")
        end

        # Check for generic arguments: Type<Args>
        if position < tokens.length && tokens[position].type == :lt
          position += 1
          type_args = []

          loop do
            arg_result = parse_type(tokens, position)
            return arg_result if arg_result.failure?

            type_args << arg_result.value
            position = arg_result.position

            break unless tokens[position]&.type == :comma

            position += 1
          end

          return TokenParseResult.failure("Expected '>'", tokens, position) unless tokens[position]&.type == :gt

          position += 1

          node = IR::GenericType.new(base: type_name, type_args: type_args)
          # Wrap in NullableType if the original type name ended with ?
          node = IR::NullableType.new(inner_type: node) if is_nullable_from_name
          # Apply postfix operators ([] or ?) to generic types too
          parse_postfix_type_operators(tokens, position, node)
        else
          # Simple type - apply postfix operators
          node = IR::SimpleType.new(name: type_name)
          # Wrap in NullableType if the original type name ended with ?
          node = IR::NullableType.new(inner_type: node) if is_nullable_from_name
          parse_postfix_type_operators(tokens, position, node)
        end
      end

      # Parse postfix type operators: [] (array shorthand) and ? (nullable)
      # Handles patterns like:
      #   String[]     => Array<String>
      #   Integer[][]  => Array<Array<Integer>>
      #   String[]?    => NullableType(Array<String>)
      #   String?[]    => Array<NullableType(String)>
      #   (A | B)[]    => Array<UnionType(A, B)>
      def parse_postfix_type_operators(tokens, position, type)
        loop do
          break if position >= tokens.length

          case tokens[position].type
          when :lbracket
            # Check for [] (empty brackets for array shorthand)
            break unless tokens[position + 1]&.type == :rbracket

            position += 2
            type = IR::GenericType.new(base: "Array", type_args: [type])
          when :question
            position += 1
            type = IR::NullableType.new(inner_type: type)
          else
            break
          end
        end

        TokenParseResult.success(type, tokens, position)
      end

      # Parse hash literal type: { key: Type, key2: Type }
      # Used for typed hash parameters like: def foo(config: { host: String, port: Integer })
      def parse_hash_literal_type(tokens, position)
        return TokenParseResult.failure("Expected '{'", tokens, position) unless tokens[position]&.type == :lbrace

        position += 1 # consume '{'

        fields = []
        while position < tokens.length && tokens[position].type != :rbrace
          # Skip newlines inside braces
          position = skip_newlines(tokens, position)
          break if position >= tokens.length || tokens[position].type == :rbrace

          # Parse field: name: Type
          unless tokens[position].type == :identifier
            return TokenParseResult.failure("Expected field name", tokens, position)
          end

          field_name = tokens[position].value
          position += 1

          unless tokens[position]&.type == :colon
            return TokenParseResult.failure("Expected ':' after field name", tokens, position)
          end

          position += 1

          type_result = parse_type(tokens, position)
          return type_result if type_result.failure?

          fields << { name: field_name, type: type_result.value }
          position = type_result.position

          # Handle optional default value (skip it for type purposes)
          if position < tokens.length && tokens[position].type == :eq
            position += 1
            position = skip_default_value_in_braces(tokens, position)
          end

          # Skip comma if present
          if position < tokens.length && tokens[position].type == :comma
            position += 1
          end
        end

        unless tokens[position]&.type == :rbrace
          return TokenParseResult.failure("Expected '}'", tokens, position)
        end

        position += 1 # consume '}'

        node = IR::HashLiteralType.new(fields: fields)
        TokenParseResult.success(node, tokens, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_dsl.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Token DSL Module - Convenience methods for token parsing
    module TokenDSL
      def token(type)
        TokenMatcher.new(type)
      end

      def keyword(kw)
        TokenMatcher.new(kw)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_label.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Label for error messages
    class TokenLabel < TokenParser
      def initialize(parser, name)
        @parser = parser
        @name = name
      end

      def parse(tokens, position = 0)
        result = @parser.parse(tokens, position)
        if result.failure?
          TokenParseResult.failure("Expected #{@name}", tokens, position)
        else
          result
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_many.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Many: zero or more
    class TokenMany < TokenParser
      def initialize(parser)
        @parser = parser
      end

      def parse(tokens, position = 0)
        results = []
        current_pos = position

        loop do
          result = @parser.parse(tokens, current_pos)
          break if result.failure?

          results << result.value
          break if result.position == current_pos # Prevent infinite loop

          current_pos = result.position
        end

        TokenParseResult.success(results, tokens, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_many1.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Many1: one or more
    class TokenMany1 < TokenParser
      def initialize(parser)
        @parser = parser
      end

      def parse(tokens, position = 0)
        first = @parser.parse(tokens, position)
        return first if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          result = @parser.parse(tokens, current_pos)
          break if result.failure?

          results << result.value
          break if result.position == current_pos

          current_pos = result.position
        end

        TokenParseResult.success(results, tokens, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_map.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Map result
    class TokenMap < TokenParser
      def initialize(parser, func)
        @parser = parser
        @func = func
      end

      def parse(tokens, position = 0)
        @parser.parse(tokens, position).map(&@func)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_matcher.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Match a specific token type
    class TokenMatcher < TokenParser
      def initialize(token_type)
        @token_type = token_type
      end

      def parse(tokens, position = 0)
        return TokenParseResult.failure("End of input", tokens, position) if position >= tokens.length

        token = tokens[position]
        return TokenParseResult.failure("End of input", tokens, position) if token.type == :eof

        if token.type == @token_type
          TokenParseResult.success(token, tokens, position + 1)
        else
          TokenParseResult.failure(
            "Expected :#{@token_type}, got :#{token.type} (#{token.value.inspect})",
            tokens,
            position
          )
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_optional.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Optional: zero or one
    class TokenOptional < TokenParser
      def initialize(parser)
        @parser = parser
      end

      def parse(tokens, position = 0)
        result = @parser.parse(tokens, position)
        if result.success?
          result
        else
          TokenParseResult.success(nil, tokens, position)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_parse_result.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Token-based parse result
    class TokenParseResult
      attr_reader :value, :tokens, :position, :error

      def initialize(success:, value: nil, tokens: [], position: 0, error: nil)
        @success = success
        @value = value
        @tokens = tokens
        @position = position
        @error = error
      end

      def success?
        @success
      end

      def failure?
        !@success
      end

      def self.success(value, tokens, position)
        new(success: true, value: value, tokens: tokens, position: position)
      end

      def self.failure(error, tokens, position)
        new(success: false, error: error, tokens: tokens, position: position)
      end

      def map
        return self if failure?

        TokenParseResult.success(yield(value), tokens, position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Base class for token parsers
    class TokenParser
      def parse(tokens, position = 0)
        raise NotImplementedError
      end

      # Sequence: run this parser, then the other
      def >>(other)
        TokenSequence.new(self, other)
      end

      # Alternative: try this parser, if it fails try the other
      def |(other)
        TokenAlternative.new(self, other)
      end

      # Map: transform the result
      def map(&block)
        TokenMap.new(self, block)
      end

      # Many: zero or more repetitions
      def many
        TokenMany.new(self)
      end

      # Many1: one or more repetitions
      def many1
        TokenMany1.new(self)
      end

      # Optional: zero or one
      def optional
        TokenOptional.new(self)
      end

      # Separated by: parse items separated by delimiter
      def sep_by(delimiter)
        TokenSepBy.new(self, delimiter)
      end

      # Separated by 1: at least one item
      def sep_by1(delimiter)
        TokenSepBy1.new(self, delimiter)
      end

      # Skip right: parse both, keep left result
      def <<(other)
        TokenSkipRight.new(self, other)
      end

      # Label: add a descriptive label for error messages
      def label(name)
        TokenLabel.new(self, name)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_sep_by.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Separated by delimiter
    class TokenSepBy < TokenParser
      def initialize(parser, delimiter)
        @parser = parser
        @delimiter = delimiter
      end

      def parse(tokens, position = 0)
        first = @parser.parse(tokens, position)
        return TokenParseResult.success([], tokens, position) if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          delim_result = @delimiter.parse(tokens, current_pos)
          break if delim_result.failure?

          item_result = @parser.parse(tokens, delim_result.position)
          break if item_result.failure?

          results << item_result.value
          current_pos = item_result.position
        end

        TokenParseResult.success(results, tokens, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_sep_by1.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Separated by 1 (at least one)
    class TokenSepBy1 < TokenParser
      def initialize(parser, delimiter)
        @parser = parser
        @delimiter = delimiter
      end

      def parse(tokens, position = 0)
        first = @parser.parse(tokens, position)
        return first if first.failure?

        results = [first.value]
        current_pos = first.position

        loop do
          delim_result = @delimiter.parse(tokens, current_pos)
          break if delim_result.failure?

          item_result = @parser.parse(tokens, delim_result.position)
          break if item_result.failure?

          results << item_result.value
          current_pos = item_result.position
        end

        TokenParseResult.success(results, tokens, current_pos)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_sequence.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Sequence two token parsers
    class TokenSequence < TokenParser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(tokens, position = 0)
        result1 = @left.parse(tokens, position)
        return result1 if result1.failure?

        result2 = @right.parse(tokens, result1.position)
        return result2 if result2.failure?

        TokenParseResult.success([result1.value, result2.value], tokens, result2.position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/token/token_skip_right.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Skip right: parse both, return left
    class TokenSkipRight < TokenParser
      def initialize(left, right)
        @left = left
        @right = right
      end

      def parse(tokens, position = 0)
        result1 = @left.parse(tokens, position)
        return result1 if result1.failure?

        result2 = @right.parse(tokens, result1.position)
        return result2 if result2.failure?

        TokenParseResult.success(result1.value, tokens, result2.position)
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator/type_parser.rb": `# frozen_string_literal: true

module TRuby
  module ParserCombinator
    # Type Parser - Parse T-Ruby type expressions
    class TypeParser
      include DSL

      def initialize
        build_parsers
      end

      def parse(input)
        result = @type_expr.parse(input.strip)
        if result.success?
          { success: true, type: result.value, remaining: input[result.position..] }
        else
          { success: false, error: result.error, position: result.position }
        end
      end

      private

      def build_parsers
        # Identifier (type name)
        type_name = identifier.label("type name")

        # Simple type
        type_name.map { |name| IR::SimpleType.new(name: name) }

        # Lazy reference for recursive types
        type_expr = lazy { @type_expr }

        # Generic type arguments: <Type, Type, ...>
        generic_args = (
          lexeme(char("<")) >>
          type_expr.sep_by1(lexeme(char(","))) <<
          lexeme(char(">"))
        ).map { |(_, types)| types }

        # Generic type: Base<Args>
        generic_type = (type_name >> generic_args.optional).map do |(name, args)|
          if args && !args.empty?
            IR::GenericType.new(base: name, type_args: args)
          else
            IR::SimpleType.new(name: name)
          end
        end

        # Nullable type: Type?
        nullable_suffix = char("?")

        # Parenthesized type
        paren_type = (lexeme(char("(")) >> type_expr << lexeme(char(")"))).map { |(_, t)| t }

        # Function type: (Params) -> ReturnType
        param_list = (
          lexeme(char("(")) >>
          type_expr.sep_by(lexeme(char(","))) <<
          lexeme(char(")"))
        ).map { |(_, params)| params }

        arrow = lexeme(string("->"))

        function_type = (param_list >> arrow >> type_expr).map do |((params, _arrow), ret)|
          IR::FunctionType.new(param_types: params, return_type: ret)
        end

        # Tuple type: [Type, Type, ...]
        tuple_type = (
          lexeme(char("[")) >>
          type_expr.sep_by1(lexeme(char(","))) <<
          lexeme(char("]"))
        ).map { |(_, types)| IR::TupleType.new(element_types: types) }

        # Primary type (before operators)
        primary_type = choice(
          function_type,
          tuple_type,
          paren_type,
          generic_type
        )

        # Array shorthand suffix: [] (can be repeated for nested arrays)
        array_suffix = string("[]")

        # Postfix operators: ([] | ?)*
        # Handles: String[], Integer[][], String[]?, String?[], etc.
        postfix_op = array_suffix | nullable_suffix

        base_type = (primary_type >> postfix_op.many).map do |(initial_type, ops)|
          ops.reduce(initial_type) do |type, op|
            case op
            when "[]"
              IR::GenericType.new(base: "Array", type_args: [type])
            when "?"
              IR::NullableType.new(inner_type: type)
            else
              type
            end
          end
        end

        # Union type: Type | Type | ...
        union_op = lexeme(char("|"))
        union_type = base_type.sep_by1(union_op).map do |types|
          types.length == 1 ? types.first : IR::UnionType.new(types: types)
        end

        # Intersection type: Type & Type & ...
        intersection_op = lexeme(char("&"))
        @type_expr = union_type.sep_by1(intersection_op).map do |types|
          types.length == 1 ? types.first : IR::IntersectionType.new(types: types)
        end
      end
    end
  end
end
`,
  "lib/t_ruby/parser_combinator.rb": `# frozen_string_literal: true

# Parser Combinator module for T-Ruby
# Provides both string-based and token-based parsing capabilities

module TRuby
  module ParserCombinator
    # Base classes
    require_relative "parser_combinator/parse_result"
    require_relative "parser_combinator/parser"

    # Primitive parsers
    require_relative "parser_combinator/primitives/literal"
    require_relative "parser_combinator/primitives/satisfy"
    require_relative "parser_combinator/primitives/regex"
    require_relative "parser_combinator/primitives/end_of_input"
    require_relative "parser_combinator/primitives/pure"
    require_relative "parser_combinator/primitives/fail"
    require_relative "parser_combinator/primitives/lazy"

    # Combinator parsers
    require_relative "parser_combinator/combinators/sequence"
    require_relative "parser_combinator/combinators/alternative"
    require_relative "parser_combinator/combinators/map"
    require_relative "parser_combinator/combinators/flat_map"
    require_relative "parser_combinator/combinators/many"
    require_relative "parser_combinator/combinators/many1"
    require_relative "parser_combinator/combinators/optional"
    require_relative "parser_combinator/combinators/sep_by"
    require_relative "parser_combinator/combinators/sep_by1"
    require_relative "parser_combinator/combinators/skip_right"
    require_relative "parser_combinator/combinators/label"
    require_relative "parser_combinator/combinators/lookahead"
    require_relative "parser_combinator/combinators/not_followed_by"
    require_relative "parser_combinator/combinators/choice"
    require_relative "parser_combinator/combinators/chain_left"

    # DSL module
    require_relative "parser_combinator/dsl"

    # Token-based parsers
    require_relative "parser_combinator/token/token_parse_result"
    require_relative "parser_combinator/token/token_parser"
    require_relative "parser_combinator/token/token_matcher"
    require_relative "parser_combinator/token/token_sequence"
    require_relative "parser_combinator/token/token_alternative"
    require_relative "parser_combinator/token/token_map"
    require_relative "parser_combinator/token/token_many"
    require_relative "parser_combinator/token/token_many1"
    require_relative "parser_combinator/token/token_optional"
    require_relative "parser_combinator/token/token_sep_by"
    require_relative "parser_combinator/token/token_sep_by1"
    require_relative "parser_combinator/token/token_skip_right"
    require_relative "parser_combinator/token/token_label"
    require_relative "parser_combinator/token/token_dsl"

    # High-level parsers
    require_relative "parser_combinator/token/expression_parser"
    require_relative "parser_combinator/token/statement_parser"
    require_relative "parser_combinator/token/token_declaration_parser"
    require_relative "parser_combinator/token/token_body_parser"

    # Type and declaration parsers (string-based)
    require_relative "parser_combinator/type_parser"
    require_relative "parser_combinator/declaration_parser"

    # Error reporting
    require_relative "parser_combinator/parse_error"
  end
end
`,
  "lib/t_ruby/ruby_version.rb": `# frozen_string_literal: true

module TRuby
  # Error raised when an unsupported Ruby version is detected
  class UnsupportedRubyVersionError < StandardError; end

  # Value object representing a Ruby version with comparison and feature detection
  #
  # @example
  #   version = RubyVersion.parse("3.4")
  #   version.supports_it_parameter? # => true
  #   version >= RubyVersion.parse("3.0") # => true
  #
  class RubyVersion
    include Comparable

    # Supported version range
    MIN_VERSION = [3, 0].freeze
    MAX_MAJOR = 4

    # Version string pattern: major.minor or major.minor.patch
    VERSION_REGEX = /\\A(\\d+)\\.(\\d+)(?:\\.(\\d+))?\\z/

    attr_reader :major, :minor, :patch

    # @param major [Integer] major version number
    # @param minor [Integer] minor version number
    # @param patch [Integer] patch version number (default: 0)
    def initialize(major, minor, patch = 0)
      @major = major
      @minor = minor
      @patch = patch
    end

    # Parse a version string into a RubyVersion object
    #
    # @param version_string [String, Numeric] version string (e.g., "3.4", "3.4.1")
    # @return [RubyVersion] parsed version object
    # @raise [ArgumentError] if version format is invalid
    def self.parse(version_string)
      str = version_string.to_s
      match = VERSION_REGEX.match(str)

      raise ArgumentError, "Invalid version: #{version_string}" unless match

      new(match[1].to_i, match[2].to_i, (match[3] || 0).to_i)
    end

    # Get the current Ruby version from the environment
    #
    # @return [RubyVersion] current Ruby version
    def self.current
      parse(RUBY_VERSION)
    end

    # Compare two versions
    #
    # @param other [RubyVersion] version to compare with
    # @return [Integer] -1, 0, or 1
    def <=>(other)
      [major, minor, patch] <=> [other.major, other.minor, other.patch]
    end

    # Convert to string representation
    #
    # @return [String] version string (e.g., "3.4" or "3.4.1")
    def to_s
      patch.zero? ? "#{major}.#{minor}" : "#{major}.#{minor}.#{patch}"
    end

    # Check if this version is within the supported range (3.0 ~ 4.x)
    #
    # @return [Boolean] true if version is supported
    def supported?
      self >= self.class.parse("#{MIN_VERSION[0]}.#{MIN_VERSION[1]}") && major <= MAX_MAJOR
    end

    # Validate that this version is supported, raising an error if not
    #
    # @return [RubyVersion] self if valid
    # @raise [UnsupportedRubyVersionError] if version is not supported
    def validate!
      unless supported?
        raise UnsupportedRubyVersionError,
              "Ruby #{self}는 지원되지 않습니다. 지원 범위: #{MIN_VERSION.join(".")} ~ #{MAX_MAJOR}.x"
      end

      self
    end

    # Check if this version supports the \`it\` implicit block parameter (Ruby 3.4+)
    #
    # @return [Boolean] true if \`it\` parameter is supported
    def supports_it_parameter?
      self >= self.class.parse("3.4")
    end

    # Check if this version supports anonymous block forwarding \`def foo(&) ... end\` (Ruby 3.1+)
    #
    # @return [Boolean] true if anonymous block forwarding is supported
    def supports_anonymous_block_forwarding?
      self >= self.class.parse("3.1")
    end

    # Check if numbered parameters (_1, _2, etc.) raise NameError (Ruby 4.0+)
    #
    # @return [Boolean] true if numbered parameters cause errors
    def numbered_parameters_raise_error?
      self >= self.class.parse("4.0")
    end
  end
end
`,
  "lib/t_ruby/runner.rb": `# frozen_string_literal: true

require "thor"

module TRuby
  # Thor-based CLI for t-ruby command
  # Runs .trb files directly without generating intermediate files
  class RunnerCLI < Thor
    def self.exit_on_failure?
      true
    end

    # Override Thor's default behavior to treat unknown arguments as the file to run
    def self.start(given_args = ARGV, _config = {})
      # Handle version flag
      if given_args.include?("--version") || given_args.include?("-v")
        new.version
        return
      end

      # Handle help flag or no arguments
      if given_args.empty? || given_args.include?("--help") || given_args.include?("-h")
        new.help
        return
      end

      # Treat first argument as file, rest as script arguments
      file = given_args.first
      args = given_args[1..] || []

      runner = Runner.new
      runner.run_file(file, args)
    end

    desc "FILE [ARGS...]", "Run a .trb file directly without generating files"
    def run_file(file, *args)
      runner = Runner.new
      runner.run_file(file, args)
    end

    map %w[--version -v] => :version
    desc "--version, -v", "Show version"
    def version
      puts "t-ruby #{VERSION}"
    end

    desc "--help, -h", "Show help"
    def help
      puts <<~HELP
        t-ruby v#{VERSION} - Run T-Ruby files directly

        Usage:
          t-ruby <file.trb>              Run a .trb file directly
          t-ruby <file.trb> [args...]    Run with arguments passed to the script
          t-ruby --version, -v           Show version
          t-ruby --help, -h              Show this help

        Examples:
          t-ruby hello.trb               Run hello.trb
          t-ruby server.trb 8080         Run with argument 8080
          t-ruby script.trb foo bar      Run with multiple arguments

        Notes:
          - No .rb or .rbs files are generated
          - Type annotations are stripped at runtime
          - Arguments after the file are passed to ARGV
      HELP
    end
  end

  # Runner class - executes T-Ruby code directly
  # Can be used as a library or through RunnerCLI
  class Runner
    def initialize(config = nil)
      @config = config || Config.new
      @compiler = Compiler.new(@config)
    end

    # Run a .trb file directly
    # @param input_path [String] Path to the .trb file
    # @param argv [Array<String>] Arguments to pass to the script via ARGV
    def run_file(input_path, argv = [])
      unless File.exist?(input_path)
        warn "Error: File not found: #{input_path}"
        exit 1
      end

      source = File.read(input_path)
      result = @compiler.compile_string(source)

      if result[:errors].any?
        result[:errors].each { |e| warn e }
        exit 1
      end

      execute_ruby(result[:ruby], input_path, argv)
    end

    # Run T-Ruby source code from a string
    # @param source [String] T-Ruby source code
    # @param filename [String] Filename for error reporting
    # @param argv [Array<String>] Arguments to pass via ARGV
    # @return [Boolean] true if execution succeeded
    def run_string(source, filename: "(t-ruby)", argv: [])
      result = @compiler.compile_string(source)

      if result[:errors].any?
        result[:errors].each { |e| warn e }
        return false
      end

      execute_ruby(result[:ruby], filename, argv)
      true
    end

    private

    # Execute Ruby code with proper script environment
    # @param ruby_code [String] Ruby code to execute
    # @param filename [String] Script filename (for $0 and stack traces)
    # @param argv [Array<String>] Script arguments
    def execute_ruby(ruby_code, filename, argv)
      # Set up script environment
      ARGV.replace(argv)
      $0 = filename

      # Execute using eval with filename and line number preserved
      # This ensures stack traces point to the original .trb file
      TOPLEVEL_BINDING.eval(ruby_code, filename, 1)
    end
  end
end
`,
  "lib/t_ruby/runtime_validator.rb": `# frozen_string_literal: true

module TRuby
  # Configuration for runtime validation
  class ValidationConfig
    attr_accessor :validate_all, :validate_public_only, :raise_on_error, :log_violations, :strict_mode

    def initialize
      @validate_all = true
      @validate_public_only = false
      @raise_on_error = true
      @log_violations = false
      @strict_mode = false
    end
  end

  # Generates runtime type validation code
  class RuntimeValidator
    attr_reader :config

    # Type mappings for runtime checks
    TYPE_CHECKS = {
      "String" => ".is_a?(String)",
      "Integer" => ".is_a?(Integer)",
      "Float" => ".is_a?(Float)",
      "Numeric" => ".is_a?(Numeric)",
      "Boolean" => " == true || %s == false",
      "Symbol" => ".is_a?(Symbol)",
      "Array" => ".is_a?(Array)",
      "Hash" => ".is_a?(Hash)",
      "nil" => ".nil?",
      "Object" => ".is_a?(Object)",
      "Class" => ".is_a?(Class)",
      "Module" => ".is_a?(Module)",
      "Proc" => ".is_a?(Proc)",
      "Regexp" => ".is_a?(Regexp)",
      "Range" => ".is_a?(Range)",
      "Time" => ".is_a?(Time)",
      "Date" => ".is_a?(Date)",
      "IO" => ".is_a?(IO)",
      "File" => ".is_a?(File)",
    }.freeze

    def initialize(config = nil)
      @config = config || ValidationConfig.new
    end

    # Generate validation code for a function
    def generate_function_validation(function_info)
      validations = []

      # Parameter validations
      function_info[:params].each do |param|
        next unless param[:type]

        validation = generate_param_validation(param[:name], param[:type])
        validations << validation if validation
      end

      # Return type validation (if specified)
      if function_info[:return_type]
        return_validation = generate_return_validation(function_info[:return_type])
        validations << return_validation if return_validation
      end

      validations
    end

    # Generate validation for a single parameter
    def generate_param_validation(param_name, type_annotation)
      check_code = generate_type_check(param_name, type_annotation)
      return nil unless check_code

      error_message = "TypeError: #{param_name} must be #{type_annotation}, got \\#{#{param_name}.class}"

      if @config.raise_on_error
        "raise #{error_message.inspect.gsub('\\#{', '#{')} unless #{check_code}"
      else
        "warn #{error_message.inspect.gsub('\\#{', '#{')} unless #{check_code}"
      end
    end

    # Generate type check expression
    def generate_type_check(var_name, type_annotation)
      # Handle nil type
      return "#{var_name}.nil?" if type_annotation == "nil"

      # Handle union types
      if type_annotation.include?("|")
        return generate_union_check(var_name, type_annotation)
      end

      # Handle generic types
      if type_annotation.include?("<")
        return generate_generic_check(var_name, type_annotation)
      end

      # Handle intersection types
      if type_annotation.include?("&")
        return generate_intersection_check(var_name, type_annotation)
      end

      # Handle optional types (ending with ?)
      if type_annotation.end_with?("?")
        base_type = type_annotation[0..-2]
        base_check = generate_simple_type_check(var_name, base_type)
        return "(#{var_name}.nil? || #{base_check})"
      end

      # Simple type check
      generate_simple_type_check(var_name, type_annotation)
    end

    # Generate simple type check
    def generate_simple_type_check(var_name, type_name)
      if type_name == "Boolean"
        "(#{var_name} == true || #{var_name} == false)"
      elsif TYPE_CHECKS.key?(type_name)
        "#{var_name}#{TYPE_CHECKS[type_name]}"
      else
        # Custom type - use is_a? or respond_to?
        "#{var_name}.is_a?(#{type_name})"
      end
    end

    # Generate union type check
    def generate_union_check(var_name, union_type)
      types = union_type.split("|").map(&:strip)
      checks = types.map { |t| generate_type_check(var_name, t) }
      "(#{checks.join(" || ")})"
    end

    # Generate generic type check
    def generate_generic_check(var_name, generic_type)
      match = generic_type.match(/^(\\w+)<(.+)>$/)
      return nil unless match

      container_type = match[1]
      element_type = match[2]

      case container_type
      when "Array"
        "#{var_name}.is_a?(Array) && #{var_name}.all? { |_e| #{generate_type_check("_e", element_type)} }"
      when "Hash"
        if element_type.include?(",")
          key_type, value_type = element_type.split(",").map(&:strip)
          "#{var_name}.is_a?(Hash) && #{var_name}.all? { |_k, _v| #{generate_type_check("_k",
                                                                                        key_type)} && #{generate_type_check(
                                                                                          "_v", value_type
                                                                                        )} }"
        else
          "#{var_name}.is_a?(Hash)"
        end
      when "Set"
        "#{var_name}.is_a?(Set) && #{var_name}.all? { |_e| #{generate_type_check("_e", element_type)} }"
      else
        # Generic with unknown container - just check container type
        "#{var_name}.is_a?(#{container_type})"
      end
    end

    # Generate intersection type check
    def generate_intersection_check(var_name, intersection_type)
      types = intersection_type.split("&").map(&:strip)
      checks = types.map { |t| generate_type_check(var_name, t) }
      "(#{checks.join(" && ")})"
    end

    # Generate return value validation wrapper
    def generate_return_validation(return_type)
      {
        type: :return,
        check: generate_type_check("_result", return_type),
        return_type: return_type,
      }
    end

    # Transform source code to include runtime validations
    def transform(source, parse_result)
      lines = source.split("\\n")
      output_lines = []
      in_function = false
      current_function = nil
      function_indent = 0

      parse_result[:functions].each do |func|
        @function_validations ||= {}
        @function_validations[func[:name]] = generate_function_validation(func)
      end

      lines.each_with_index do |line, _idx|
        # Check for function definition
        if line.match?(/^\\s*def\\s+(\\w+)/)
          match = line.match(/^(\\s*)def\\s+(\\w+)/)
          function_indent = match[1].length
          function_name = match[2]

          # Add validation code after function definition
          output_lines << line

          if @function_validations && @function_validations[function_name]
            validations = @function_validations[function_name]
            param_validations = validations.select { |v| v.is_a?(String) }

            param_validations.each do |validation|
              output_lines << "#{" " * (function_indent + 2)}#{validation}"
            end
          end

          in_function = true
          current_function = function_name
        elsif in_function && line.match?(/^\\s*end\\s*$/)
          # End of function
          in_function = false
          current_function = nil
          output_lines << line
        else
          output_lines << line
        end
      end

      output_lines.join("\\n")
    end

    # Generate a validation module that can be included
    def generate_validation_module(functions)
      module_code = <<~RUBY
        # frozen_string_literal: true
        # Auto-generated runtime type validation module

        module TRubyValidation
          class TypeError < StandardError; end

          def self.validate_type(value, expected_type, param_name = "value")
      RUBY

      module_code += <<~RUBY
          case expected_type
          when "String"
            raise TypeError, "\\#{param_name} must be String, got \\#{value.class}" unless value.is_a?(String)
          when "Integer"
            raise TypeError, "\\#{param_name} must be Integer, got \\#{value.class}" unless value.is_a?(Integer)
          when "Float"
            raise TypeError, "\\#{param_name} must be Float, got \\#{value.class}" unless value.is_a?(Float)
          when "Boolean"
            raise TypeError, "\\#{param_name} must be Boolean, got \\#{value.class}" unless value == true || value == false
          when "Symbol"
            raise TypeError, "\\#{param_name} must be Symbol, got \\#{value.class}" unless value.is_a?(Symbol)
          when "Array"
            raise TypeError, "\\#{param_name} must be Array, got \\#{value.class}" unless value.is_a?(Array)
          when "Hash"
            raise TypeError, "\\#{param_name} must be Hash, got \\#{value.class}" unless value.is_a?(Hash)
          when "nil"
            raise TypeError, "\\#{param_name} must be nil, got \\#{value.class}" unless value.nil?
          else
            # Custom type check
            begin
              type_class = Object.const_get(expected_type)
              raise TypeError, "\\#{param_name} must be \\#{expected_type}, got \\#{value.class}" unless value.is_a?(type_class)
            rescue NameError
              # Unknown type, skip validation
            end
          end
          true
        end
      RUBY

      # Generate validation methods for each function
      functions.each do |func|
        next if func[:params].empty? && !func[:return_type]

        method_name = "validate_#{func[:name]}_params"
        param_list = func[:params].map { |p| p[:name] }.join(", ")

        module_code += "\\n  def self.#{method_name}(#{param_list})\\n"

        func[:params].each do |param|
          next unless param[:type]

          module_code += "    validate_type(#{param[:name]}, #{param[:type].inspect}, #{param[:name].inspect})\\n"
        end

        module_code += "    true\\n  end\\n"
      end

      module_code += "end\\n"
      module_code
    end

    # Check if validation should be applied based on config
    def should_validate?(visibility)
      return true if @config.validate_all
      return visibility == :public if @config.validate_public_only

      false
    end
  end

  # Runtime type error
  class RuntimeTypeError < StandardError
    attr_reader :expected_type, :actual_type, :value, :location

    def initialize(message, expected_type: nil, actual_type: nil, value: nil, location: nil)
      super(message)
      @expected_type = expected_type
      @actual_type = actual_type
      @value = value
      @location = location
    end
  end

  # Mixin for adding runtime validation to classes
  module RuntimeTypeChecks
    def self.included(base)
      base.extend(ClassMethods)
    end

    module ClassMethods
      def validate_types!
        @_validate_types = true
      end

      def skip_type_validation!
        @_validate_types = false
      end

      def type_validation_enabled?
        @_validate_types != false
      end
    end

    private

    def validate_param(value, expected_type, param_name)
      return true unless self.class.type_validation_enabled?

      validator = RuntimeValidator.new
      check_code = validator.generate_type_check("value", expected_type)

      # Evaluate the check
      unless eval(check_code)
        raise RuntimeTypeError.new(
          "#{param_name} must be #{expected_type}, got #{value.class}",
          expected_type: expected_type,
          actual_type: value.class.to_s,
          value: value
        )
      end

      true
    end

    def validate_return(value, expected_type)
      return value unless self.class.type_validation_enabled?

      validator = RuntimeValidator.new
      check_code = validator.generate_type_check("value", expected_type)

      unless eval(check_code)
        raise RuntimeTypeError.new(
          "Return value must be #{expected_type}, got #{value.class}",
          expected_type: expected_type,
          actual_type: value.class.to_s,
          value: value
        )
      end

      value
    end
  end
end
`,
  "lib/t_ruby/scanner.rb": `# frozen_string_literal: true

module TRuby
  # Scanner - T-Ruby 소스 코드를 토큰 스트림으로 변환
  # TypeScript 컴파일러와 유사한 구조로, 파서와 분리되어 증분 파싱을 지원
  class Scanner
    # 토큰 구조체
    Token = Struct.new(:type, :value, :start_pos, :end_pos, :line, :column)

    # 스캔 에러
    class ScanError < StandardError
      attr_reader :line, :column, :position

      def initialize(message, line:, column:, position:)
        @line = line
        @column = column
        @position = position
        super("#{message} at line #{line}, column #{column}")
      end
    end

    # 키워드 맵
    KEYWORDS = {
      "def" => :def,
      "end" => :end,
      "class" => :class,
      "module" => :module,
      "if" => :if,
      "unless" => :unless,
      "else" => :else,
      "elsif" => :elsif,
      "return" => :return,
      "type" => :type,
      "interface" => :interface,
      "public" => :public,
      "private" => :private,
      "protected" => :protected,
      "true" => true,
      "false" => false,
      "nil" => :nil,
      "while" => :while,
      "until" => :until,
      "for" => :for,
      "do" => :do,
      "begin" => :begin,
      "rescue" => :rescue,
      "ensure" => :ensure,
      "case" => :case,
      "when" => :when,
      "then" => :then,
      "and" => :and,
      "or" => :or,
      "not" => :not,
      "in" => :in,
      "self" => :self,
      "super" => :super,
      "yield" => :yield,
      "break" => :break,
      "next" => :next,
      "redo" => :redo,
      "retry" => :retry,
      "raise" => :raise,
      "alias" => :alias,
      "defined?" => :defined,
      "__FILE__" => :__file__,
      "__LINE__" => :__line__,
      "__ENCODING__" => :__encoding__,
    }.freeze

    def initialize(source)
      @source = source
      @position = 0
      @line = 1
      @column = 1
      @tokens = []
      @token_index = 0
      @scanned = false
    end

    # 전체 토큰화 (캐싱용)
    def scan_all
      return @tokens if @scanned

      @tokens = []
      @position = 0
      @line = 1
      @column = 1

      while @position < @source.length
        token = scan_token
        @tokens << token if token
      end

      @tokens << Token.new(:eof, "", @position, @position, @line, @column)
      @scanned = true
      @tokens
    end

    # 단일 토큰 반환 (스트리밍용)
    def next_token
      scan_all unless @scanned

      token = @tokens[@token_index]
      @token_index += 1 unless token&.type == :eof
      token || @tokens.last
    end

    # lookahead
    def peek(n = 1)
      scan_all unless @scanned

      if n == 1
        @tokens[@token_index] || @tokens.last
      else
        @tokens[@token_index, n] || [@tokens.last]
      end
    end

    # 토큰 인덱스 리셋
    def reset
      @token_index = 0
    end

    private

    def scan_token
      skip_whitespace

      return nil if @position >= @source.length

      start_pos = @position
      start_line = @line
      start_column = @column
      char = current_char

      case char
      when "\\n"
        scan_newline
      when "#"
        scan_comment
      when '"'
        scan_double_quoted_string
      when "'"
        scan_single_quoted_string
      when ":"
        scan_colon_or_symbol
      when "@"
        scan_instance_or_class_variable
      when "$"
        scan_global_variable
      when /[a-z_\\p{L}]/i
        scan_identifier_or_keyword
      when /[0-9]/
        scan_number
      when "<"
        scan_less_than_or_heredoc
      when ">"
        scan_greater_than
      when "="
        scan_equals
      when "!"
        scan_bang
      when "&"
        scan_ampersand
      when "|"
        scan_pipe
      when "+"
        scan_plus
      when "-"
        scan_minus_or_arrow
      when "*"
        scan_star
      when "/"
        scan_slash
      when "%"
        scan_percent
      when "?"
        advance
        Token.new(:question, "?", start_pos, @position, start_line, start_column)
      when "("
        advance
        Token.new(:lparen, "(", start_pos, @position, start_line, start_column)
      when ")"
        advance
        Token.new(:rparen, ")", start_pos, @position, start_line, start_column)
      when "["
        advance
        Token.new(:lbracket, "[", start_pos, @position, start_line, start_column)
      when "]"
        advance
        Token.new(:rbracket, "]", start_pos, @position, start_line, start_column)
      when "{"
        advance
        Token.new(:lbrace, "{", start_pos, @position, start_line, start_column)
      when "}"
        advance
        Token.new(:rbrace, "}", start_pos, @position, start_line, start_column)
      when ","
        advance
        Token.new(:comma, ",", start_pos, @position, start_line, start_column)
      when "."
        advance
        Token.new(:dot, ".", start_pos, @position, start_line, start_column)
      else
        raise ScanError.new(
          "Unexpected character '#{char}'",
          line: start_line,
          column: start_column,
          position: start_pos
        )
      end
    end

    def scan_newline
      start_pos = @position
      start_line = @line
      start_column = @column

      advance
      @line += 1
      @column = 1

      Token.new(:newline, "\\n", start_pos, @position, start_line, start_column)
    end

    def scan_comment
      start_pos = @position
      start_line = @line
      start_column = @column

      value = ""
      while @position < @source.length && current_char != "\\n"
        value += current_char
        advance
      end

      Token.new(:comment, value, start_pos, @position, start_line, start_column)
    end

    def scan_double_quoted_string
      start_pos = @position
      start_line = @line
      start_column = @column

      # 보간이 있는지 확인을 위해 먼저 스캔
      advance # skip opening "

      has_interpolation = false
      temp_pos = @position
      while temp_pos < @source.length
        c = @source[temp_pos]
        break if c == '"' && (temp_pos == @position || @source[temp_pos - 1] != "\\\\")

        if c == "#" && temp_pos + 1 < @source.length && @source[temp_pos + 1] == "{"
          has_interpolation = true
          break
        end
        temp_pos += 1
      end

      @position = start_pos + 1 # reset to after opening "

      if has_interpolation
        scan_interpolated_string(start_pos, start_line, start_column)
      else
        scan_simple_string(start_pos, start_line, start_column, '"')
      end
    end

    def scan_interpolated_string(start_pos, start_line, start_column)
      # string_start 토큰 반환
      @tokens << Token.new(:string_start, '"', start_pos, start_pos + 1, start_line, start_column)

      content = ""
      content_start = @position
      content_line = @line
      content_column = @column

      while @position < @source.length
        char = current_char

        if char == '"'
          # 문자열 끝
          if content.length.positive?
            @tokens << Token.new(:string_content, content, content_start, @position, content_line, content_column)
          end
          advance
          return Token.new(:string_end, '"', @position - 1, @position, @line, @column - 1)
        elsif char == "\\\\" && peek_char
          # 이스케이프 시퀀스
          content += char
          advance
          content += current_char if @position < @source.length
          advance
        elsif char == "#" && peek_char == "{"
          # 보간 시작
          if content.length.positive?
            @tokens << Token.new(:string_content, content, content_start, @position, content_line, content_column)
            content = ""
          end

          interp_start = @position
          advance # skip #
          advance # skip {
          @tokens << Token.new(:interpolation_start, '#{', interp_start, @position, @line, @column - 2)

          # 보간 내부 토큰 스캔 (중첩된 {} 고려)
          scan_interpolation_content

          content_start = @position
          content_line = @line
          content_column = @column
        else
          content += char
          advance
        end
      end

      raise ScanError.new(
        "Unterminated string",
        line: start_line,
        column: start_column,
        position: start_pos
      )
    end

    def scan_interpolation_content
      depth = 1

      while @position < @source.length && depth.positive?
        skip_whitespace_in_interpolation

        break if @position >= @source.length

        char = current_char

        if char == "}"
          depth -= 1
          if depth.zero?
            interp_end_pos = @position
            advance
            @tokens << Token.new(:interpolation_end, "}", interp_end_pos, @position, @line, @column - 1)
            return
          end
        elsif char == "{"
          depth += 1
        end

        # 보간 내부의 토큰 스캔
        token = scan_token
        @tokens << token if token
      end
    end

    def skip_whitespace_in_interpolation
      advance while @position < @source.length && current_char =~ /[ \\t]/
    end

    def scan_simple_string(start_pos, start_line, start_column, quote)
      value = quote

      while @position < @source.length
        char = current_char

        if char == quote
          value += char
          advance
          return Token.new(:string, value, start_pos, @position, start_line, start_column)
        elsif char == "\\\\" && peek_char
          value += char
          advance
          value += current_char
          advance
        elsif char == "\\n"
          raise ScanError.new(
            "Unterminated string",
            line: start_line,
            column: start_column,
            position: start_pos
          )
        else
          value += char
          advance
        end
      end

      raise ScanError.new(
        "Unterminated string",
        line: start_line,
        column: start_column,
        position: start_pos
      )
    end

    def scan_single_quoted_string
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip opening '
      scan_simple_string(start_pos, start_line, start_column, "'")
    end

    def scan_colon_or_symbol
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip :

      # 심볼인지 확인
      if @position < @source.length && current_char =~ /[a-zA-Z_]/
        value = ":"
        while @position < @source.length && current_char =~ /[a-zA-Z0-9_]/
          value += current_char
          advance
        end
        Token.new(:symbol, value, start_pos, @position, start_line, start_column)
      else
        Token.new(:colon, ":", start_pos, @position, start_line, start_column)
      end
    end

    def scan_instance_or_class_variable
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip first @

      if current_char == "@"
        # 클래스 변수
        advance # skip second @
        value = "@@"
        while @position < @source.length && current_char =~ /[a-zA-Z0-9_]/
          value += current_char
          advance
        end
        Token.new(:cvar, value, start_pos, @position, start_line, start_column)
      else
        # 인스턴스 변수
        value = "@"
        while @position < @source.length && current_char =~ /[a-zA-Z0-9_]/
          value += current_char
          advance
        end
        Token.new(:ivar, value, start_pos, @position, start_line, start_column)
      end
    end

    def scan_global_variable
      start_pos = @position
      start_line = @line
      start_column = @column

      value = "$"
      advance # skip $

      while @position < @source.length && current_char =~ /[a-zA-Z0-9_]/
        value += current_char
        advance
      end

      Token.new(:gvar, value, start_pos, @position, start_line, start_column)
    end

    def scan_identifier_or_keyword
      start_pos = @position
      start_line = @line
      start_column = @column

      value = ""
      # Support Unicode letters (\\p{L}) and numbers (\\p{N}) in identifiers
      while @position < @source.length && current_char =~ /[\\p{L}\\p{N}_]/
        value += current_char
        advance
      end

      # ? 또는 ! 접미사 처리
      if @position < @source.length && ["?", "!"].include?(current_char)
        value += current_char
        advance
      end

      # 키워드인지 확인
      if KEYWORDS.key?(value)
        Token.new(KEYWORDS[value], value, start_pos, @position, start_line, start_column)
      elsif value[0] =~ /\\p{Lu}/ # Unicode uppercase letter
        Token.new(:constant, value, start_pos, @position, start_line, start_column)
      else
        Token.new(:identifier, value, start_pos, @position, start_line, start_column)
      end
    end

    def scan_number
      start_pos = @position
      start_line = @line
      start_column = @column

      value = ""
      while @position < @source.length && current_char =~ /[0-9_]/
        value += current_char
        advance
      end

      # 소수점 확인
      if @position < @source.length && current_char == "." && peek_char =~ /[0-9]/
        value += current_char
        advance
        while @position < @source.length && current_char =~ /[0-9_]/
          value += current_char
          advance
        end
        Token.new(:float, value, start_pos, @position, start_line, start_column)
      else
        Token.new(:integer, value, start_pos, @position, start_line, start_column)
      end
    end

    def scan_less_than_or_heredoc
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip <

      if current_char == "<"
        # heredoc 또는 <<
        advance
        # heredoc: <<EOF, <<-EOF, <<~EOF 형태
        if current_char =~ /[~-]/ || current_char =~ /[A-Z_]/i
          scan_heredoc(start_pos, start_line, start_column)
        else
          # << 연산자? 아니면 다시 되돌리기
          @position = start_pos + 1
          @column = start_column + 1
          Token.new(:lt, "<", start_pos, @position, start_line, start_column)
        end
      elsif current_char == "="
        advance
        if current_char == ">"
          advance
          Token.new(:spaceship, "<=>", start_pos, @position, start_line, start_column)
        else
          Token.new(:lt_eq, "<=", start_pos, @position, start_line, start_column)
        end
      else
        Token.new(:lt, "<", start_pos, @position, start_line, start_column)
      end
    end

    def scan_heredoc(start_pos, start_line, start_column)
      # <<~, <<-, << 형식 처리
      squiggly = false
      dash = false

      if current_char == "~"
        squiggly = true
        advance
      elsif current_char == "-"
        dash = true
        advance
      end

      # 종료 마커 읽기
      delimiter = ""
      while @position < @source.length && current_char =~ /[A-Za-z0-9_]/
        delimiter += current_char
        advance
      end

      # 현재 줄 끝까지 스킵
      advance while @position < @source.length && current_char != "\\n"
      advance if @position < @source.length # skip newline
      @line += 1
      @column = 1

      # heredoc 내용 수집
      content = ""

      while @position < @source.length
        line_content = ""

        while @position < @source.length && current_char != "\\n"
          line_content += current_char
          advance
        end

        # 종료 마커 확인
        stripped = squiggly || dash ? line_content.lstrip : line_content
        if stripped == delimiter || line_content.strip == delimiter
          # heredoc 끝
          value = "<<#{if squiggly
                         "~"
                       else
                         (dash ? "-" : "")
                       end}#{delimiter}\\n#{content}#{delimiter}"
          return Token.new(:heredoc, value, start_pos, @position, start_line, start_column)
        end

        content += line_content
        next unless @position < @source.length

        content += "\\n"
        advance # skip newline
        @line += 1
        @column = 1
      end

      # 종료 마커를 찾지 못함
      raise ScanError.new(
        "Unterminated heredoc",
        line: start_line,
        column: start_column,
        position: start_pos
      )
    end

    def scan_greater_than
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip >

      if current_char == "="
        advance
        Token.new(:gt_eq, ">=", start_pos, @position, start_line, start_column)
      else
        Token.new(:gt, ">", start_pos, @position, start_line, start_column)
      end
    end

    def scan_equals
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip =

      case current_char
      when "="
        advance
        Token.new(:eq_eq, "==", start_pos, @position, start_line, start_column)
      when ">"
        advance
        Token.new(:hash_rocket, "=>", start_pos, @position, start_line, start_column)
      else
        Token.new(:eq, "=", start_pos, @position, start_line, start_column)
      end
    end

    def scan_bang
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip !

      if current_char == "="
        advance
        Token.new(:bang_eq, "!=", start_pos, @position, start_line, start_column)
      else
        Token.new(:bang, "!", start_pos, @position, start_line, start_column)
      end
    end

    def scan_ampersand
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip &

      if current_char == "&"
        advance
        Token.new(:and_and, "&&", start_pos, @position, start_line, start_column)
      else
        Token.new(:amp, "&", start_pos, @position, start_line, start_column)
      end
    end

    def scan_pipe
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip |

      if current_char == "|"
        advance
        Token.new(:or_or, "||", start_pos, @position, start_line, start_column)
      else
        Token.new(:pipe, "|", start_pos, @position, start_line, start_column)
      end
    end

    def scan_plus
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip +

      if current_char == "="
        advance
        Token.new(:plus_eq, "+=", start_pos, @position, start_line, start_column)
      else
        Token.new(:plus, "+", start_pos, @position, start_line, start_column)
      end
    end

    def scan_minus_or_arrow
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip -

      case current_char
      when ">"
        advance
        Token.new(:arrow, "->", start_pos, @position, start_line, start_column)
      when "="
        advance
        Token.new(:minus_eq, "-=", start_pos, @position, start_line, start_column)
      else
        Token.new(:minus, "-", start_pos, @position, start_line, start_column)
      end
    end

    def scan_star
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip *

      case current_char
      when "*"
        advance
        Token.new(:star_star, "**", start_pos, @position, start_line, start_column)
      when "="
        advance
        Token.new(:star_eq, "*=", start_pos, @position, start_line, start_column)
      else
        Token.new(:star, "*", start_pos, @position, start_line, start_column)
      end
    end

    def scan_slash
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip /

      if current_char == "="
        advance
        Token.new(:slash_eq, "/=", start_pos, @position, start_line, start_column)
      elsif regex_context?
        # 정규표현식 리터럴 스캔
        scan_regex(start_pos, start_line, start_column)
      else
        Token.new(:slash, "/", start_pos, @position, start_line, start_column)
      end
    end

    def regex_context?
      # Check if / followed by whitespace - always division
      next_char = @source[@position]
      return false if [" ", "\\t", "\\n"].include?(next_char)

      # Check previous token context
      return true if @tokens.empty?

      last_token = @tokens.last
      return true if last_token.nil?

      # After values/expressions - division operator
      case last_token.type
      when :identifier, :constant, :integer, :float, :string, :symbol,
           :rparen, :rbracket, :rbrace, :ivar, :cvar, :gvar, :regex
        false
      # After binary operators - could be regex in \`a * /pattern/\` but safer to treat as division
      # unless there's no space after /
      when :plus, :minus, :star, :slash, :percent, :star_star,
           :lt, :gt, :lt_eq, :gt_eq, :eq_eq, :bang_eq, :spaceship,
           :and_and, :or_or, :amp, :pipe, :caret
        # Already checked no whitespace after /, so this could be regex
        true
      # After keywords that expect expression - regex context
      when :kw_if, :kw_unless, :kw_when, :kw_case, :kw_while, :kw_until,
           :kw_and, :kw_or, :kw_not, :kw_return, :kw_yield
        true
      # After opening brackets/parens, comma, equals - regex context
      when :lparen, :lbracket, :lbrace, :comma, :eq, :colon, :semicolon,
           :plus_eq, :minus_eq, :star_eq, :slash_eq, :percent_eq,
           :and_eq, :or_eq, :caret_eq, :arrow
        true
      else
        false
      end
    end

    def scan_regex(start_pos, start_line, start_column)
      value = "/"

      while @position < @source.length
        char = current_char

        case char
        when "/"
          value += char
          advance
          # 플래그 스캔 (i, m, x, o 등)
          while @position < @source.length && current_char =~ /[imxo]/
            value += current_char
            advance
          end
          return Token.new(:regex, value, start_pos, @position, start_line, start_column)
        when "\\\\"
          # 이스케이프 시퀀스
          value += char
          advance
          if @position < @source.length
            value += current_char
            advance
          end
        when "\\n"
          raise ScanError.new(
            "Unterminated regex",
            line: start_line,
            column: start_column,
            position: start_pos
          )
        else
          value += char
          advance
        end
      end

      raise ScanError.new(
        "Unterminated regex",
        line: start_line,
        column: start_column,
        position: start_pos
      )
    end

    def scan_percent
      start_pos = @position
      start_line = @line
      start_column = @column

      advance # skip %

      if current_char == "="
        advance
        Token.new(:percent_eq, "%=", start_pos, @position, start_line, start_column)
      else
        Token.new(:percent, "%", start_pos, @position, start_line, start_column)
      end
    end

    def skip_whitespace
      advance while @position < @source.length && current_char =~ /[ \\t\\r]/
    end

    def current_char
      @source[@position]
    end

    def peek_char
      @source[@position + 1]
    end

    def advance
      @column += 1
      @position += 1
    end
  end
end
`,
  "lib/t_ruby/smt_solver.rb": `# frozen_string_literal: true

module TRuby
  module SMT
    #==========================================================================
    # Logical Formulas
    #==========================================================================

    # Base class for all formulas
    class Formula
      def &(other)
        And.new(self, other)
      end

      def |(other)
        Or.new(self, other)
      end

      def !
        Not.new(self)
      end

      def implies(other)
        Implies.new(self, other)
      end

      def iff(other)
        Iff.new(self, other)
      end

      def free_variables
        raise NotImplementedError
      end

      def substitute(bindings)
        raise NotImplementedError
      end

      def simplify
        self
      end

      def to_cnf
        raise NotImplementedError
      end
    end

    # Boolean constant
    class BoolConst < Formula
      attr_reader :value

      def initialize(value)
        @value = value
      end

      def free_variables
        Set.new
      end

      def substitute(_bindings)
        self
      end

      def simplify
        self
      end

      def to_cnf
        @value ? [[]] : [[]]
      end

      def ==(other)
        other.is_a?(BoolConst) && other.value == @value
      end

      def to_s
        @value.to_s
      end
    end

    TRUE = BoolConst.new(true)
    FALSE = BoolConst.new(false)

    # Propositional variable
    class Variable < Formula
      attr_reader :name

      def initialize(name)
        @name = name.to_s
      end

      def free_variables
        Set.new([@name])
      end

      def substitute(bindings)
        bindings[@name] || self
      end

      def to_cnf
        [[@name]]
      end

      def ==(other)
        other.is_a?(Variable) && other.name == @name
      end

      def hash
        @name.hash
      end

      def eql?(other)
        self == other
      end

      def to_s
        @name
      end
    end

    # Negation
    class Not < Formula
      attr_reader :operand

      def initialize(operand)
        @operand = operand
      end

      def free_variables
        @operand.free_variables
      end

      def substitute(bindings)
        Not.new(@operand.substitute(bindings))
      end

      def simplify
        inner = @operand.simplify
        case inner
        when BoolConst
          BoolConst.new(!inner.value)
        when Not
          inner.operand
        else
          Not.new(inner)
        end
      end

      def to_cnf
        case @operand
        when Variable
          [["!#{@operand.name}"]]
        when Not
          @operand.operand.to_cnf
        when And
          # De Morgan: !(A & B) = !A | !B
          Or.new(Not.new(@operand.left), Not.new(@operand.right)).to_cnf
        when Or
          # De Morgan: !(A | B) = !A & !B
          And.new(Not.new(@operand.left), Not.new(@operand.right)).to_cnf
        else
          [["!#{@operand}"]]
        end
      end

      def ==(other)
        other.is_a?(Not) && other.operand == @operand
      end

      def to_s
        "!#{@operand}"
      end
    end

    # Conjunction
    class And < Formula
      attr_reader :left, :right

      def initialize(left, right)
        @left = left
        @right = right
      end

      def free_variables
        @left.free_variables | @right.free_variables
      end

      def substitute(bindings)
        And.new(@left.substitute(bindings), @right.substitute(bindings))
      end

      def simplify
        l = @left.simplify
        r = @right.simplify

        return FALSE if l == FALSE || r == FALSE
        return r if l == TRUE
        return l if r == TRUE
        return l if l == r

        And.new(l, r)
      end

      def to_cnf
        @left.to_cnf + @right.to_cnf
      end

      def ==(other)
        other.is_a?(And) && other.left == @left && other.right == @right
      end

      def to_s
        "(#{@left} && #{@right})"
      end
    end

    # Disjunction
    class Or < Formula
      attr_reader :left, :right

      def initialize(left, right)
        @left = left
        @right = right
      end

      def free_variables
        @left.free_variables | @right.free_variables
      end

      def substitute(bindings)
        Or.new(@left.substitute(bindings), @right.substitute(bindings))
      end

      def simplify
        l = @left.simplify
        r = @right.simplify

        return TRUE if l == TRUE || r == TRUE
        return r if l == FALSE
        return l if r == FALSE
        return l if l == r

        Or.new(l, r)
      end

      def to_cnf
        left_cnf = @left.to_cnf
        right_cnf = @right.to_cnf

        # Distribute: (A & B) | C = (A | C) & (B | C)
        result = []
        left_cnf.each do |left_clause|
          right_cnf.each do |right_clause|
            result << (left_clause + right_clause).uniq
          end
        end
        result
      end

      def ==(other)
        other.is_a?(Or) && other.left == @left && other.right == @right
      end

      def to_s
        "(#{@left} || #{@right})"
      end
    end

    # Implication
    class Implies < Formula
      attr_reader :antecedent, :consequent

      def initialize(antecedent, consequent)
        @antecedent = antecedent
        @consequent = consequent
      end

      def free_variables
        @antecedent.free_variables | @consequent.free_variables
      end

      def substitute(bindings)
        Implies.new(@antecedent.substitute(bindings), @consequent.substitute(bindings))
      end

      def simplify
        # A -> B = !A | B
        Or.new(Not.new(@antecedent), @consequent).simplify
      end

      def to_cnf
        # A -> B = !A | B
        Or.new(Not.new(@antecedent), @consequent).to_cnf
      end

      def ==(other)
        other.is_a?(Implies) && other.antecedent == @antecedent && other.consequent == @consequent
      end

      def to_s
        "(#{@antecedent} -> #{@consequent})"
      end
    end

    # Biconditional
    class Iff < Formula
      attr_reader :left, :right

      def initialize(left, right)
        @left = left
        @right = right
      end

      def free_variables
        @left.free_variables | @right.free_variables
      end

      def substitute(bindings)
        Iff.new(@left.substitute(bindings), @right.substitute(bindings))
      end

      def simplify
        # A <-> B = (A -> B) & (B -> A)
        And.new(Implies.new(@left, @right), Implies.new(@right, @left)).simplify
      end

      def to_cnf
        And.new(Implies.new(@left, @right), Implies.new(@right, @left)).to_cnf
      end

      def ==(other)
        other.is_a?(Iff) && other.left == @left && other.right == @right
      end

      def to_s
        "(#{@left} <-> #{@right})"
      end
    end

    #==========================================================================
    # Type Constraints
    #==========================================================================

    # Type variable
    class TypeVar < Formula
      attr_reader :name, :bounds

      def initialize(name, bounds: nil)
        @name = name.to_s
        @bounds = bounds # { upper: Type, lower: Type }
      end

      def free_variables
        Set.new([@name])
      end

      def substitute(bindings)
        bindings[@name] || self
      end

      def to_cnf
        [[@name]]
      end

      def ==(other)
        other.is_a?(TypeVar) && other.name == @name
      end

      def hash
        @name.hash
      end

      def eql?(other)
        self == other
      end

      def to_s
        @name
      end
    end

    # Subtype constraint: A <: B (A is subtype of B)
    class Subtype < Formula
      attr_reader :subtype, :supertype

      def initialize(subtype, supertype)
        @subtype = subtype
        @supertype = supertype
      end

      def free_variables
        vars = Set.new
        vars.add(@subtype.name) if @subtype.is_a?(TypeVar)
        vars.add(@supertype.name) if @supertype.is_a?(TypeVar)
        vars
      end

      def substitute(bindings)
        sub = @subtype.is_a?(TypeVar) ? (bindings[@subtype.name] || @subtype) : @subtype
        sup = @supertype.is_a?(TypeVar) ? (bindings[@supertype.name] || @supertype) : @supertype
        Subtype.new(sub, sup)
      end

      def simplify
        self
      end

      def to_cnf
        [["#{@subtype}<:#{@supertype}"]]
      end

      def ==(other)
        other.is_a?(Subtype) && other.subtype == @subtype && other.supertype == @supertype
      end

      def to_s
        "#{@subtype} <: #{@supertype}"
      end
    end

    # Type equality: A = B
    class TypeEqual < Formula
      attr_reader :left, :right

      def initialize(left, right)
        @left = left
        @right = right
      end

      def free_variables
        vars = Set.new
        vars.add(@left.name) if @left.is_a?(TypeVar)
        vars.add(@right.name) if @right.is_a?(TypeVar)
        vars
      end

      def substitute(bindings)
        l = @left.is_a?(TypeVar) ? (bindings[@left.name] || @left) : @left
        r = @right.is_a?(TypeVar) ? (bindings[@right.name] || @right) : @right
        TypeEqual.new(l, r)
      end

      def simplify
        return TRUE if @left == @right

        self
      end

      def to_cnf
        [["#{@left}=#{@right}"]]
      end

      def ==(other)
        other.is_a?(TypeEqual) && other.left == @left && other.right == @right
      end

      def to_s
        "#{@left} = #{@right}"
      end
    end

    # Instance constraint: T has property P
    class HasProperty < Formula
      attr_reader :type_var, :property, :property_type

      def initialize(type_var, property, property_type)
        @type_var = type_var
        @property = property
        @property_type = property_type
      end

      def free_variables
        vars = Set.new
        vars.add(@type_var.name) if @type_var.is_a?(TypeVar)
        vars.add(@property_type.name) if @property_type.is_a?(TypeVar)
        vars
      end

      def substitute(bindings)
        tv = @type_var.is_a?(TypeVar) ? (bindings[@type_var.name] || @type_var) : @type_var
        pt = @property_type.is_a?(TypeVar) ? (bindings[@property_type.name] || @property_type) : @property_type
        HasProperty.new(tv, @property, pt)
      end

      def to_cnf
        [["#{@type_var}.#{@property}:#{@property_type}"]]
      end

      def to_s
        "#{@type_var} has #{@property}: #{@property_type}"
      end
    end

    #==========================================================================
    # Concrete Types for Solver
    #==========================================================================

    class ConcreteType
      attr_reader :name

      def initialize(name)
        @name = name
      end

      def ==(other)
        other.is_a?(ConcreteType) && other.name == @name
      end

      def hash
        @name.hash
      end

      def eql?(other)
        self == other
      end

      def to_s
        @name
      end
    end

    #==========================================================================
    # SAT Solver (DPLL Algorithm)
    #==========================================================================

    class SATSolver
      attr_reader :assignments, :conflicts

      def initialize
        @assignments = {}
        @conflicts = []
      end

      # Solve CNF formula
      def solve(cnf)
        @assignments = {}
        @conflicts = []

        dpll(cnf.dup, {})
      end

      private

      def dpll(clauses, assignment)
        # Unit propagation
        loop do
          unit = find_unit_clause(clauses)
          break unless unit

          var, value = parse_literal(unit)
          assignment[var] = value
          clauses = propagate(clauses, var, value)

          return nil if clauses.any?(&:empty?) # Conflict
        end

        # All clauses satisfied
        return assignment if clauses.empty?

        # Check for empty clause (conflict)
        return nil if clauses.any?(&:empty?)

        # Choose variable
        var = choose_variable(clauses)
        return assignment unless var

        # Try true
        result = dpll(propagate(clauses.dup, var, true), assignment.merge(var => true))
        return result if result

        # Try false
        dpll(propagate(clauses.dup, var, false), assignment.merge(var => false))
      end

      def find_unit_clause(clauses)
        clauses.each do |clause|
          return clause.first if clause.length == 1
        end
        nil
      end

      def parse_literal(literal)
        if literal.start_with?("!")
          [literal[1..], false]
        else
          [literal, true]
        end
      end

      def propagate(clauses, var, value)
        result = []

        clauses.each do |clause|
          # If clause contains literal with matching polarity, clause is satisfied
          satisfied = clause.any? do |lit|
            lit_var, lit_value = parse_literal(lit)
            lit_var == var && lit_value == value
          end

          next if satisfied

          # Remove literals with opposite polarity
          new_clause = clause.reject do |lit|
            lit_var, lit_value = parse_literal(lit)
            lit_var == var && lit_value != value
          end

          result << new_clause
        end

        result
      end

      def choose_variable(clauses)
        # VSIDS-like heuristic: choose most frequent variable
        counts = Hash.new(0)

        clauses.each do |clause|
          clause.each do |lit|
            var, = parse_literal(lit)
            counts[var] += 1
          end
        end

        counts.max_by { |_, v| v }&.first
      end
    end

    #==========================================================================
    # Type Constraint Solver
    #==========================================================================

    class ConstraintSolver
      attr_reader :constraints, :solution, :errors

      # Type hierarchy (built-in)
      TYPE_HIERARCHY = {
        "Integer" => %w[Numeric Object],
        "Float" => %w[Numeric Object],
        "Numeric" => ["Object"],
        "String" => ["Object"],
        "Array" => %w[Enumerable Object],
        "Hash" => %w[Enumerable Object],
        "Enumerable" => ["Object"],
        "Boolean" => ["Object"],
        "Symbol" => ["Object"],
        "nil" => ["Object"],
        "Object" => [],
      }.freeze

      def initialize
        @constraints = []
        @solution = {}
        @errors = []
        @type_vars = {}
      end

      # Create a new type variable
      def fresh_var(prefix = "T")
        name = "#{prefix}#{@type_vars.length}"
        var = TypeVar.new(name)
        @type_vars[name] = var
        var
      end

      # Add constraint
      def add_constraint(constraint)
        @constraints << constraint
      end

      # Add subtype constraint
      def add_subtype(sub, sup)
        add_constraint(Subtype.new(sub, sup))
      end

      # Add equality constraint
      def add_equal(left, right)
        add_constraint(TypeEqual.new(left, right))
      end

      # Solve all constraints
      def solve
        @solution = {}
        @errors = []

        # Phase 1: Unification
        unified = unify_constraints

        # Phase 2: Subtype checking
        check_subtypes(unified) if @errors.empty?

        # Phase 3: Instantiation
        instantiate_remaining if @errors.empty?

        {
          success: @errors.empty?,
          solution: @solution,
          errors: @errors,
        }
      end

      # Check if type A is subtype of type B
      def subtype?(sub, sup)
        return true if sub == sup
        return true if sup.to_s == "Object"
        return true if sub.to_s == "nil" # nil is subtype of everything (nullable)

        sub_name = sub.is_a?(ConcreteType) ? sub.name : sub.to_s
        sup_name = sup.is_a?(ConcreteType) ? sup.name : sup.to_s

        # Check type hierarchy
        ancestors = TYPE_HIERARCHY[sub_name] || []
        return true if ancestors.include?(sup_name)

        # Check transitive closure
        ancestors.any? { |a| subtype?(ConcreteType.new(a), sup) }
      end

      # Infer type from constraints
      def infer(var)
        @solution[var.name] || @solution[var.to_s]
      end

      private

      def unify_constraints
        worklist = @constraints.dup

        while (constraint = worklist.shift)
          case constraint
          when TypeEqual
            result = unify(constraint.left, constraint.right)
            if result
              # Apply substitution to remaining constraints
              worklist = worklist.map { |c| c.substitute(result) }
              @solution.merge!(result)
            else
              @errors << "Cannot unify #{constraint.left} with #{constraint.right}"
            end
          end
        end

        @constraints.reject { |c| c.is_a?(TypeEqual) }
      end

      def unify(left, right)
        return {} if left == right

        # If left is type variable, bind it
        if left.is_a?(TypeVar)
          return nil if occurs_check(left, right)

          return { left.name => right }
        end

        # If right is type variable, bind it
        if right.is_a?(TypeVar)
          return nil if occurs_check(right, left)

          return { right.name => left }
        end

        # Both are concrete types
        if left.is_a?(ConcreteType) && right.is_a?(ConcreteType)
          return {} if left.name == right.name

          return nil
        end

        nil
      end

      def occurs_check(var, type)
        return false unless type.respond_to?(:free_variables)

        type.free_variables.include?(var.name)
      end

      def check_subtypes(remaining_constraints)
        remaining_constraints.each do |constraint|
          case constraint
          when Subtype
            sub = resolve_type(constraint.subtype)
            sup = resolve_type(constraint.supertype)

            # Skip if either is still a TypeVar (unresolved)
            next if sub.is_a?(TypeVar) || sup.is_a?(TypeVar)

            unless subtype?(sub, sup)
              @errors << "Type #{sub} is not a subtype of #{sup}"
            end
          end
        end
      end

      def resolve_type(type)
        case type
        when TypeVar
          @solution[type.name] || type
        when ConcreteType
          type
        else
          ConcreteType.new(type.to_s)
        end
      end

      def instantiate_remaining
        @type_vars.each_key do |name|
          next if @solution[name]

          # Default to Object if no constraints
          @solution[name] = ConcreteType.new("Object")
        end
      end
    end

    #==========================================================================
    # Type Inference Engine using SMT
    #==========================================================================

    class TypeInferenceEngine
      attr_reader :solver, :type_env

      def initialize
        @solver = ConstraintSolver.new
        @type_env = {} # Variable name -> Type
      end

      # Infer types for a method
      def infer_method(method_ir)
        param_types = {}

        # Create type variables for parameters without annotations
        method_ir.params.each do |param|
          param_types[param.name] = if param.type_annotation
                                      type_from_ir(param.type_annotation)
                                    else
                                      @solver.fresh_var("P_#{param.name}")
                                    end
          @type_env[param.name] = param_types[param.name]
        end

        # Create type variable for return type if not annotated
        return_type = if method_ir.return_type
                        type_from_ir(method_ir.return_type)
                      else
                        @solver.fresh_var("R_#{method_ir.name}")
                      end

        # Analyze body to generate constraints
        if method_ir.body
          infer_body(method_ir.body, return_type)
        end

        # Solve constraints
        result = @solver.solve

        if result[:success]
          # Build inferred signature
          inferred_params = param_types.transform_values do |type|
            resolve_type(type, result[:solution])
          end

          inferred_return = resolve_type(return_type, result[:solution])

          {
            success: true,
            params: inferred_params,
            return_type: inferred_return,
          }
        else
          {
            success: false,
            errors: result[:errors],
          }
        end
      end

      # Generate constraints from method body
      def infer_body(body_ir, expected_return)
        case body_ir
        when IR::Block
          body_ir.statements.each do |stmt|
            infer_statement(stmt, expected_return)
          end
        when IR::Return
          if body_ir.value
            value_type = infer_expression(body_ir.value)
            @solver.add_subtype(value_type, expected_return)
          end
        end
      end

      # Infer statement
      def infer_statement(stmt, expected_return)
        case stmt
        when IR::Assignment
          value_type = infer_expression(stmt.value)
          @type_env[stmt.target] = value_type

          if stmt.type_annotation
            annotated = type_from_ir(stmt.type_annotation)
            @solver.add_subtype(value_type, annotated)
          end
        when IR::Return
          if stmt.value
            value_type = infer_expression(stmt.value)
            @solver.add_subtype(value_type, expected_return)
          end
        when IR::Conditional
          infer_expression(stmt.condition)
          infer_body(stmt.then_branch, expected_return) if stmt.then_branch
          infer_body(stmt.else_branch, expected_return) if stmt.else_branch
        end
      end

      # Infer expression type
      def infer_expression(expr)
        case expr
        when IR::Literal
          ConcreteType.new(literal_type(expr.literal_type))
        when IR::VariableRef
          @type_env[expr.name] || @solver.fresh_var("V_#{expr.name}")
        when IR::MethodCall
          infer_method_call(expr)
        when IR::BinaryOp
          infer_binary_op(expr)
        when IR::ArrayLiteral
          infer_array_literal(expr)
        else
          @solver.fresh_var("E")
        end
      end

      private

      def type_from_ir(ir_type)
        case ir_type
        when IR::SimpleType
          ConcreteType.new(ir_type.name)
        when IR::GenericType
          # Simplified: just use base type for now
          ConcreteType.new(ir_type.base)
        when IR::UnionType
          # Create fresh var with union constraint
          @solver.fresh_var("U")
        when IR::NullableType
          # T | nil
          @solver.fresh_var("N")
        else
          @solver.fresh_var("T")
        end
      end

      def resolve_type(type, solution)
        case type
        when TypeVar
          resolved = solution[type.name]
          resolved ? resolve_type(resolved, solution) : "Object"
        when ConcreteType
          type.name
        else
          type.to_s
        end
      end

      def literal_type(lit_type)
        case lit_type
        when :string then "String"
        when :integer then "Integer"
        when :float then "Float"
        when :boolean then "Boolean"
        when :symbol then "Symbol"
        when :nil then "nil"
        when :array then "Array"
        when :hash then "Hash"
        else "Object"
        end
      end

      def infer_method_call(call)
        # Get receiver type
        receiver_type = if call.receiver
                          infer_expression(call.receiver)
                        else
                          @type_env["self"] || ConcreteType.new("Object")
                        end

        # Look up method return type
        return_type = lookup_method_type(receiver_type, call.method_name)
        return_type || @solver.fresh_var("M_#{call.method_name}")
      end

      def lookup_method_type(_receiver, method)
        # Built-in method types
        method_types = {
          "to_s" => ConcreteType.new("String"),
          "to_i" => ConcreteType.new("Integer"),
          "to_f" => ConcreteType.new("Float"),
          "length" => ConcreteType.new("Integer"),
          "size" => ConcreteType.new("Integer"),
          "empty?" => ConcreteType.new("Boolean"),
          "nil?" => ConcreteType.new("Boolean"),
        }

        method_types[method.to_s]
      end

      def infer_binary_op(expr)
        left_type = infer_expression(expr.left)
        right_type = infer_expression(expr.right)

        case expr.operator
        when "+", "-", "*", "/", "%"
          # Numeric operations
          @solver.add_subtype(left_type, ConcreteType.new("Numeric"))
          @solver.add_subtype(right_type, ConcreteType.new("Numeric"))
          ConcreteType.new("Numeric")
        when "==", "!=", "<", ">", "<=", ">="
          ConcreteType.new("Boolean")
        when "&&", "||"
          ConcreteType.new("Boolean")
        else
          @solver.fresh_var("Op")
        end
      end

      def infer_array_literal(expr)
        unless expr.elements.empty?
          element_type = @solver.fresh_var("E")
          expr.elements.each do |elem|
            elem_type = infer_expression(elem)
            @solver.add_subtype(elem_type, element_type)
          end
        end
        ConcreteType.new("Array")
      end
    end

    #==========================================================================
    # DSL for building constraints
    #==========================================================================

    module DSL
      def var(name)
        Variable.new(name)
      end

      def type_var(name, bounds: nil)
        TypeVar.new(name, bounds: bounds)
      end

      def concrete(name)
        ConcreteType.new(name)
      end

      def subtype(sub, sup)
        Subtype.new(sub, sup)
      end

      def type_equal(left, right)
        TypeEqual.new(left, right)
      end

      def has_property(type, prop, prop_type)
        HasProperty.new(type, prop, prop_type)
      end

      def all(*constraints)
        constraints.reduce { |acc, c| acc & c }
      end

      def any(*constraints)
        constraints.reduce { |acc, c| acc | c }
      end
    end
  end
end
`,
  "lib/t_ruby/string_utils.rb": `# frozen_string_literal: true

module TRuby
  # 문자열 파싱을 위한 공통 유틸리티 모듈
  # 파서와 컴파일러에서 공유하는 중첩 괄호 처리 로직
  module StringUtils
    module_function

    # 중첩된 괄호를 고려하여 콤마로 문자열 분리
    # @param content [String] 분리할 문자열
    # @return [Array<String>] 분리된 문자열 배열
    def split_by_comma(content)
      result = []
      current = ""
      depth = 0

      content.each_char do |char|
        case char
        when "<", "[", "(", "{"
          depth += 1
          current += char
        when ">", "]", ")", "}"
          depth -= 1
          current += char
        when ","
          if depth.zero?
            result << current.strip
            current = ""
          else
            current += char
          end
        else
          current += char
        end
      end

      result << current.strip unless current.empty?
      result
    end

    # 타입과 기본값 분리: "String = 0" -> ["String", "0"]
    # 중첩된 괄호 내부의 = 는 무시
    # @param type_and_default [String] "Type = default" 형태의 문자열
    # @return [Array] [type_str, default_value] 또는 [type_str, nil]
    def split_type_and_default(type_and_default)
      depth = 0
      equals_pos = nil

      type_and_default.each_char.with_index do |char, i|
        case char
        when "<", "[", "(", "{"
          depth += 1
        when ">", "]", ")", "}"
          depth -= 1
        when "="
          if depth.zero?
            equals_pos = i
            break
          end
        end
      end

      if equals_pos
        type_str = type_and_default[0...equals_pos].strip
        default_value = type_and_default[(equals_pos + 1)..].strip
        [type_str, default_value]
      else
        [type_and_default, nil]
      end
    end

    # 기본값만 추출 (타입은 버림)
    # @param type_and_default [String] "Type = default" 형태의 문자열
    # @return [String, nil] 기본값 또는 nil
    def extract_default_value(type_and_default)
      _, default_value = split_type_and_default(type_and_default)
      default_value
    end
  end
end
`,
  "lib/t_ruby/type_alias_registry.rb": `# frozen_string_literal: true

module TRuby
  # Custom exceptions for type alias errors
  class DuplicateTypeAliasError < StandardError; end
  class CircularTypeAliasError < StandardError; end
  class UndefinedTypeError < StandardError; end

  class TypeAliasRegistry
    BUILT_IN_TYPES = %w[String Integer Boolean Array Hash Symbol void nil].freeze

    def initialize
      @aliases = {}
    end

    def register(name, definition)
      if @aliases.key?(name)
        raise DuplicateTypeAliasError, "Type alias '#{name}' is already defined"
      end

      # Check for self-reference
      if name == definition
        raise CircularTypeAliasError, "Type alias '#{name}' cannot reference itself"
      end

      # Check for circular references (including longer chains)
      if would_create_cycle?(name, definition)
        raise CircularTypeAliasError, "Circular type alias detected involving '#{name}'"
      end

      @aliases[name] = definition
    end

    def resolve(name)
      @aliases[name]
    end

    def all
      @aliases.dup
    end

    def clear
      @aliases.clear
    end

    def valid_type?(name)
      return true if BUILT_IN_TYPES.include?(name)

      @aliases.key?(name)
    end

    def validate_all
      @aliases.each do |name, definition|
        check_circular_references(name)
        check_undefined_types(definition)
      end
    end

    private

    def would_create_cycle?(name, definition)
      # Follow the chain of definitions from 'definition' to see if it leads back to 'name'
      visited = Set.new
      current = definition

      # Check each step in the chain
      until visited.include?(current)
        return true if current == name
        return false unless @aliases.key?(current)

        visited.add(current)
        current = @aliases[current]
      end

      false
    end

    def check_circular_references(name, visited = Set.new)
      return if visited.include?(name)

      visited.add(name)
      definition = @aliases[name]

      return unless @aliases.key?(definition)

      if visited.include?(definition)
        raise CircularTypeAliasError, "Circular type alias detected involving '#{name}'"
      end

      check_circular_references(definition, visited)
    end

    def check_undefined_types(type_name)
      return if BUILT_IN_TYPES.include?(type_name)
      return if @aliases.key?(type_name)

      # Ignore generic types for now (e.g., Array<String>, Result<T, E>)
      return if type_name.include?("<")

      raise UndefinedTypeError, "Type '#{type_name}' is not defined"
    end
  end
end
`,
  "lib/t_ruby/type_checker.rb": `# frozen_string_literal: true

module TRuby
  # Represents a type checking error (can be raised as an exception)
  class TypeCheckError < StandardError
    attr_reader :error_message, :location, :expected, :actual, :suggestion, :severity

    def initialize(message:, location: nil, expected: nil, actual: nil, suggestion: nil, severity: :error)
      @error_message = message
      @location = location
      @expected = expected
      @actual = actual
      @suggestion = suggestion
      @severity = severity
      super(build_full_message)
    end

    def to_diagnostic
      {
        severity: @severity,
        message: @error_message,
        location: @location,
        expected: @expected,
        actual: @actual,
        suggestion: @suggestion,
      }
    end

    private

    def build_full_message
      parts = [@error_message]
      parts << "  Expected: #{@expected}" if @expected
      parts << "  Actual: #{@actual}" if @actual
      parts << "  Suggestion: #{@suggestion}" if @suggestion
      parts << "  at #{@location}" if @location
      parts.join("\\n")
    end
  end

  # Type hierarchy for subtype checking
  class TypeHierarchy
    NUMERIC_TYPES = %w[Integer Float Numeric].freeze
    COLLECTION_TYPES = %w[Array Hash Set].freeze

    def initialize
      @subtypes = {
        "Integer" => %w[Numeric Object],
        "Float" => %w[Numeric Object],
        "Numeric" => ["Object"],
        "String" => ["Object"],
        "Symbol" => ["Object"],
        "Array" => %w[Enumerable Object],
        "Hash" => %w[Enumerable Object],
        "Set" => %w[Enumerable Object],
        "Boolean" => ["Object"],
        "nil" => ["Object"],
        "Object" => [],
      }
    end

    def subtype_of?(subtype, supertype)
      return true if subtype == supertype
      return true if supertype == "Object"

      chain = @subtypes[subtype] || []
      return true if chain.include?(supertype)

      # Check transitive relationship
      chain.any? { |t| subtype_of?(t, supertype) }
    end

    def compatible?(type_a, type_b)
      subtype_of?(type_a, type_b) || subtype_of?(type_b, type_a)
    end

    def register_subtype(subtype, supertype)
      @subtypes[subtype] ||= []
      @subtypes[subtype] << supertype unless @subtypes[subtype].include?(supertype)
    end

    def common_supertype(type_a, type_b)
      return type_a if type_a == type_b
      return type_a if subtype_of?(type_b, type_a)
      return type_b if subtype_of?(type_a, type_b)

      # Find common ancestor
      chain_a = [type_a] + (@subtypes[type_a] || [])
      chain_b = [type_b] + (@subtypes[type_b] || [])

      common = chain_a & chain_b
      common.first || "Object"
    end
  end

  # Scope for tracking variable types in a block
  class TypeScope
    attr_reader :parent, :variables

    def initialize(parent = nil)
      @parent = parent
      @variables = {}
    end

    def define(name, type)
      @variables[name] = type
    end

    def lookup(name)
      @variables[name] || @parent&.lookup(name)
    end

    def child_scope
      TypeScope.new(self)
    end
  end

  # Flow-sensitive type tracking
  class FlowContext
    attr_reader :narrowed_types, :guard_conditions

    def initialize
      @narrowed_types = {}
      @guard_conditions = []
    end

    def narrow(variable, new_type)
      @narrowed_types[variable] = new_type
    end

    def get_narrowed_type(variable)
      @narrowed_types[variable]
    end

    def push_guard(condition)
      @guard_conditions.push(condition)
    end

    def pop_guard
      @guard_conditions.pop
    end

    def branch
      new_context = FlowContext.new
      @narrowed_types.each { |k, v| new_context.narrow(k, v) }
      new_context
    end

    def merge(other)
      # Merge two branches - types that are narrowed in both become union
      merged = FlowContext.new
      all_vars = @narrowed_types.keys | other.narrowed_types.keys

      all_vars.each do |var|
        type_a = @narrowed_types[var]
        type_b = other.narrowed_types[var]

        if type_a && type_b
          if type_a == type_b
            merged.narrow(var, type_a)
          else
            merged.narrow(var, "#{type_a} | #{type_b}")
          end
        elsif type_a || type_b
          merged.narrow(var, type_a || type_b)
        end
      end

      merged
    end
  end

  # Main type checker with SMT solver integration
  class TypeChecker
    attr_reader :errors, :warnings, :hierarchy, :inferencer, :smt_solver, :use_smt

    def initialize(use_smt: true)
      @errors = []
      @warnings = []
      @hierarchy = TypeHierarchy.new
      @inferencer = TypeInferencer.new
      @function_signatures = {}
      @type_aliases = {}
      @current_scope = TypeScope.new
      @flow_context = FlowContext.new
      @use_smt = use_smt
      @smt_solver = SMT::ConstraintSolver.new if use_smt
      @smt_inference_engine = SMT::TypeInferenceEngine.new if use_smt
    end

    # Check an IR program using SMT-based type checking
    def check_program(ir_program)
      return check_program_legacy(ir_program) unless @use_smt

      @errors = []
      @warnings = []

      ir_program.declarations.each do |decl|
        case decl
        when IR::TypeAlias
          register_alias(decl.name, decl.definition)
        when IR::Interface
          check_interface(decl)
        when IR::MethodDef
          check_method_with_smt(decl)
        end
      end

      {
        success: @errors.empty?,
        errors: @errors,
        warnings: @warnings,
      }
    end

    # Check a method definition using SMT solver
    def check_method_with_smt(method_ir)
      result = @smt_inference_engine.infer_method(method_ir)

      if result[:success]
        # Store inferred types
        @function_signatures[method_ir.name] = {
          params: method_ir.params.map do |p|
            {
              name: p.name,
              type: result[:params][p.name] || infer_param_type(p),
            }
          end,
          return_type: result[:return_type],
        }
      else
        # Add errors from SMT solver
        result[:errors]&.each do |error|
          add_error(
            message: "Type inference error in #{method_ir.name}: #{error}",
            location: method_ir.location
          )
        end
      end

      result
    end

    # Check interface implementation
    def check_interface(interface_ir)
      interface_ir.members.each do |member|
        # Validate member type signature
        if member.type_signature
          validate_type(member.type_signature)
        end
      end
    end

    # Validate a type node is well-formed
    def validate_type(type_node)
      case type_node
      when IR::SimpleType
        # Check if type exists
        unless known_type?(type_node.name)
          add_warning("Unknown type: #{type_node.name}")
        end
      when IR::GenericType
        # Check base type and type args
        unless known_type?(type_node.base)
          add_warning("Unknown generic type: #{type_node.base}")
        end
        type_node.type_args.each { |t| validate_type(t) }
      when IR::UnionType
        type_node.types.each { |t| validate_type(t) }
      when IR::IntersectionType
        type_node.types.each { |t| validate_type(t) }
      when IR::NullableType
        validate_type(type_node.inner_type)
      when IR::FunctionType
        type_node.param_types.each { |t| validate_type(t) }
        validate_type(type_node.return_type)
      end
    end

    # SMT-based subtype checking
    def subtype_with_smt?(subtype, supertype)
      return true if subtype == supertype

      if @use_smt
        sub = to_smt_type(subtype)
        sup = to_smt_type(supertype)
        @smt_solver.subtype?(sub, sup)
      else
        @hierarchy.subtype_of?(subtype.to_s, supertype.to_s)
      end
    end

    # Convert to SMT type
    def to_smt_type(type)
      case type
      when String
        SMT::ConcreteType.new(type)
      when IR::SimpleType
        SMT::ConcreteType.new(type.name)
      when SMT::ConcreteType, SMT::TypeVar
        type
      else
        SMT::ConcreteType.new(type.to_s)
      end
    end

    # Register a function signature
    def register_function(name, params:, return_type:)
      @function_signatures[name] = {
        params: params,
        return_type: return_type,
      }
    end

    # Register a type alias
    def register_alias(name, definition)
      @type_aliases[name] = definition
    end

    # Check a function call
    def check_call(function_name, arguments, location: nil)
      signature = @function_signatures[function_name]

      unless signature
        add_warning("Unknown function: #{function_name}", location)
        return nil
      end

      params = signature[:params]

      # Check argument count
      if arguments.length != params.length
        add_error(
          message: "Wrong number of arguments for #{function_name}",
          expected: "#{params.length} arguments",
          actual: "#{arguments.length} arguments",
          location: location
        )
        return nil
      end

      # Check each argument type
      params.each_with_index do |param, idx|
        next unless param[:type]

        arg = arguments[idx]
        arg_type = infer_type(arg)

        next unless arg_type

        next if type_compatible?(arg_type, param[:type])

        add_error(
          message: "Type mismatch in argument '#{param[:name]}' of #{function_name}",
          expected: param[:type],
          actual: arg_type,
          suggestion: suggest_conversion(arg_type, param[:type]),
          location: location
        )
      end

      signature[:return_type]
    end

    # Check a return statement
    def check_return(value, expected_type, location: nil)
      return true unless expected_type

      actual_type = infer_type(value)
      return true unless actual_type

      unless type_compatible?(actual_type, expected_type)
        add_error(
          message: "Return type mismatch",
          expected: expected_type,
          actual: actual_type,
          suggestion: suggest_conversion(actual_type, expected_type),
          location: location
        )
        return false
      end

      true
    end

    # Check variable assignment
    def check_assignment(variable, value, declared_type: nil, location: nil)
      value_type = infer_type(value)

      if declared_type && !type_compatible?(value_type, declared_type)
        add_error(
          message: "Cannot assign #{value_type} to variable of type #{declared_type}",
          expected: declared_type,
          actual: value_type,
          location: location
        )
        return false
      end

      @current_scope.define(variable, declared_type || value_type)
      true
    end

    # Check property access
    def check_property_access(receiver_type, property_name, location: nil)
      # Known properties for common types
      known_properties = {
        "String" => %w[length size empty? chars bytes],
        "Array" => %w[length size first last empty? count],
        "Hash" => %w[keys values size empty? length],
        "Integer" => %w[abs to_s to_f even? odd? positive? negative?],
        "Float" => %w[abs to_s to_i ceil floor round],
      }

      properties = known_properties[receiver_type]
      return nil unless properties

      unless properties.include?(property_name)
        add_warning("Property '#{property_name}' may not exist on type #{receiver_type}", location)
      end

      # Return expected type for known properties
      infer_property_type(receiver_type, property_name)
    end

    # Check operator usage
    def check_operator(left_type, operator, right_type, location: nil)
      # Arithmetic operators
      if %w[+ - * / %].include?(operator)
        if left_type == "String" && operator == "+"
          unless right_type == "String"
            add_error(
              message: "Cannot concatenate String with #{right_type}",
              expected: "String",
              actual: right_type,
              suggestion: "Use .to_s to convert to String",
              location: location
            )
          end
          return "String"
        end

        unless numeric_type?(left_type) && numeric_type?(right_type)
          add_error(
            message: "Operator '#{operator}' requires numeric operands",
            expected: "Numeric",
            actual: "#{left_type} #{operator} #{right_type}",
            location: location
          )
          return nil
        end

        # Result type depends on operands
        return "Float" if left_type == "Float" || right_type == "Float"

        return "Integer"
      end

      # Comparison operators
      if %w[== != < > <= >=].include?(operator)
        return "Boolean"
      end

      # Logical operators
      if %w[&& ||].include?(operator)
        return right_type # Short-circuit returns right operand type
      end

      nil
    end

    # Handle conditional type narrowing
    def narrow_in_conditional(condition, then_scope, else_scope = nil)
      # Parse type guards from condition
      if condition.match?(/(\\w+)\\.is_a\\?\\((\\w+)\\)/)
        match = condition.match(/(\\w+)\\.is_a\\?\\((\\w+)\\)/)
        var = match[1]
        type = match[2]

        # In then branch, variable is narrowed to the type
        then_scope.narrow(var, type)

        # In else branch, variable is NOT that type (can't narrow further without more info)
      end

      if condition.match?(/(\\w+)\\.nil\\?/)
        match = condition.match(/(\\w+)\\.nil\\?/)
        var = match[1]

        then_scope.narrow(var, "nil")
        # In else branch, variable is not nil
        else_scope&.narrow(var, remove_nil_from_type(@current_scope.lookup(var) || "Object"))
      end

      return unless condition.match?(/!(\\w+)\\.nil\\?/)

      match = condition.match(/!(\\w+)\\.nil\\?/)
      var = match[1]

      # Variable is not nil in then branch
      then_scope.narrow(var, remove_nil_from_type(@current_scope.lookup(var) || "Object"))
      else_scope&.narrow(var, "nil")
    end

    # Check a complete function
    def check_function(function_info, body_lines)
      @current_scope = TypeScope.new

      # Register parameters in scope
      function_info[:params].each do |param|
        @current_scope.define(param[:name], param[:type] || "Object")
      end

      # Register function signature
      register_function(
        function_info[:name],
        params: function_info[:params],
        return_type: function_info[:return_type]
      )

      # Check body (simplified - real implementation would parse AST)
      body_lines.each_with_index do |line, idx|
        check_statement(line, location: "line #{idx + 1}")
      end
    end

    # Check a statement
    def check_statement(line, location: nil)
      line = line.strip

      # Return statement
      if line.match?(/^return\\s+(.+)/)
        line.match(/^return\\s+(.+)/)
        # Would need current function context for proper checking
        return
      end

      # Assignment
      if line.match?(/^(\\w+)\\s*=\\s*(.+)/)
        match = line.match(/^(\\w+)\\s*=\\s*(.+)/)
        check_assignment(match[1], match[2], location: location)
        return
      end

      # Method call
      if line.match?(/(\\w+)\\(([^)]*)\\)/)
        match = line.match(/(\\w+)\\(([^)]*)\\)/)
        args = match[2].split(",").map(&:strip)
        check_call(match[1], args, location: location)
      end
    end

    # Resolve type alias
    def resolve_type(type_name)
      @type_aliases[type_name] || type_name
    end

    # Clear all state
    def reset
      @errors.clear
      @warnings.clear
      @function_signatures.clear
      @type_aliases.clear
      @current_scope = TypeScope.new
      @flow_context = FlowContext.new
      @smt_solver = SMT::ConstraintSolver.new if @use_smt
      @smt_inference_engine = SMT::TypeInferenceEngine.new if @use_smt
    end

    # Get all diagnostics
    def diagnostics
      @errors.map { |e| e.respond_to?(:to_diagnostic) ? e.to_diagnostic : { type: :error, message: e.to_s } } +
        @warnings.map { |w| { type: :warning, message: w } }
    end

    # Check if a type name is known
    def known_type?(type_name)
      return true if %w[String Integer Float Boolean Array Hash Symbol void nil Object Numeric
                        Enumerable].include?(type_name)
      return true if @type_aliases.key?(type_name)

      false
    end

    # Infer parameter type from annotation
    def infer_param_type(param)
      if param.type_annotation
        case param.type_annotation
        when IR::SimpleType
          param.type_annotation.name
        else
          param.type_annotation.to_s
        end
      else
        "Object"
      end
    end

    # Legacy program check (without SMT)
    def check_program_legacy(ir_program)
      @errors = []
      @warnings = []

      ir_program.declarations.each do |decl|
        case decl
        when IR::TypeAlias
          register_alias(decl.name, decl.definition)
        when IR::Interface
          check_interface(decl)
        when IR::MethodDef
          check_function_legacy(decl)
        end
      end

      {
        success: @errors.empty?,
        errors: @errors,
        warnings: @warnings,
      }
    end

    # Check function without SMT (legacy)
    def check_function_legacy(method_ir)
      @current_scope = TypeScope.new

      # Register parameters
      method_ir.params.each do |param|
        param_type = infer_param_type(param)
        @current_scope.define(param.name, param_type)
      end

      # Register function signature
      register_function(
        method_ir.name,
        params: method_ir.params.map { |p| { name: p.name, type: infer_param_type(p) } },
        return_type: method_ir.return_type&.to_s || "Object"
      )
    end

    private

    def add_error(message:, expected: nil, actual: nil, suggestion: nil, location: nil)
      @errors << TypeCheckError.new(
        message: message,
        expected: expected,
        actual: actual,
        suggestion: suggestion,
        location: location
      )
    end

    def add_warning(message, location = nil)
      full_message = location ? "#{message} at #{location}" : message
      @warnings << full_message
    end

    def infer_type(expression)
      result = @inferencer.infer_expression_type(expression)
      result&.type
    end

    def type_compatible?(actual, expected)
      return true if actual.nil? || expected.nil?

      actual = resolve_type(actual)
      expected = resolve_type(expected)

      return true if actual == expected

      # Handle union types in expected
      if expected.include?("|")
        types = expected.split("|").map(&:strip)
        return types.any? { |t| type_compatible?(actual, t) }
      end

      # Handle union types in actual
      if actual.include?("|")
        types = actual.split("|").map(&:strip)
        return types.all? { |t| type_compatible?(t, expected) }
      end

      # Check hierarchy
      @hierarchy.subtype_of?(actual, expected)
    end

    def numeric_type?(type)
      %w[Integer Float Numeric].include?(type)
    end

    def suggest_conversion(from_type, to_type)
      conversions = {
        %w[Integer String] => "Use .to_s to convert to String",
        %w[Float String] => "Use .to_s to convert to String",
        %w[String Integer] => "Use .to_i to convert to Integer",
        %w[String Float] => "Use .to_f to convert to Float",
        %w[Integer Float] => "Use .to_f to convert to Float",
        %w[Float Integer] => "Use .to_i to convert to Integer (may lose precision)",
        %w[Symbol String] => "Use .to_s to convert to String",
        %w[String Symbol] => "Use .to_sym to convert to Symbol",
      }

      conversions[[from_type, to_type]]
    end

    def infer_property_type(receiver_type, property)
      property_types = {
        %w[String length] => "Integer",
        %w[String size] => "Integer",
        ["String", "empty?"] => "Boolean",
        %w[String chars] => "Array<String>",
        %w[Array length] => "Integer",
        %w[Array size] => "Integer",
        ["Array", "empty?"] => "Boolean",
        %w[Array first] => nil, # Depends on element type
        %w[Array last] => nil,
        %w[Hash keys] => "Array",
        %w[Hash values] => "Array",
        %w[Hash size] => "Integer",
        %w[Integer abs] => "Integer",
        %w[Integer to_s] => "String",
        %w[Float abs] => "Float",
        %w[Float to_i] => "Integer",
      }

      property_types[[receiver_type, property]]
    end

    def remove_nil_from_type(type)
      return "Object" if type == "nil"

      if type.include?("|")
        types = type.split("|").map(&:strip).reject { |t| t == "nil" }
        return types.length == 1 ? types.first : types.join(" | ")
      end

      type
    end
  end

  # Legacy TypeChecker without SMT (backward compatible)
  class LegacyTypeChecker < TypeChecker
    def initialize
      super(use_smt: false)
    end
  end

  # SMT-enhanced type checker with constraint solving
  class SMTTypeChecker < TypeChecker
    include SMT::DSL

    def initialize
      super(use_smt: true)
    end

    # Add constraint-based type check
    def check_with_constraints(ir_program, &block)
      # Allow users to add custom constraints
      block.call(@smt_solver) if block_given?

      # Run standard type checking
      check_program(ir_program)
    end

    # Solve current constraints and return solution
    def solve_constraints
      @smt_solver.solve
    end

    # Get inferred type for a variable
    def inferred_type(var_name)
      @smt_solver.infer(SMT::TypeVar.new(var_name))
    end
  end
end
`,
  "lib/t_ruby/type_env.rb": `# frozen_string_literal: true

module TRuby
  # TypeEnv - 타입 환경 (스코프 체인)
  # TypeScript의 Checker에서 심볼 타입을 추적하는 방식을 참고
  class TypeEnv
    attr_reader :parent, :bindings, :instance_vars

    def initialize(parent = nil)
      @parent = parent
      @bindings = {}      # 지역 변수 { name => type }
      @instance_vars = {} # 인스턴스 변수 { name => type }
      @class_vars = {}    # 클래스 변수 { name => type }
    end

    # 지역 변수 타입 정의
    # @param name [String] 변수 이름
    # @param type [IR::TypeNode, String] 타입
    def define(name, type)
      @bindings[name] = type
    end

    # 변수 타입 조회 (스코프 체인 탐색)
    # @param name [String] 변수 이름
    # @return [IR::TypeNode, String, nil] 타입 또는 nil
    def lookup(name)
      # 인스턴스 변수
      if name.start_with?("@") && !name.start_with?("@@")
        return lookup_instance_var(name)
      end

      # 클래스 변수
      if name.start_with?("@@")
        return lookup_class_var(name)
      end

      # 지역 변수 또는 메서드 파라미터
      return @bindings[name] if @bindings.key?(name)

      # 부모 스코프에서 검색
      @parent&.lookup(name)
    end

    # 인스턴스 변수 타입 정의
    # @param name [String] 변수 이름 (@포함)
    # @param type [IR::TypeNode, String] 타입
    def define_instance_var(name, type)
      # @ 접두사 정규화
      normalized = name.start_with?("@") ? name : "@#{name}"
      @instance_vars[normalized] = type
    end

    # 인스턴스 변수 타입 조회
    # @param name [String] 변수 이름 (@포함)
    # @return [IR::TypeNode, String, nil] 타입 또는 nil
    def lookup_instance_var(name)
      normalized = name.start_with?("@") ? name : "@#{name}"
      return @instance_vars[normalized] if @instance_vars.key?(normalized)

      @parent&.lookup_instance_var(normalized)
    end

    # 클래스 변수 타입 정의
    # @param name [String] 변수 이름 (@@포함)
    # @param type [IR::TypeNode, String] 타입
    def define_class_var(name, type)
      normalized = name.start_with?("@@") ? name : "@@#{name}"
      @class_vars[normalized] = type
    end

    # 클래스 변수 타입 조회
    # @param name [String] 변수 이름 (@@포함)
    # @return [IR::TypeNode, String, nil] 타입 또는 nil
    def lookup_class_var(name)
      normalized = name.start_with?("@@") ? name : "@@#{name}"
      return @class_vars[normalized] if @class_vars.key?(normalized)

      @parent&.lookup_class_var(normalized)
    end

    # 자식 스코프 생성 (블록, 람다 등)
    # @return [TypeEnv] 새 자식 스코프
    def child_scope
      TypeEnv.new(self)
    end

    # 현재 스코프에서 정의된 모든 변수 이름
    # @return [Array<String>] 변수 이름 배열
    def local_names
      @bindings.keys
    end

    # 현재 스코프에서 정의된 모든 인스턴스 변수 이름
    # @return [Array<String>] 인스턴스 변수 이름 배열
    def instance_var_names
      @instance_vars.keys
    end

    # 변수가 현재 스코프에 정의되어 있는지 확인
    # @param name [String] 변수 이름
    # @return [Boolean]
    def defined_locally?(name)
      @bindings.key?(name)
    end

    # 스코프 깊이 (디버깅용)
    # @return [Integer] 스코프 깊이
    def depth
      @parent ? @parent.depth + 1 : 0
    end

    # 스코프 체인에서 모든 변수 수집
    # @return [Hash] 모든 변수의 { name => type }
    def all_bindings
      parent_bindings = @parent ? @parent.all_bindings : {}
      parent_bindings.merge(@bindings)
    end

    # 디버그 출력
    def to_s
      parts = ["TypeEnv(depth=#{depth})"]
      parts << "  locals: #{@bindings.keys.join(", ")}" if @bindings.any?
      parts << "  ivars: #{@instance_vars.keys.join(", ")}" if @instance_vars.any?
      parts.join("\\n")
    end
  end
end
`,
  "lib/t_ruby/type_erasure.rb": `# frozen_string_literal: true

module TRuby
  class TypeErasure
    def initialize(source)
      @source = source
    end

    def erase
      result = @source.dup

      # Remove type alias definitions: type AliasName = TypeDefinition
      result = result.gsub(/^\\s*type\\s+\\w+\\s*=\\s*.+?$\\n?/, "")

      # Remove parameter type annotations: (name: Type) -> (name)
      # Matches: parameter_name: TypeName
      result = result.gsub(/\\b(\\w+)\\s*:\\s*\\w+/, '\\1')

      # Remove return type annotations: ): TypeName -> )
      # Matches: ): TypeName or ): TypeName (with spaces/EOF)
      result.gsub(/\\)\\s*:\\s*\\w+(\\s|$)/, ')\\1')
    end
  end
end
`,
  "lib/t_ruby/type_inferencer.rb": `# frozen_string_literal: true

module TRuby
  # Represents an inferred type with confidence score
  class InferredType
    attr_reader :type, :confidence, :source, :location

    # Confidence levels
    HIGH = 1.0
    MEDIUM = 0.7
    LOW = 0.4

    def initialize(type:, confidence: HIGH, source: :unknown, location: nil)
      @type = type
      @confidence = confidence
      @source = source
      @location = location
    end

    def to_s
      @type
    end

    def high_confidence?
      @confidence >= HIGH
    end

    def medium_confidence?
      @confidence >= MEDIUM && @confidence < HIGH
    end

    def low_confidence?
      @confidence < MEDIUM
    end
  end

  # Type inference engine
  class TypeInferencer
    attr_reader :inferred_types, :warnings

    # Literal type patterns
    LITERAL_PATTERNS = {
      # String literals
      /^".*"$/ => "String",
      /^'.*'$/ => "String",
      # Integer literals
      /^-?\\d+$/ => "Integer",
      /^0x[0-9a-fA-F]+$/ => "Integer",
      /^0b[01]+$/ => "Integer",
      /^0o[0-7]+$/ => "Integer",
      # Float literals
      /^-?\\d+\\.\\d+$/ => "Float",
      /^-?\\d+e[+-]?\\d+$/i => "Float",
      # Boolean literals
      /^true$/ => "Boolean",
      /^false$/ => "Boolean",
      # Nil literal
      /^nil$/ => "nil",
      # Symbol literals
      /^:\\w+$/ => "Symbol",
      # Array literals
      /^\\[.*\\]$/ => "Array",
      # Hash literals
      /^\\{.*\\}$/ => "Hash",
      # Regex literals
      %r{^/.*/$} => "Regexp",
    }.freeze

    # Method return type patterns
    METHOD_RETURN_TYPES = {
      # String methods
      "to_s" => "String",
      "upcase" => "String",
      "downcase" => "String",
      "strip" => "String",
      "chomp" => "String",
      "reverse" => "String",
      "capitalize" => "String",
      "gsub" => "String",
      "sub" => "String",
      "chars" => "Array<String>",
      "split" => "Array<String>",
      "lines" => "Array<String>",
      "bytes" => "Array<Integer>",
      # Integer/Numeric methods
      "to_i" => "Integer",
      "to_int" => "Integer",
      "abs" => "Integer",
      "ceil" => "Integer",
      "floor" => "Integer",
      "round" => "Integer",
      "to_f" => "Float",
      # Array methods
      "length" => "Integer",
      "size" => "Integer",
      "count" => "Integer",
      "first" => nil, # Depends on array type
      "last" => nil,
      "empty?" => "Boolean",
      "any?" => "Boolean",
      "all?" => "Boolean",
      "none?" => "Boolean",
      "include?" => "Boolean",
      "compact" => nil,
      "flatten" => "Array",
      "uniq" => nil,
      "sort" => nil,
      "map" => "Array",
      "select" => "Array",
      "reject" => "Array",
      "reduce" => nil,
      # Hash methods
      "keys" => "Array",
      "values" => "Array",
      "merge" => "Hash",
      "key?" => "Boolean",
      "has_key?" => "Boolean",
      "value?" => "Boolean",
      "has_value?" => "Boolean",
      # Object methods
      "class" => "Class",
      "object_id" => "Integer",
      "hash" => "Integer",
      "frozen?" => "Boolean",
      "nil?" => "Boolean",
      "is_a?" => "Boolean",
      "kind_of?" => "Boolean",
      "instance_of?" => "Boolean",
      "respond_to?" => "Boolean",
      "eql?" => "Boolean",
      "equal?" => "Boolean",
      "inspect" => "String",
      "dup" => nil,
      "clone" => nil,
    }.freeze

    # Operator return types
    OPERATOR_TYPES = {
      # Arithmetic
      "+" => :numeric_or_string,
      "-" => :numeric,
      "*" => :numeric_or_string,
      "/" => :numeric,
      "%" => :numeric,
      "**" => :numeric,
      # Comparison
      "==" => "Boolean",
      "!=" => "Boolean",
      "<" => "Boolean",
      ">" => "Boolean",
      "<=" => "Boolean",
      ">=" => "Boolean",
      "<=>" => "Integer",
      # Logical
      "&&" => :propagate,
      "||" => :propagate,
      "!" => "Boolean",
      # Bitwise
      "&" => "Integer",
      "|" => "Integer",
      "^" => "Integer",
      "~" => "Integer",
      "<<" => "Integer",
      ">>" => "Integer",
    }.freeze

    def initialize
      @inferred_types = {}
      @warnings = []
      @function_contexts = {}
      @variable_types = {}
    end

    # Infer type from a literal expression
    def infer_literal(expression)
      expr = expression.to_s.strip

      LITERAL_PATTERNS.each do |pattern, type|
        if expr.match?(pattern)
          return InferredType.new(
            type: type,
            confidence: InferredType::HIGH,
            source: :literal
          )
        end
      end

      nil
    end

    # Infer type from method call
    def infer_method_call(receiver_type, method_name)
      return_type = METHOD_RETURN_TYPES[method_name.to_s]

      if return_type
        return InferredType.new(
          type: return_type,
          confidence: InferredType::HIGH,
          source: :method_call
        )
      end

      # Try to infer from receiver type and method
      inferred = infer_from_receiver(receiver_type, method_name)
      return inferred if inferred

      nil
    end

    # Infer return type from function body
    def infer_return_type(function_body)
      return_statements = extract_return_statements(function_body)

      if return_statements.empty?
        # Implicit nil return
        return InferredType.new(
          type: "nil",
          confidence: InferredType::MEDIUM,
          source: :implicit_return
        )
      end

      types = return_statements.map do |stmt|
        infer_expression_type(stmt[:value])
      end.compact

      if types.empty?
        return nil
      end

      if types.uniq.length == 1
        # All returns have same type
        return InferredType.new(
          type: types.first.type,
          confidence: InferredType::HIGH,
          source: :return_analysis
        )
      end

      # Multiple return types - create union
      unique_types = types.map(&:type).uniq
      union_type = unique_types.join(" | ")

      InferredType.new(
        type: union_type,
        confidence: InferredType::MEDIUM,
        source: :return_analysis
      )
    end

    # Infer parameter types from usage patterns
    def infer_parameter_types(function_body, parameters)
      inferred_params = {}

      parameters.each do |param|
        param_name = param[:name]
        usages = find_parameter_usages(function_body, param_name)
        inferred_type = infer_from_usages(usages)

        if inferred_type
          inferred_params[param_name] = inferred_type
        end
      end

      inferred_params
    end

    # Infer generic type parameters
    def infer_generic_params(call_arguments, function_params)
      generic_bindings = {}

      function_params.each_with_index do |param, idx|
        next unless param[:type]&.include?("<")
        next unless call_arguments[idx]

        arg_type = infer_expression_type(call_arguments[idx])
        next unless arg_type

        # Extract generic parameter from function param type
        next unless param[:type].match?(/^(\\w+)<(\\w+)>$/)

        match = param[:type].match(/^(\\w+)<(\\w+)>$/)
        generic_name = match[2]

        # If arg type is concrete, bind it
        if arg_type.type.match?(/^(\\w+)<(\\w+)>$/)
          arg_match = arg_type.type.match(/^(\\w+)<(\\w+)>$/)
          generic_bindings[generic_name] = arg_match[2]
        end
      end

      generic_bindings
    end

    # Infer type narrowing in conditionals
    def infer_narrowed_type(variable, condition)
      # Type guard patterns
      if condition.match?(/#{variable}\\.is_a\\?\\((\\w+)\\)/)
        match = condition.match(/#{variable}\\.is_a\\?\\((\\w+)\\)/)
        return InferredType.new(
          type: match[1],
          confidence: InferredType::HIGH,
          source: :type_guard
        )
      end

      if condition.match?(/#{variable}\\.nil\\?/)
        return InferredType.new(
          type: "nil",
          confidence: InferredType::HIGH,
          source: :nil_check
        )
      end

      if condition.match?(/#{variable}\\.respond_to\\?\\(:(\\w+)\\)/)
        # Can't determine exact type, but know it has the method
        return nil
      end

      nil
    end

    # Infer type of an expression
    def infer_expression_type(expression)
      expr = expression.to_s.strip

      # Try literal inference first
      literal_type = infer_literal(expr)
      return literal_type if literal_type

      # Method call inference
      if expr.match?(/\\.(\\w+)(?:\\(.*\\))?$/)
        match = expr.match(/(.+)\\.(\\w+)(?:\\(.*\\))?$/)
        if match
          receiver = match[1]
          method = match[2]
          receiver_type = infer_expression_type(receiver)
          return infer_method_call(receiver_type&.type, method)
        end
      end

      # Variable reference - check recorded types
      if @variable_types[expr]
        return @variable_types[expr]
      end

      # Operator inference
      OPERATOR_TYPES.each do |op, result_type|
        if expr.include?(" #{op} ")
          return infer_operator_result(expr, op, result_type)
        end
      end

      # Array construction
      if expr.start_with?("[") && expr.end_with?("]")
        return infer_array_type(expr)
      end

      # Hash construction
      if expr.start_with?("{") && expr.end_with?("}")
        return InferredType.new(
          type: "Hash",
          confidence: InferredType::HIGH,
          source: :literal
        )
      end

      nil
    end

    # Record a variable's type for later inference
    def record_variable_type(name, type)
      @variable_types[name] = type
    end

    # Get recorded variable type
    def get_variable_type(name)
      @variable_types[name]
    end

    # Add a warning about ambiguous inference
    def add_warning(message, location: nil)
      @warnings << { message: message, location: location }
    end

    # Clear all state
    def reset
      @inferred_types.clear
      @warnings.clear
      @function_contexts.clear
      @variable_types.clear
    end

    private

    def extract_return_statements(body)
      statements = []
      lines = body.split("\\n")

      lines.each_with_index do |line, idx|
        # Explicit return
        if line.match?(/^\\s*return\\s+(.+)/)
          match = line.match(/^\\s*return\\s+(.+)/)
          statements << { type: :explicit, value: match[1].strip, line: idx + 1 }
        end

        # Last expression (implicit return)
        # This is simplified - real implementation would need full parsing
      end

      statements
    end

    def find_parameter_usages(body, param_name)
      usages = []
      lines = body.split("\\n")

      lines.each_with_index do |line, idx|
        # Method call on parameter
        if line.match?(/#{param_name}\\.(\\w+)/)
          matches = line.scan(/#{param_name}\\.(\\w+)/)
          matches.each do |match|
            usages << { type: :method_call, method: match[0], line: idx + 1 }
          end
        end

        # Arithmetic operation
        if line.match?(%r{#{param_name}\\s*[+\\-*/%]})
          usages << { type: :arithmetic, line: idx + 1 }
        end

        # Comparison
        if line.match?(/#{param_name}\\s*[<>=!]=?/)
          usages << { type: :comparison, line: idx + 1 }
        end

        # String interpolation
        if line.match?(/#\\{#{param_name}\\}/)
          usages << { type: :string_interpolation, line: idx + 1 }
        end
      end

      usages
    end

    def infer_from_usages(usages)
      return nil if usages.empty?

      type_hints = []

      usages.each do |usage|
        case usage[:type]
        when :arithmetic
          type_hints << "Numeric"
        when :method_call
          method_type = infer_type_from_method(usage[:method])
          type_hints << method_type if method_type
        when :string_interpolation
          # Could be any type (calls to_s)
        when :comparison
          # Most types support comparison
        end
      end

      return nil if type_hints.empty?

      # Find most specific type
      most_common = type_hints.group_by(&:itself)
                              .max_by { |_, v| v.length }
                              &.first

      return unless most_common

      InferredType.new(
        type: most_common,
        confidence: InferredType::MEDIUM,
        source: :usage_analysis
      )
    end

    def infer_type_from_method(method_name)
      # Methods that suggest String type
      string_methods = %w[upcase downcase strip chomp split chars]
      return "String" if string_methods.include?(method_name)

      # Methods that suggest Array type
      array_methods = %w[each map select reject push pop shift unshift first last]
      return "Array" if array_methods.include?(method_name)

      # Methods that suggest Hash type
      hash_methods = %w[keys values merge fetch]
      return "Hash" if hash_methods.include?(method_name)

      # Methods that suggest Numeric type
      numeric_methods = %w[abs ceil floor round to_i to_f times upto downto]
      return "Numeric" if numeric_methods.include?(method_name)

      nil
    end

    def infer_from_receiver(receiver_type, method_name)
      return nil unless receiver_type

      case receiver_type
      when "String"
        case method_name.to_s
        when "length", "size" then "Integer"
        when "chars", "split", "lines" then "Array<String>"
        when /^[a-z]/ then "String" # Most String methods return String
        end
      when "Array"
        case method_name.to_s
        when "length", "size", "count" then "Integer"
        when "first", "last" then nil # Depends on element type
        when "join" then "String"
        end
      when "Integer", "Float", "Numeric"
        case method_name.to_s
        when "to_s" then "String"
        when "to_i" then "Integer"
        when "to_f" then "Float"
        when "abs", "ceil", "floor" then receiver_type
        end
      end
    end

    def infer_operator_result(_expr, _operator, result_type)
      case result_type
      when "Boolean"
        InferredType.new(type: "Boolean", confidence: InferredType::HIGH, source: :operator)
      when "Integer"
        InferredType.new(type: "Integer", confidence: InferredType::HIGH, source: :operator)
      when :numeric
        # Check operand types
        InferredType.new(type: "Numeric", confidence: InferredType::MEDIUM, source: :operator)
      when :numeric_or_string
        # Could be numeric or string concatenation
        InferredType.new(type: "Numeric | String", confidence: InferredType::LOW, source: :operator)
      when :propagate
        # Type propagates from operands
        nil
      end
    end

    def infer_array_type(expr)
      # Remove brackets
      content = expr[1..-2].strip
      return InferredType.new(type: "Array", confidence: InferredType::HIGH, source: :literal) if content.empty?

      # Try to infer element types
      elements = split_array_elements(content)
      element_types = elements.map { |e| infer_expression_type(e)&.type }.compact.uniq

      if element_types.length == 1
        InferredType.new(
          type: "Array<#{element_types.first}>",
          confidence: InferredType::HIGH,
          source: :literal
        )
      elsif element_types.length > 1
        InferredType.new(
          type: "Array<#{element_types.join(" | ")}>",
          confidence: InferredType::MEDIUM,
          source: :literal
        )
      else
        InferredType.new(type: "Array", confidence: InferredType::HIGH, source: :literal)
      end
    end

    def split_array_elements(content)
      # Simple split by comma (doesn't handle nested structures well)
      content.split(",").map(&:strip)
    end
  end
end
`,
  "lib/t_ruby/union_type_parser.rb": `# frozen_string_literal: true

module TRuby
  class UnionTypeParser
    def initialize(type_string)
      @type_string = type_string.strip
    end

    def parse
      # Check if it contains pipes (union indicator)
      if @type_string.include?("|")
        parse_union
      else
        parse_simple
      end
    end

    private

    def parse_union
      members = @type_string.split("|").map(&:strip).compact

      {
        type: :union,
        members: members,
        has_duplicates: members.length != members.uniq.length,
        unique_members: members.uniq,
      }
    end

    def parse_simple
      {
        type: :simple,
        value: @type_string,
      }
    end
  end
end
`,
  "lib/t_ruby/version.rb": `# frozen_string_literal: true

module TRuby
  VERSION = "0.0.46"
end
`,
  "lib/t_ruby/version_checker.rb": `# frozen_string_literal: true

require "net/http"
require "json"
require "uri"
require "openssl"

module TRuby
  class VersionChecker
    GEM_NAME = "t-ruby"
    RUBYGEMS_API = "https://rubygems.org/api/v1/gems/#{GEM_NAME}.json".freeze

    def self.check
      new.check
    end

    def self.update
      new.update
    end

    def check
      latest = fetch_latest_version
      return nil unless latest

      current = Gem::Version.new(VERSION)
      latest_version = Gem::Version.new(latest)

      return nil if current >= latest_version

      { current: VERSION, latest: latest }
    end

    def update
      system("gem install #{GEM_NAME}")
    end

    private

    def fetch_latest_version
      uri = URI(RUBYGEMS_API)

      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true
      http.verify_mode = OpenSSL::SSL::VERIFY_PEER
      http.verify_callback = ->(_preverify_ok, _store_ctx) { true } # Skip CRL check
      http.open_timeout = 3
      http.read_timeout = 3

      request = Net::HTTP::Get.new(uri)
      response = http.request(request)

      return nil unless response.is_a?(Net::HTTPSuccess)

      data = JSON.parse(response.body)
      data["version"]
    rescue StandardError
      nil
    end
  end
end
`,
  "lib/t_ruby/watcher.rb": `# frozen_string_literal: true

# listen gem is optional - only required for watch mode
# This allows T-Ruby core functionality to work on Ruby 4.0+ where listen/ffi may not be available
begin
  require "listen"
  LISTEN_AVAILABLE = true
rescue LoadError
  LISTEN_AVAILABLE = false
end

module TRuby
  class Watcher
    # ANSI color codes (similar to tsc output style)
    COLORS = {
      reset: "\\e[0m",
      bold: "\\e[1m",
      dim: "\\e[2m",
      red: "\\e[31m",
      green: "\\e[32m",
      yellow: "\\e[33m",
      blue: "\\e[34m",
      cyan: "\\e[36m",
      gray: "\\e[90m",
    }.freeze

    attr_reader :incremental_compiler, :stats

    def initialize(paths: ["."], config: nil, incremental: true, cross_file_check: true, parallel: true)
      @paths = paths.map { |p| File.expand_path(p) }
      @config = config || Config.new
      @compiler = Compiler.new(@config)
      @error_count = 0
      @file_count = 0
      @use_colors = $stdout.tty?
      @file_diagnostics = {} # Cache diagnostics per file for incremental updates

      # Enhanced features
      @incremental = incremental
      @cross_file_check = cross_file_check
      @parallel = parallel

      # Initialize incremental compiler
      if @incremental
        @incremental_compiler = EnhancedIncrementalCompiler.new(
          @compiler,
          enable_cross_file: @cross_file_check
        )
      end

      # Parallel processor
      @parallel_processor = ParallelProcessor.new if @parallel

      # Statistics
      @stats = {
        total_compilations: 0,
        incremental_hits: 0,
        total_time: 0.0,
      }
    end

    def watch
      unless LISTEN_AVAILABLE
        puts colorize(:red, "Error: Watch mode requires the 'listen' gem.")
        puts colorize(:yellow, "The 'listen' gem is not available (possibly due to Ruby 4.0+ ffi compatibility).")
        puts colorize(:dim, "Install with: gem install listen")
        puts colorize(:dim, "Or run without watch mode: trc")
        exit 1
      end

      print_start_message

      # Initial compilation
      start_time = Time.now
      compile_all
      @stats[:total_time] += Time.now - start_time

      # Start watching (.trb and .rb files)
      listener = Listen.to(*watch_directories, only: /\\.(trb|rb)$/) do |modified, added, removed|
        handle_changes(modified, added, removed)
      end

      listener.start

      print_watching_message

      # Keep the process running
      begin
        sleep
      rescue Interrupt
        puts "\\n#{colorize(:dim, timestamp)} #{colorize(:cyan, "Stopping watch mode...")}"
        print_stats if @incremental
        listener.stop
      end
    end

    private

    def watch_directory(path)
      File.directory?(path) ? path : File.dirname(path)
    end

    def watch_directories
      if @paths == [File.expand_path(".")]
        # Default case: only watch source_include directories from config
        @config.source_include.map { |dir| File.expand_path(dir) }.select { |dir| Dir.exist?(dir) }
      else
        # Specific paths provided: watch those paths
        @paths.map { |path| watch_directory(path) }.uniq
      end
    end

    def handle_changes(modified, added, removed)
      changed_files = (modified + added)
                      .select { |f| f.end_with?(".trb") || f.end_with?(".rb") }
                      .reject { |f| @config.excluded?(f) }
      return if changed_files.empty? && removed.empty?

      puts
      print_file_change_message

      if removed.any?
        removed.each do |file|
          puts "#{colorize(:gray, timestamp)} #{colorize(:yellow, "File removed:")} #{relative_path(file)}"
          # Clear from incremental compiler cache
          @incremental_compiler&.file_hashes&.delete(file)
        end
      end

      if changed_files.any?
        start_time = Time.now
        compile_files_incremental(changed_files)
        @stats[:total_time] += Time.now - start_time
      else
        print_watching_message
      end
    end

    def compile_all
      @error_count = 0
      @file_count = 0
      @file_diagnostics = {} # Reset diagnostics cache on full compile

      trb_files = find_trb_files
      rb_files = find_rb_files
      all_files = trb_files + rb_files
      @file_count = all_files.size

      # Use unified compile_with_diagnostics for all files
      # Note: compile_file increments @stats[:total_compilations] internally
      all_files.each do |file|
        result = compile_file(file)
        # Cache diagnostics per file
        @file_diagnostics[file] = result[:diagnostics] || []
      end

      all_diagnostics = @file_diagnostics.values.flatten
      print_errors(all_diagnostics)
      print_summary
    end

    def compile_files_incremental(files)
      compiled_count = 0

      if @incremental
        files.each do |file|
          if @incremental_compiler.needs_compile?(file)
            @stats[:total_compilations] += 1
            result = compile_file_with_ir(file)
            # Update cached diagnostics for this file
            @file_diagnostics[file] = result[:diagnostics] || []
            compiled_count += 1
          else
            @stats[:incremental_hits] += 1
            puts "#{colorize(:gray, timestamp)} #{colorize(:dim, "Skipping unchanged:")} #{relative_path(file)}"
          end
        end

        # Run cross-file check if enabled
        if @cross_file_check && @incremental_compiler.cross_file_checker
          check_result = @incremental_compiler.cross_file_checker.check_all
          check_result[:errors].each do |e|
            # Add cross-file errors (these are not file-specific)
            @file_diagnostics[:cross_file] ||= []
            @file_diagnostics[:cross_file] << create_diagnostic_from_cross_file_error(e)
          end
        end
      else
        files.each do |file|
          result = compile_file(file)
          # Update cached diagnostics for this file
          @file_diagnostics[file] = result[:diagnostics] || []
          compiled_count += 1
        end
      end

      # Collect all diagnostics from cache (includes unchanged files' errors)
      all_diagnostics = @file_diagnostics.values.flatten

      # Update error count from all cached diagnostics
      @error_count = all_diagnostics.size

      @file_count = compiled_count
      print_errors(all_diagnostics)
      print_summary
      print_watching_message
    end

    def compile_file_with_ir(file)
      # Use unified compile_with_diagnostics from Compiler (same as compile_file)
      # This ensures incremental compile returns the same diagnostics as full compile
      compile_result = @compiler.compile_with_diagnostics(file)

      # Update incremental compiler's file hash to track changes
      @incremental_compiler&.update_file_hash(file)

      {
        file: file,
        diagnostics: compile_result[:diagnostics],
        success: compile_result[:success],
      }
    end

    def compile_file(file)
      # Use unified compile_with_diagnostics from Compiler
      compile_result = @compiler.compile_with_diagnostics(file)

      @error_count += compile_result[:diagnostics].size
      @stats[:total_compilations] += 1

      {
        file: file,
        diagnostics: compile_result[:diagnostics],
        success: compile_result[:success],
      }
    end

    def find_trb_files
      find_source_files_by_extension(".trb")
    end

    def find_rb_files
      find_source_files_by_extension(".rb")
    end

    def find_source_files_by_extension(ext)
      files = []

      # Always search in source_include directories only
      source_paths = if @paths == [File.expand_path(".")]
                       @config.source_include.map { |dir| File.expand_path(dir) }
                     else
                       @paths.map { |path| File.expand_path(path) }
                     end

      source_paths.each do |path|
        if File.file?(path)
          # Handle single file path
          files << path if path.end_with?(ext) && !@config.excluded?(path)
        elsif Dir.exist?(path)
          # Handle directory path
          Dir.glob(File.join(path, "**", "*#{ext}")).each do |file|
            files << file unless @config.excluded?(file)
          end
        end
      end

      files.uniq
    end

    # Create a Diagnostic for cross-file check errors
    def create_diagnostic_from_cross_file_error(error)
      file = error[:file]
      source = File.exist?(file) ? File.read(file) : nil
      create_generic_diagnostic(file, error[:message], source)
    end

    # Create a generic Diagnostic for standard errors
    def create_generic_diagnostic(file, message, source = nil)
      line = 1
      col = 1

      # Try to extract line info from error message
      if message =~ /line (\\d+)/i
        line = ::Regexp.last_match(1).to_i
      end

      source_line = source&.split("\\n")&.at(line - 1)

      Diagnostic.new(
        code: "TR0001",
        message: message,
        file: relative_path(file),
        line: line,
        column: col,
        source_line: source_line
      )
    end

    def print_errors(diagnostics)
      return if diagnostics.empty?

      formatter = DiagnosticFormatter.new(use_colors: @use_colors)
      diagnostics.each do |diagnostic|
        puts
        puts formatter.format(diagnostic)
      end
    end

    def print_start_message
      puts "#{colorize(:gray, timestamp)} #{colorize(:bold, "Starting compilation in watch mode...")}"
      puts
    end

    def print_file_change_message
      puts "#{colorize(:gray,
                       timestamp)} #{colorize(:bold, "File change detected. Starting incremental compilation...")}"
      puts
    end

    def print_summary
      puts
      if @error_count.zero?
        msg = "Found #{colorize(:green, "0 errors")}. Watching for file changes."
      else
        error_word = @error_count == 1 ? "error" : "errors"
        msg = "Found #{colorize(:red, "#{@error_count} #{error_word}")}. Watching for file changes."
      end
      puts "#{colorize(:gray, timestamp)} #{msg}"
    end

    def print_watching_message
      # Just print a blank line for readability
    end

    def print_stats
      puts
      puts "#{colorize(:gray, timestamp)} #{colorize(:bold, "Watch Mode Statistics:")}"
      puts "  Total compilations: #{@stats[:total_compilations]}"
      puts "  Incremental cache hits: #{@stats[:incremental_hits]}"
      total = @stats[:total_compilations] + @stats[:incremental_hits]
      hit_rate = if total.positive?
                   (@stats[:incremental_hits].to_f / total * 100).round(1)
                 else
                   0
                 end
      puts "  Cache hit rate: #{hit_rate}%"
      puts "  Total compile time: #{@stats[:total_time].round(2)}s"
    end

    def timestamp
      Time.now.strftime("[%I:%M:%S %p]")
    end

    def relative_path(file)
      file.sub("#{Dir.pwd}/", "")
    end

    def colorize(color, text)
      return text unless @use_colors
      return text unless COLORS[color]

      "#{COLORS[color]}#{text}#{COLORS[:reset]}"
    end
  end
end
`,
  "lib/t_ruby.rb": `# frozen_string_literal: true

require_relative "t_ruby/version"
require_relative "t_ruby/version_checker"
require_relative "t_ruby/ruby_version"
require_relative "t_ruby/code_emitter"
require_relative "t_ruby/config"

# Core infrastructure (must be loaded first)
require_relative "t_ruby/string_utils"
require_relative "t_ruby/ir"
require_relative "t_ruby/parser_combinator"
require_relative "t_ruby/scanner"
require_relative "t_ruby/smt_solver"

# Basic components
require_relative "t_ruby/type_alias_registry"
require_relative "t_ruby/heredoc_detector"
require_relative "t_ruby/parser"
require_relative "t_ruby/union_type_parser"
require_relative "t_ruby/generic_type_parser"
require_relative "t_ruby/intersection_type_parser"
require_relative "t_ruby/type_erasure"
require_relative "t_ruby/error_handler"
require_relative "t_ruby/diagnostic"
require_relative "t_ruby/diagnostic_formatter"
require_relative "t_ruby/error_reporter"
require_relative "t_ruby/declaration_generator"
require_relative "t_ruby/compiler"
require_relative "t_ruby/lsp_server"
require_relative "t_ruby/watcher"
require_relative "t_ruby/runner"
require_relative "t_ruby/cli"

# Milestone 4: Advanced Features
require_relative "t_ruby/constraint_checker"
require_relative "t_ruby/type_inferencer"
require_relative "t_ruby/runtime_validator"
require_relative "t_ruby/type_checker"
require_relative "t_ruby/type_env"
require_relative "t_ruby/ast_type_inferrer"
require_relative "t_ruby/cache"
require_relative "t_ruby/package_manager"

# Milestone 5: Bundler Integration
require_relative "t_ruby/bundler_integration"

# Milestone 6: Quality & Documentation
require_relative "t_ruby/benchmark"
require_relative "t_ruby/doc_generator"

# Milestone -7: Documentation Verification
require_relative "t_ruby/docs_example_extractor"
require_relative "t_ruby/docs_example_verifier"
require_relative "t_ruby/docs_badge_generator"

module TRuby
  # Parse error for T-Ruby source code
  class ParseError < StandardError
    attr_reader :line, :column, :source

    def initialize(message, line: nil, column: nil, source: nil)
      @line = line
      @column = column
      @source = source
      super(message)
    end
  end
end
`,
  "scripts/add_example_badges.rb": `#!/usr/bin/env ruby
# frozen_string_literal: true

# 문서의 코드 예제에 ExampleBadge를 자동으로 추가하는 스크립트
#
# 사용법:
#   ruby scripts/add_example_badges.rb [--dry-run]
#
# 동작:
#   1. 한글 문서의 모든 코드 예제를 추출
#   2. 각 예제에 대응하는 spec 파일을 찾기
#   3. 코드 블록 바로 위에 ExampleBadge 태그 삽입

class ExampleBadgeAdder
  DOCS_ROOT = File.expand_path("../../t-ruby.github.io", __dir__)
  KO_DOCS = "#{DOCS_ROOT}/i18n/ko/docusaurus-plugin-content-docs/current".freeze
  SPEC_ROOT = File.expand_path("../spec/docs_site/pages", __dir__)

  # 코드 블록 패턴
  CODE_FENCE_PATTERN = /^\`\`\`(\\w+)?(?:\\s+title="([^"]*)")?/

  def initialize(dry_run: false)
    @dry_run = dry_run
  end

  def run
    doc_files = Dir.glob("#{KO_DOCS}/**/*.md")
    processed = 0
    skipped = 0

    doc_files.each do |doc_path|
      result = process_document(doc_path)
      if result == :processed
        processed += 1
      else
        skipped += 1
      end
    end

    puts "\\n완료: #{processed}개 문서 처리, #{skipped}개 스킵"
  end

  private

  def process_document(doc_path)
    relative_path = doc_path.sub("#{KO_DOCS}/", "")
    spec_file = find_spec_file(relative_path)

    unless spec_file
      return :skipped
    end

    content = File.read(doc_path, encoding: "UTF-8")

    # 이미 ExampleBadge가 있는지 확인
    if content.include?("<ExampleBadge")
      puts "  [SKIP] Already has badges: #{relative_path}"
      return :skipped
    end

    new_content = add_badges_to_content(content, spec_file)

    if new_content == content
      puts "  [SKIP] No code blocks: #{relative_path}"
      return :skipped
    end

    puts "Processing: #{relative_path}"

    if @dry_run
      puts "  [DRY RUN] Would update #{doc_path}"
    else
      File.write(doc_path, new_content, encoding: "UTF-8")
      puts "  Updated: #{doc_path}"
    end

    :processed
  end

  def find_spec_file(doc_relative_path)
    # introduction/what-is-t-ruby.md -> introduction/what_is_t_ruby_spec.rb
    spec_relative = doc_relative_path
                    .sub(".md", "_spec.rb")
                    .gsub("-", "_")

    spec_path = "#{SPEC_ROOT}/#{spec_relative}"

    if File.exist?(spec_path)
      "spec/docs_site/pages/#{spec_relative}"
    end
  end

  def add_badges_to_content(content, spec_file)
    lines = content.lines
    result = []
    i = 0

    while i < lines.size
      line = lines[i]

      # 코드 블록 시작 감지
      if line.match?(CODE_FENCE_PATTERN)
        lang_match = line.match(CODE_FENCE_PATTERN)
        lang = lang_match[1]

        # trb, ruby, rbs 언어만 처리
        if %w[trb t-ruby ruby rbs].include?(lang&.downcase)
          # 이전 줄이 빈 줄이거나 텍스트인 경우에만 뱃지 추가
          # (이미 ExampleBadge가 있으면 추가 안함)
          prev_line = result.last
          unless prev_line&.include?("<ExampleBadge")
            badge = %(<ExampleBadge status="pass" testFile="#{spec_file}" line={21} />\\n\\n)
            result << badge
          end
        end
      end

      result << line
      i += 1
    end

    result.join
  end
end

if __FILE__ == $PROGRAM_NAME
  dry_run = ARGV.include?("--dry-run")
  ExampleBadgeAdder.new(dry_run: dry_run).run
end
`,
  "scripts/generate_example_tests.rb": `#!/usr/bin/env ruby
# frozen_string_literal: true

# 문서의 코드 예제를 분석하여:
# 1. spec 파일에 개별 예제 테스트 생성
# 2. 문서의 ExampleBadge 라인 번호 업데이트
#
# 사용법:
#   ruby scripts/generate_example_tests.rb [--dry-run]

require_relative "../lib/t_ruby/docs_example_extractor"

class ExampleTestGenerator
  DOCS_ROOT = File.expand_path("../../t-ruby.github.io", __dir__)
  KO_DOCS = "#{DOCS_ROOT}/i18n/ko/docusaurus-plugin-content-docs/current".freeze
  SPEC_ROOT = File.expand_path("../spec/docs_site/pages", __dir__)

  def initialize(dry_run: false)
    @dry_run = dry_run
    @extractor = TRuby::DocsExampleExtractor.new
  end

  def run
    doc_files = Dir.glob("#{KO_DOCS}/**/*.md")

    doc_files.each do |doc_path|
      process_document(doc_path)
    end
  end

  private

  def process_document(doc_path)
    relative_path = doc_path.sub("#{KO_DOCS}/", "")
    spec_relative = relative_path.sub(".md", "_spec.rb").gsub("-", "_")
    spec_path = "#{SPEC_ROOT}/#{spec_relative}"

    return unless File.exist?(spec_path)

    examples = @extractor.extract_from_file(doc_path)
    return if examples.empty?

    puts "Processing: #{relative_path} (#{examples.size} examples)"

    # 1. spec 파일 생성
    spec_content = generate_spec_content(relative_path, examples)
    line_map = calculate_line_map(spec_content, examples)

    # 2. 문서 업데이트
    doc_content = File.read(doc_path, encoding: "UTF-8")
    updated_doc = update_doc_badges(doc_content, examples, spec_relative, line_map)

    if @dry_run
      puts "  [DRY RUN] Would update spec and doc"
      puts "  Line map: #{line_map.inspect}"
    else
      File.write(spec_path, spec_content, encoding: "UTF-8")
      File.write(doc_path, updated_doc, encoding: "UTF-8")
      puts "  Updated: #{spec_path}"
      puts "  Updated: #{doc_path}"
    end
  end

  def generate_spec_content(relative_path, examples)
    doc_name = relative_path.sub(".md", "").split("/").last.gsub("-", " ").split.map(&:capitalize).join(" ")

    lines = []
    lines << "# frozen_string_literal: true"
    lines << ""
    lines << 'require "spec_helper"'
    lines << 'require_relative "../support/shared_examples"'
    lines << ""
    lines << "RSpec.describe \\"한글 문서: #{doc_name}\\" do"
    lines << '  include_context "docs site paths"'
    lines << ""
    lines << "  let(:relative_path) { \\"#{relative_path}\\" }"
    lines << %{  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }}
    lines << "  let(:doc_content) { File.read(doc_path) }"
    lines << "  let(:extractor) { TRuby::DocsExampleExtractor.new }"
    lines << "  let(:verifier) { TRuby::DocsExampleVerifier.new }"
    lines << "  let(:examples) { extractor.extract_from_file(doc_path) }"
    lines << ""
    lines << "  before do"
    lines << '    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)'
    lines << '    skip "Document not found" unless File.exist?(doc_path)'
    lines << "  end"
    lines << ""
    lines << "  it_behaves_like \\"valid documentation page\\", \\"#{relative_path}\\""
    lines << ""
    lines << '  describe "코드 예제" do'

    examples.each_with_index do |example, index|
      lines << generate_example_test(example, index)
    end

    lines << "  end"
    lines << "end"
    lines << ""

    lines.join("\\n")
  end

  def generate_example_test(example, index)
    # 예제 코드의 첫 줄을 기반으로 설명 생성
    first_line = example.code.lines.first&.strip || "코드"
    "#{first_line[0..40]}..." if first_line.length > 40

    lang_name = case example.language
                when "trb" then "T-Ruby"
                when "ruby" then "Ruby"
                when "rbs" then "RBS"
                else example.language
                end

    lines = []
    lines << ""
    lines << "    # 예제 #{index + 1}: #{lang_name} (라인 #{example.line_number})"
    lines << "    describe \\"예제 #{index + 1}: #{lang_name} 코드\\" do"
    lines << "      let(:example) { examples[#{index}] }"
    lines << ""

    case example.language
    when "trb"
      lines << '      it "T-Ruby 코드가 파싱에 성공한다" do'
      lines << '        skip "예제를 찾을 수 없음" unless example'
      lines << "        parser = TRuby::Parser.new(example.code)"
      lines << "        expect { parser.parse }.not_to raise_error"
      lines << "      end"
    when "ruby"
      lines << '      it "유효한 Ruby 문법이다" do'
      lines << '        skip "예제를 찾을 수 없음" unless example'
      lines << "        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error"
      lines << "      end"
    when "rbs"
      lines << '      it "RBS 형식이다" do'
      lines << '        skip "예제를 찾을 수 없음" unless example'
      lines << '        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)'
      lines << "      end"
    end

    lines << "    end"
    lines.join("\\n")
  end

  def calculate_line_map(spec_content, _examples)
    # spec 파일에서 각 예제 테스트의 시작 라인 번호 계산
    line_map = {}

    spec_content.lines.each_with_index do |line, index|
      if (match = line.match(/# 예제 (\\d+):/))
        example_index = match[1].to_i - 1
        line_map[example_index] = index + 1 # 1-based line number
      end
    end

    line_map
  end

  def update_doc_badges(doc_content, _examples, _spec_file, line_map)
    lines = doc_content.lines
    result = []
    example_index = 0

    i = 0
    while i < lines.size
      line = lines[i]

      # ExampleBadge 찾기
      if line.include?("<ExampleBadge")
        # 다음 코드 블록의 예제 인덱스 찾기
        test_line = line_map[example_index] || 21

        # 라인 번호 업데이트
        updated_badge = line.gsub(/line=\\{\\d+\\}/, "line={#{test_line}}")
        result << updated_badge
        example_index += 1
      else
        result << line
      end

      i += 1
    end

    result.join
  end
end

if __FILE__ == $PROGRAM_NAME
  dry_run = ARGV.include?("--dry-run")
  ExampleTestGenerator.new(dry_run: dry_run).run
end
`,
  "spec/docs_site/components_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe "Documentation Site Components" do
  let(:docs_site_path) { File.expand_path("../../../t-ruby.github.io", __dir__) }

  before(:all) do
    @docs_site_path = File.expand_path("../../../t-ruby.github.io", __dir__)
    skip "t-ruby.github.io not found at #{@docs_site_path}" unless Dir.exist?(@docs_site_path)
  end

  describe "DocsBadge component" do
    let(:component_path) { "#{docs_site_path}/src/components/DocsBadge/index.tsx" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(File.exist?(component_path)).to be true
    end

    it "uses lucide-react BadgeCheck icon" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      content = File.read(component_path)
      expect(content).to include("BadgeCheck")
      expect(content).to include("lucide-react")
    end
  end

  describe "VerifiedBadge component" do
    let(:component_path) { "#{docs_site_path}/src/components/VerifiedBadge/index.tsx" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(File.exist?(component_path)).to be true
    end

    it "supports pass and fail status" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      content = File.read(component_path)
      expect(content).to include("'pass'")
      expect(content).to include("'fail'")
    end

    it "uses lucide-react icons" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      content = File.read(component_path)
      expect(content).to include("lucide-react")
      expect(content).to include("BadgeCheck")
    end
  end

  describe "MDXComponents theme override" do
    let(:mdx_components_path) { "#{docs_site_path}/src/theme/MDXComponents.tsx" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(File.exist?(mdx_components_path)).to be true
    end

    it "exports DocsBadge and VerifiedBadge" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      content = File.read(mdx_components_path)
      expect(content).to include("DocsBadge")
      expect(content).to include("VerifiedBadge")
    end
  end

  describe "Package dependencies" do
    let(:package_json_path) { "#{docs_site_path}/package.json" }

    it "has lucide-react installed" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      content = File.read(package_json_path)
      expect(content).to include("lucide-react")
    end
  end

  describe "DocsBadge usage in documents" do
    it "all Korean documents have DocsBadge" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      ko_docs = Dir.glob("#{docs_site_path}/i18n/ko/docusaurus-plugin-content-docs/current/**/*.md")
      missing_badge = ko_docs.reject do |file|
        content = File.read(file)
        content.include?("<DocsBadge")
      end

      if missing_badge.any?
        raise "#{missing_badge.size} Korean documents missing DocsBadge:\\n#{missing_badge.join("\\n")}"
      end

      expect(missing_badge).to be_empty
    end

    it "all English documents have DocsBadge" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      en_docs = Dir.glob("#{docs_site_path}/docs/**/*.md")
      missing_badge = en_docs.reject do |file|
        content = File.read(file)
        content.include?("<DocsBadge")
      end

      if missing_badge.any?
        raise "#{missing_badge.size} English documents missing DocsBadge:\\n#{missing_badge.join("\\n")}"
      end

      expect(missing_badge).to be_empty
    end

    it "all Japanese documents have DocsBadge" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      ja_docs = Dir.glob("#{docs_site_path}/i18n/ja/docusaurus-plugin-content-docs/current/**/*.md")
      missing_badge = ja_docs.reject do |file|
        content = File.read(file)
        content.include?("<DocsBadge")
      end

      if missing_badge.any?
        raise "#{missing_badge.size} Japanese documents missing DocsBadge:\\n#{missing_badge.join("\\n")}"
      end

      expect(missing_badge).to be_empty
    end
  end
end
`,
  "spec/docs_site/docs_site_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe "t-ruby.github.io Documentation Site" do
  let(:docs_site_path) { File.expand_path("../../../t-ruby.github.io", __dir__) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }

  before(:all) do
    @docs_site_path = File.expand_path("../../../t-ruby.github.io", __dir__)
    skip "t-ruby.github.io not found at #{@docs_site_path}" unless Dir.exist?(@docs_site_path)
  end

  describe "English documentation (docs/)" do
    let(:docs_path) { "#{docs_site_path}/docs" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(Dir.exist?(docs_path)).to be true
    end

    it "has all code examples passing verification" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      results = []
      Dir.glob("#{docs_path}/**/*.md").each do |file|
        results.concat(verifier.verify_file(file))
      end

      failed = results.select(&:fail?)
      if failed.any?
        failure_messages = failed.map do |r|
          "#{r.file_path}:#{r.line_number}\\n  #{r.errors.join("\\n  ")}"
        end
        raise "#{failed.size} examples failed:\\n#{failure_messages.join("\\n\\n")}"
      end

      expect(failed).to be_empty
    end

    it "extracts examples from all markdown files" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      examples = extractor.extract_from_glob("#{docs_path}/**/*.md")
      expect(examples).not_to be_empty
    end
  end

  describe "Korean documentation (i18n/ko/)" do
    let(:docs_path) { "#{docs_site_path}/i18n/ko/docusaurus-plugin-content-docs/current" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(Dir.exist?(docs_path)).to be true
    end

    it "has all code examples passing verification" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      results = []
      Dir.glob("#{docs_path}/**/*.md").each do |file|
        results.concat(verifier.verify_file(file))
      end

      failed = results.select(&:fail?)
      if failed.any?
        failure_messages = failed.map do |r|
          "#{r.file_path}:#{r.line_number}\\n  #{r.errors.join("\\n  ")}"
        end
        raise "#{failed.size} examples failed:\\n#{failure_messages.join("\\n\\n")}"
      end

      expect(failed).to be_empty
    end

    it "has the same number of documents as English" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      en_docs = Dir.glob("#{docs_site_path}/docs/**/*.md").size
      ko_docs = Dir.glob("#{docs_path}/**/*.md").size

      expect(ko_docs).to eq(en_docs)
    end
  end

  describe "Japanese documentation (i18n/ja/)" do
    let(:docs_path) { "#{docs_site_path}/i18n/ja/docusaurus-plugin-content-docs/current" }

    it "exists" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)
      expect(Dir.exist?(docs_path)).to be true
    end

    it "has all code examples passing verification" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      results = []
      Dir.glob("#{docs_path}/**/*.md").each do |file|
        results.concat(verifier.verify_file(file))
      end

      failed = results.select(&:fail?)
      if failed.any?
        failure_messages = failed.map do |r|
          "#{r.file_path}:#{r.line_number}\\n  #{r.errors.join("\\n  ")}"
        end
        raise "#{failed.size} examples failed:\\n#{failure_messages.join("\\n\\n")}"
      end

      expect(failed).to be_empty
    end

    it "has the same number of documents as English" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      en_docs = Dir.glob("#{docs_site_path}/docs/**/*.md").size
      ja_docs = Dir.glob("#{docs_path}/**/*.md").size

      expect(ja_docs).to eq(en_docs)
    end
  end

  describe "Cross-language consistency" do
    it "all languages have matching document structure" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      en_structure = Dir.glob("#{docs_site_path}/docs/**/*.md").map do |f|
        f.sub("#{docs_site_path}/docs/", "")
      end.sort

      ko_structure = Dir.glob("#{docs_site_path}/i18n/ko/docusaurus-plugin-content-docs/current/**/*.md").map do |f|
        f.sub("#{docs_site_path}/i18n/ko/docusaurus-plugin-content-docs/current/", "")
      end.sort

      ja_structure = Dir.glob("#{docs_site_path}/i18n/ja/docusaurus-plugin-content-docs/current/**/*.md").map do |f|
        f.sub("#{docs_site_path}/i18n/ja/docusaurus-plugin-content-docs/current/", "")
      end.sort

      expect(ko_structure).to eq(en_structure), "Korean docs structure differs from English"
      expect(ja_structure).to eq(en_structure), "Japanese docs structure differs from English"
    end
  end
end
`,
  "spec/docs_site/examples_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe "Documentation Examples" do
  let(:docs_site_path) { File.expand_path("../../../t-ruby.github.io", __dir__) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }

  before(:all) do
    @docs_site_path = File.expand_path("../../../t-ruby.github.io", __dir__)
    skip "t-ruby.github.io not found at #{@docs_site_path}" unless Dir.exist?(@docs_site_path)
  end

  describe "T-Ruby (.trb) examples" do
    it "all parse successfully" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      all_examples = collect_all_examples
      trb_examples = all_examples.select(&:trb?).select(&:should_verify?)

      parse_failures = []
      trb_examples.each do |example|
        parser = TRuby::Parser.new(example.code)
        parser.parse
      rescue TRuby::ParseError => e
        parse_failures << {
          file: example.file_path,
          line: example.line_number,
          error: e.message,
        }
      end

      if parse_failures.any?
        messages = parse_failures.map { |f| "#{f[:file]}:#{f[:line]} - #{f[:error]}" }
        raise "#{parse_failures.size} T-Ruby examples failed to parse:\\n#{messages.join("\\n")}"
      end

      expect(parse_failures).to be_empty
    end

    it "all compile successfully" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      all_examples = collect_all_examples
      trb_examples = all_examples.select(&:trb?).select(&:should_verify?).select(&:should_compile?)

      compile_failures = []
      compiler = TRuby::Compiler.new

      trb_examples.each do |example|
        compiler.compile_string(example.code)
      rescue StandardError => e
        compile_failures << {
          file: example.file_path,
          line: example.line_number,
          error: e.message,
        }
      end

      if compile_failures.any?
        messages = compile_failures.map { |f| "#{f[:file]}:#{f[:line]} - #{f[:error]}" }
        raise "#{compile_failures.size} T-Ruby examples failed to compile:\\n#{messages.join("\\n")}"
      end

      expect(compile_failures).to be_empty
    end
  end

  describe "Ruby examples" do
    it "all have valid syntax" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      all_examples = collect_all_examples
      ruby_examples = all_examples.select(&:ruby?).select(&:should_verify?)

      syntax_failures = []
      ruby_examples.each do |example|
        RubyVM::InstructionSequence.compile(example.code)
      rescue SyntaxError => e
        syntax_failures << {
          file: example.file_path,
          line: example.line_number,
          error: e.message,
        }
      end

      if syntax_failures.any?
        messages = syntax_failures.map { |f| "#{f[:file]}:#{f[:line]} - #{f[:error]}" }
        raise "#{syntax_failures.size} Ruby examples have syntax errors:\\n#{messages.join("\\n")}"
      end

      expect(syntax_failures).to be_empty
    end
  end

  describe "Example statistics" do
    it "reports coverage statistics" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      all_examples = collect_all_examples
      stats = extractor.statistics(all_examples)

      puts "\\n=== Documentation Example Statistics ==="
      puts "Total examples: #{stats[:total]}"
      puts "T-Ruby (.trb): #{stats[:trb]}"
      puts "Ruby (.rb): #{stats[:ruby]}"
      puts "RBS (.rbs): #{stats[:rbs]}"
      puts "Verifiable: #{stats[:verifiable]}"
      puts "Files: #{stats[:files]}"
      puts "========================================\\n"

      expect(stats[:total]).to be > 0
    end

    it "has high pass rate (>99%)" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_path)

      all_examples = collect_all_examples
      results = all_examples.map { |ex| verifier.verify_example(ex) }
      summary = verifier.summary(results)

      puts "\\n=== Verification Results ==="
      puts "Passed: #{summary[:passed]}"
      puts "Failed: #{summary[:failed]}"
      puts "Skipped: #{summary[:skipped]}"
      puts "Pass rate: #{summary[:pass_rate]}%"
      puts "============================\\n"

      expect(summary[:pass_rate]).to be >= 99.0
    end
  end

  private

  def collect_all_examples
    patterns = [
      "#{docs_site_path}/docs/**/*.md",
      "#{docs_site_path}/i18n/ko/docusaurus-plugin-content-docs/current/**/*.md",
      "#{docs_site_path}/i18n/ja/docusaurus-plugin-content-docs/current/**/*.md",
    ]

    patterns.flat_map { |pattern| extractor.extract_from_glob(pattern) }
  end
end
`,
  "spec/docs_site/pages/cli/commands_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: CLI 명령어" do
  include_context "docs site paths"

  let(:relative_path) { "cli/commands.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "cli/commands.md"
end
`,
  "spec/docs_site/pages/cli/compiler_options_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Compiler Options" do
  include_context "docs site paths"

  let(:relative_path) { "cli/compiler-options.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "cli/compiler-options.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 42)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 66)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 85)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 107)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 129)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 151)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 172)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: Ruby (라인 354)
    describe "예제 8: Ruby 코드" do
      let(:example) { examples[7] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 9: Ruby (라인 366)
    describe "예제 9: Ruby 코드" do
      let(:example) { examples[8] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 10: Ruby (라인 376)
    describe "예제 10: Ruby 코드" do
      let(:example) { examples[9] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/cli/configuration_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Configuration" do
  include_context "docs site paths"

  let(:relative_path) { "cli/configuration.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "cli/configuration.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 259)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 277)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: Ruby (라인 299)
    describe "예제 3: Ruby 코드" do
      let(:example) { examples[2] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 328)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: Ruby (라인 339)
    describe "예제 5: Ruby 코드" do
      let(:example) { examples[4] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 6: Ruby (라인 350)
    describe "예제 6: Ruby 코드" do
      let(:example) { examples[5] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 389)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 405)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 417)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 433)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/getting_started/editor_setup_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: 에디터 설정" do
  include_context "docs site paths"

  let(:relative_path) { "getting-started/editor-setup.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "getting-started/editor-setup.md"

  describe "코드 예제" do
    describe "예제: VS Code settings.json" do
      let(:example) { examples.find { |e| e.code.include?('"t-ruby.typeCheck.enabled"') } }

      it "JSON 형식이 유효하다" do
        skip "예제를 찾을 수 없음" unless example
        expect { JSON.parse(example.code) }.not_to raise_error
      end
    end

    describe "예제: Sublime Text 빌드 시스템" do
      let(:example) { examples.find { |e| e.code.include?('"cmd": ["trc"') } }

      it "JSON 형식이 유효하다" do
        skip "예제를 찾을 수 없음" unless example
        expect { JSON.parse(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/getting_started/first_trb_file_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: First Trb File" do
  include_context "docs site paths"

  let(:relative_path) { "getting-started/first-trb-file.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "getting-started/first-trb-file.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 27)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 54)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 72)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 111)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 127)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 146)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: Ruby (라인 233)
    describe "예제 7: Ruby 코드" do
      let(:example) { examples[6] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 8: RBS (라인 251)
    describe "예제 8: RBS 코드" do
      let(:example) { examples[7] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 9: T-Ruby (라인 273)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 286)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 296)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/getting_started/installation_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: 설치하기" do
  include_context "docs site paths"

  let(:relative_path) { "getting-started/installation.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "getting-started/installation.md"

  describe "코드 예제" do
    describe "예제: package.json 스크립트" do
      let(:example) { examples.find { |e| e.code.include?('"build": "trc') } }

      it "JSON 형식이 유효하다" do
        skip "예제를 찾을 수 없음" unless example
        expect { JSON.parse(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/getting_started/project_configuration_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Project Configuration" do
  include_context "docs site paths"

  let(:relative_path) { "getting-started/project-configuration.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "getting-started/project-configuration.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 241)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 255)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: Ruby (라인 302)
    describe "예제 3: Ruby 코드" do
      let(:example) { examples[2] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/getting_started/quick_start_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Quick Start" do
  include_context "docs site paths"

  let(:relative_path) { "getting-started/quick-start.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "getting-started/quick-start.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 66)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 88)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 116)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/introduction/t_ruby_vs_others_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: T Ruby Vs Others" do
  include_context "docs site paths"

  let(:relative_path) { "introduction/t-ruby-vs-others.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "introduction/t-ruby-vs-others.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 36)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: RBS (라인 49)
    describe "예제 2: RBS 코드" do
      let(:example) { examples[1] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 3: T-Ruby (라인 65)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: Ruby (라인 110)
    describe "예제 4: Ruby 코드" do
      let(:example) { examples[3] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 133)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: Ruby (라인 159)
    describe "예제 6: Ruby 코드" do
      let(:example) { examples[5] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 173)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 215)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/introduction/what_is_t_ruby_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: What Is T Ruby" do
  include_context "docs site paths"

  let(:relative_path) { "introduction/what-is-t-ruby.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "introduction/what-is-t-ruby.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 19)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 28)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: RBS (라인 37)
    describe "예제 3: RBS 코드" do
      let(:example) { examples[2] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 4: T-Ruby (라인 50)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/introduction/why_t_ruby_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Why T Ruby" do
  include_context "docs site paths"

  let(:relative_path) { "introduction/why-t-ruby.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "introduction/why-t-ruby.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 20)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 34)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 56)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 76)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 100)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 119)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: Ruby (라인 125)
    describe "예제 7: Ruby 코드" do
      let(:example) { examples[6] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 160)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/advanced/conditional_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Conditional Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/advanced/conditional-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/advanced/conditional-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 24)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 34)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 52)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 66)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 88)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 104)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 120)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 138)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 161)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 182)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 204)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 226)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 246)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 270)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 285)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 303)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 325)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 346)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 385)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 404)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 420)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 438)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 459)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 478)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 492)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 510)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 534)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 28: T-Ruby (라인 546)
    describe "예제 28: T-Ruby 코드" do
      let(:example) { examples[27] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/advanced/intersection_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Intersection Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/advanced/intersection-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/advanced/intersection-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 26)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 43)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 53)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 105)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 166)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 243)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 301)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 432)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 482)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 532)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 568)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 600)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 614)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 627)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 652)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 704)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 766)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 778)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/advanced/mapped_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Mapped Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/advanced/mapped-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/advanced/mapped-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 24)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 34)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 57)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 78)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 106)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 134)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 160)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 192)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 220)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 247)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 281)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 304)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 345)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 381)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 423)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 468)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 511)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 553)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 589)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 626)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 641)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 655)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 668)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 683)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 704)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 724)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 739)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/advanced/type_aliases_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Type Aliases" do
  include_context "docs site paths"

  let(:relative_path) { "learn/advanced/type-aliases.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/advanced/type-aliases.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 27)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 49)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 76)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 84)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 111)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 144)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 182)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 208)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 240)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 274)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 305)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 344)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 376)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 415)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 455)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 485)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 501)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 520)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 542)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 558)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 586)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 617)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 631)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 650)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 672)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/advanced/utility_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Utility Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/advanced/utility-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/advanced/utility-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 26)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 68)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 99)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 140)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 186)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 239)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 270)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 294)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 320)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 347)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 375)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 421)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 444)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 466)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 504)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 536)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 569)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 598)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 626)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 656)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 680)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 699)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 726)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 761)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 789)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 818)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 832)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 28: T-Ruby (라인 848)
    describe "예제 28: T-Ruby 코드" do
      let(:example) { examples[27] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/basics/basic_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Basic Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/basics/basic-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/basics/basic-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 35)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 58)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 78)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 100)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 114)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 134)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 156)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 181)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 195)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 219)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 241)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 259)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 273)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 300)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 329)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 352)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 374)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 407)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 425)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 447)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 463)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 483)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 510)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 535)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/basics/type_annotations_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Type Annotations" do
  include_context "docs site paths"

  let(:relative_path) { "learn/basics/type-annotations.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/basics/type-annotations.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 41)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 62)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 70)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 94)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 108)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 123)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 141)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 156)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 185)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 201)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: Ruby (라인 230)
    describe "예제 12: Ruby 코드" do
      let(:example) { examples[11] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 255)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 272)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 297)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 315)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 332)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/basics/type_inference_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Type Inference" do
  include_context "docs site paths"

  let(:relative_path) { "learn/basics/type-inference.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/basics/type-inference.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 40)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 55)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 81)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 103)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 127)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 155)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 181)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 211)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 229)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 249)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 266)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 283)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 306)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 325)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 347)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 363)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 380)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 403)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 418)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 442)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 461)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 475)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 498)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 518)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/classes/abstract_classes_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Abstract Classes" do
  include_context "docs site paths"

  let(:relative_path) { "learn/classes/abstract-classes.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/classes/abstract-classes.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 98)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 187)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 276)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 411)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 498)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 679)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 718)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/classes/class_annotations_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Class Annotations" do
  include_context "docs site paths"

  let(:relative_path) { "learn/classes/class-annotations.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/classes/class-annotations.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 54)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 91)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 125)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 170)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 197)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 245)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 288)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 333)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 461)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 611)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 657)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 686)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/classes/inheritance_mixins_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Inheritance Mixins" do
  include_context "docs site paths"

  let(:relative_path) { "learn/classes/inheritance-mixins.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/classes/inheritance-mixins.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 83)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 164)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 222)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 318)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 380)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 461)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 524)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 700)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 744)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/classes/instance_class_variables_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Instance Class Variables" do
  include_context "docs site paths"

  let(:relative_path) { "learn/classes/instance-class-variables.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/classes/instance-class-variables.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 24)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 59)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 94)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 131)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 183)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 214)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 267)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 344)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 395)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 509)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 651)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 677)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 706)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/everyday_types/arrays_and_hashes_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Arrays And Hashes" do
  include_context "docs site paths"

  let(:relative_path) { "learn/everyday-types/arrays-and-hashes.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/everyday-types/arrays-and-hashes.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 42)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 57)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 87)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 111)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 142)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 171)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 206)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 237)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 258)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 287)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 319)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 358)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 404)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 430)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 467)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 592)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 629)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 672)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 685)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 712)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/everyday_types/literal_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Literal Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/everyday-types/literal-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/everyday-types/literal-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 39)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 57)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 76)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 115)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 140)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 196)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 210)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 247)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 264)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 286)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 306)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 331)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 411)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 454)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 509)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 585)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 605)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 623)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 645)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 666)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 684)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 704)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 716)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 741)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/everyday_types/primitives_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Primitives" do
  include_context "docs site paths"

  let(:relative_path) { "learn/everyday-types/primitives.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/everyday-types/primitives.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 35)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 52)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 78)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 100)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 122)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 147)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 176)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 199)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 230)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 260)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 284)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 314)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 337)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 368)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 395)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 424)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 456)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 485)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 514)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 544)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 570)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 594)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 621)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 650)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/everyday_types/type_narrowing_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Type Narrowing" do
  include_context "docs site paths"

  let(:relative_path) { "learn/everyday-types/type-narrowing.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/everyday-types/type-narrowing.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 46)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 73)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 105)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 128)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 155)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 174)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 197)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 216)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 242)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 257)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 285)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 302)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 337)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 351)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 367)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 401)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 520)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 542)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 558)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 588)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 611)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 628)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/everyday_types/union_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Union Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/everyday-types/union-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/everyday-types/union-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 41)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 58)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 77)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 101)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 122)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 147)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 173)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 212)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 261)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 290)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 315)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 344)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 366)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 388)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 422)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 541)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 559)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 575)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 599)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 619)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 639)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/functions/blocks_procs_lambdas_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Blocks Procs Lambdas" do
  include_context "docs site paths"

  let(:relative_path) { "learn/functions/blocks-procs-lambdas.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/functions/blocks-procs-lambdas.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 24)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 45)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 75)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 106)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 132)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 158)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 184)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 215)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 248)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 274)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 328)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 403)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 462)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 509)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 530)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 561)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/functions/optional_rest_parameters_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Optional Rest Parameters" do
  include_context "docs site paths"

  let(:relative_path) { "learn/functions/optional-rest-parameters.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/functions/optional-rest-parameters.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 46)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 76)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 113)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 145)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 180)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 213)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 253)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 290)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 388)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 463)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 480)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 492)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/functions/parameter_return_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Parameter Return Types" do
  include_context "docs site paths"

  let(:relative_path) { "learn/functions/parameter-return-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/functions/parameter-return-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 48)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 71)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 104)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 126)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 154)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 188)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 221)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 248)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 273)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 354)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 368)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 386)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/generics/built_in_generics_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Built In Generics" do
  include_context "docs site paths"

  let(:relative_path) { "learn/generics/built-in-generics.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/generics/built-in-generics.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 43)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 71)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 107)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 134)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 164)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 196)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 223)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 253)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 283)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 326)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 360)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 387)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 424)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 458)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 496)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 534)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 547)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 566)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 585)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 600)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 613)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 643)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/generics/constraints_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Constraints" do
  include_context "docs site paths"

  let(:relative_path) { "learn/generics/constraints.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/generics/constraints.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 27)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 43)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 61)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 81)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 117)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 159)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 203)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 268)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 287)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 307)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 331)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 385)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 437)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 525)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 541)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 571)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 587)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 612)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 633)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/generics/generic_functions_classes_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Generic Functions Classes" do
  include_context "docs site paths"

  let(:relative_path) { "learn/generics/generic-functions-classes.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/generics/generic-functions-classes.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 46)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 68)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 86)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 104)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 134)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 157)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 193)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 224)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 280)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 322)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 396)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 424)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 462)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 485)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 501)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 515)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 563)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/interfaces/defining_interfaces_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Defining Interfaces" do
  include_context "docs site paths"

  let(:relative_path) { "learn/interfaces/defining-interfaces.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/interfaces/defining-interfaces.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 80)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 139)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 209)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 289)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 343)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 395)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 546)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 663)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 698)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 714)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/interfaces/duck_typing_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Duck Typing" do
  include_context "docs site paths"

  let(:relative_path) { "learn/interfaces/duck-typing.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/interfaces/duck-typing.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 60)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 114)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 160)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 241)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 290)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 329)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 374)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 442)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 561)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/learn/interfaces/implementing_interfaces_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../../support/shared_examples"

RSpec.describe "한글 문서: Implementing Interfaces" do
  include_context "docs site paths"

  let(:relative_path) { "learn/interfaces/implementing-interfaces.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "learn/interfaces/implementing-interfaces.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 20)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 77)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 140)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 220)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 313)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 369)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 542)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 711)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 749)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/project/changelog_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Changelog" do
  include_context "docs site paths"

  let(:relative_path) { "project/changelog.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "project/changelog.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 191)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/project/contributing_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Contributing" do
  include_context "docs site paths"

  let(:relative_path) { "project/contributing.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "project/contributing.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 323)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 348)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 367)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 387)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 440)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 460)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/project/roadmap_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Roadmap" do
  include_context "docs site paths"

  let(:relative_path) { "project/roadmap.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "project/roadmap.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 209)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 218)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 227)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 236)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/reference/built_in_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Built In Types" do
  include_context "docs site paths"

  let(:relative_path) { "reference/built-in-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "reference/built-in-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 22)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 46)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 67)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 89)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 103)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 124)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 143)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 157)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 175)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 191)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 221)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 262)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 300)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 322)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 346)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 363)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 373)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 385)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 405)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 413)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 436)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 448)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 462)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 474)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 489)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 506)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 521)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 28: T-Ruby (라인 532)
    describe "예제 28: T-Ruby 코드" do
      let(:example) { examples[27] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 29: T-Ruby (라인 544)
    describe "예제 29: T-Ruby 코드" do
      let(:example) { examples[28] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 30: T-Ruby (라인 559)
    describe "예제 30: T-Ruby 코드" do
      let(:example) { examples[29] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 31: T-Ruby (라인 575)
    describe "예제 31: T-Ruby 코드" do
      let(:example) { examples[30] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 32: T-Ruby (라인 587)
    describe "예제 32: T-Ruby 코드" do
      let(:example) { examples[31] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 33: Ruby (라인 601)
    describe "예제 33: Ruby 코드" do
      let(:example) { examples[32] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 34: T-Ruby (라인 618)
    describe "예제 34: T-Ruby 코드" do
      let(:example) { examples[33] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 35: T-Ruby (라인 635)
    describe "예제 35: T-Ruby 코드" do
      let(:example) { examples[34] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 36: T-Ruby (라인 649)
    describe "예제 36: T-Ruby 코드" do
      let(:example) { examples[35] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 37: Ruby (라인 688)
    describe "예제 37: Ruby 코드" do
      let(:example) { examples[36] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 38: T-Ruby (라인 723)
    describe "예제 38: T-Ruby 코드" do
      let(:example) { examples[37] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/reference/cheatsheet_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Cheatsheet" do
  include_context "docs site paths"

  let(:relative_path) { "reference/cheatsheet.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "reference/cheatsheet.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 31)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 50)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 93)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 115)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 134)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 154)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 187)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 213)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 266)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 313)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 334)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 357)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 392)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 414)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 436)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 455)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 484)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 499)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 515)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 538)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 569)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/reference/stdlib_types_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Stdlib Types" do
  include_context "docs site paths"

  let(:relative_path) { "reference/stdlib-types.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "reference/stdlib-types.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 28)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 65)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 98)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 131)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 165)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 187)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 218)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: T-Ruby (라인 258)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 292)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 332)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 367)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 403)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 435)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 475)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 505)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 537)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 563)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 596)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 628)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: T-Ruby (라인 659)
    describe "예제 20: T-Ruby 코드" do
      let(:example) { examples[19] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 712)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 732)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 751)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/reference/type_operators_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Type Operators" do
  include_context "docs site paths"

  let(:relative_path) { "reference/type-operators.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "reference/type-operators.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 22)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 30)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 55)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 83)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 103)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 112)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 148)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: Ruby (라인 162)
    describe "예제 8: Ruby 코드" do
      let(:example) { examples[7] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 170)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: T-Ruby (라인 213)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 231)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: T-Ruby (라인 252)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 294)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 319)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: T-Ruby (라인 327)
    describe "예제 15: T-Ruby 코드" do
      let(:example) { examples[14] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 363)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 371)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: T-Ruby (라인 410)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 418)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: Ruby (라인 452)
    describe "예제 20: Ruby 코드" do
      let(:example) { examples[19] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 460)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 486)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 510)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 520)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 552)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 567)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 580)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 28: T-Ruby (라인 593)
    describe "예제 28: T-Ruby 코드" do
      let(:example) { examples[27] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 29: T-Ruby (라인 607)
    describe "예제 29: T-Ruby 코드" do
      let(:example) { examples[28] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 30: T-Ruby (라인 626)
    describe "예제 30: T-Ruby 코드" do
      let(:example) { examples[29] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 31: T-Ruby (라인 642)
    describe "예제 31: T-Ruby 코드" do
      let(:example) { examples[30] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 32: T-Ruby (라인 659)
    describe "예제 32: T-Ruby 코드" do
      let(:example) { examples[31] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 33: T-Ruby (라인 680)
    describe "예제 33: T-Ruby 코드" do
      let(:example) { examples[32] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 34: T-Ruby (라인 717)
    describe "예제 34: T-Ruby 코드" do
      let(:example) { examples[33] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 35: T-Ruby (라인 729)
    describe "예제 35: T-Ruby 코드" do
      let(:example) { examples[34] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 36: T-Ruby (라인 741)
    describe "예제 36: T-Ruby 코드" do
      let(:example) { examples[35] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 37: T-Ruby (라인 754)
    describe "예제 37: T-Ruby 코드" do
      let(:example) { examples[36] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 38: T-Ruby (라인 766)
    describe "예제 38: T-Ruby 코드" do
      let(:example) { examples[37] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 39: T-Ruby (라인 786)
    describe "예제 39: T-Ruby 코드" do
      let(:example) { examples[38] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 40: T-Ruby (라인 802)
    describe "예제 40: T-Ruby 코드" do
      let(:example) { examples[39] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 41: T-Ruby (라인 816)
    describe "예제 41: T-Ruby 코드" do
      let(:example) { examples[40] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/support/shared_examples.rb": `# frozen_string_literal: true

# 문서 페이지 테스트를 위한 공통 shared examples
# 한글 문서 기준으로 테스트하며, 다른 언어는 구조 일치만 확인

RSpec.shared_context "docs site paths" do
  let(:docs_site_root) { File.expand_path("../../../../../t-ruby.github.io", __dir__) }
  let(:ko_docs_root) { "#{docs_site_root}/i18n/ko/docusaurus-plugin-content-docs/current" }
  let(:en_docs_root) { "#{docs_site_root}/docs" }
  let(:ja_docs_root) { "#{docs_site_root}/i18n/ja/docusaurus-plugin-content-docs/current" }
end

RSpec.shared_examples "valid documentation page" do |relative_path|
  include_context "docs site paths"

  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }

  before do
    skip "t-ruby.github.io not found at #{docs_site_root}" unless Dir.exist?(docs_site_root)
    skip "Document not found at #{doc_path}" unless File.exist?(doc_path)
  end

  describe "문서 구조" do
    it "frontmatter가 존재한다" do
      expect(doc_content).to match(/\\A---\\n.*?---/m)
    end

    it "title이 frontmatter에 포함되어 있다" do
      frontmatter = doc_content.match(/\\A---\\n(.*?)---/m)&.[](1)
      expect(frontmatter).to include("title:")
    end

    it "최소 1개 이상의 heading이 존재한다" do
      # frontmatter 이후의 본문에서 heading 찾기
      body = doc_content.sub(/\\A---\\n.*?---\\n/m, "")
      expect(body).to match(/^#+ /)
    end
  end

  describe "DocsBadge" do
    it "DocsBadge 컴포넌트가 포함되어 있다" do
      expect(doc_content).to include("<DocsBadge")
    end
  end

  describe "코드 예제 검증" do
    let(:examples) { extractor.extract_from_file(doc_path) }

    it "모든 T-Ruby 예제가 파싱된다" do
      trb_examples = examples.select(&:trb?).select(&:should_verify?)
      skip "T-Ruby 예제 없음" if trb_examples.empty?

      parse_failures = []
      trb_examples.each do |example|
        parser = TRuby::Parser.new(example.code)
        parser.parse
      rescue TRuby::ParseError => e
        parse_failures << { line: example.line_number, error: e.message }
      end

      if parse_failures.any?
        messages = parse_failures.map { |f| "Line #{f[:line]}: #{f[:error]}" }
        raise "T-Ruby 파싱 실패:\\n#{messages.join("\\n")}"
      end
    end

    it "모든 T-Ruby 예제가 컴파일된다" do
      trb_examples = examples.select(&:trb?).select(&:should_verify?).select(&:should_compile?)
      skip "컴파일 대상 T-Ruby 예제 없음" if trb_examples.empty?

      compiler = TRuby::Compiler.new
      compile_failures = []

      trb_examples.each do |example|
        compiler.compile_string(example.code)
      rescue StandardError => e
        compile_failures << { line: example.line_number, error: e.message }
      end

      if compile_failures.any?
        messages = compile_failures.map { |f| "Line #{f[:line]}: #{f[:error]}" }
        raise "T-Ruby 컴파일 실패:\\n#{messages.join("\\n")}"
      end
    end

    it "모든 Ruby 예제가 유효한 문법이다" do
      ruby_examples = examples.select(&:ruby?).select(&:should_verify?)
      skip "Ruby 예제 없음" if ruby_examples.empty?

      syntax_failures = []
      ruby_examples.each do |example|
        RubyVM::InstructionSequence.compile(example.code)
      rescue SyntaxError => e
        syntax_failures << { line: example.line_number, error: e.message }
      end

      if syntax_failures.any?
        messages = syntax_failures.map { |f| "Line #{f[:line]}: #{f[:error]}" }
        raise "Ruby 문법 오류:\\n#{messages.join("\\n")}"
      end
    end

    it "모든 RBS 예제가 유효하다" do
      rbs_examples = examples.select(&:rbs?).select(&:should_verify?)
      skip "RBS 예제 없음" if rbs_examples.empty?

      invalid_examples = []
      rbs_examples.each do |example|
        # 기본 유효성 검사: def, type, interface, class 중 하나 포함
        unless example.code.match?(/\\b(def|type|interface|class|module)\\b/)
          invalid_examples << { line: example.line_number, error: "RBS 키워드 없음" }
        end
      end

      if invalid_examples.any?
        messages = invalid_examples.map { |f| "Line #{f[:line]}: #{f[:error]}" }
        raise "RBS 유효성 검사 실패:\\n#{messages.join("\\n")}"
      end
    end
  end
end

RSpec.shared_examples "code example" do |example_index, description|
  it "예제 #{example_index + 1}: #{description}" do
    example = examples[example_index]
    skip "예제를 찾을 수 없음" unless example

    result = verifier.verify_example(example)
    expect(result).to be_pass, -> { "검증 실패: #{result.errors.join(", ")}" }
  end
end
`,
  "spec/docs_site/pages/tooling/migrating_from_ruby_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Migrating From Ruby" do
  include_context "docs site paths"

  let(:relative_path) { "tooling/migrating-from-ruby.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "tooling/migrating-from-ruby.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 56)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 76)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: Ruby (라인 96)
    describe "예제 3: Ruby 코드" do
      let(:example) { examples[2] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 120)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 162)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: Ruby (라인 194)
    describe "예제 6: Ruby 코드" do
      let(:example) { examples[5] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 7: T-Ruby (라인 215)
    describe "예제 7: T-Ruby 코드" do
      let(:example) { examples[6] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 8: Ruby (라인 248)
    describe "예제 8: Ruby 코드" do
      let(:example) { examples[7] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 9: T-Ruby (라인 269)
    describe "예제 9: T-Ruby 코드" do
      let(:example) { examples[8] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 10: Ruby (라인 291)
    describe "예제 10: Ruby 코드" do
      let(:example) { examples[9] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 11: T-Ruby (라인 315)
    describe "예제 11: T-Ruby 코드" do
      let(:example) { examples[10] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 12: Ruby (라인 354)
    describe "예제 12: Ruby 코드" do
      let(:example) { examples[11] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 13: T-Ruby (라인 374)
    describe "예제 13: T-Ruby 코드" do
      let(:example) { examples[12] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 14: T-Ruby (라인 396)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: Ruby (라인 422)
    describe "예제 15: Ruby 코드" do
      let(:example) { examples[14] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 445)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: T-Ruby (라인 468)
    describe "예제 17: T-Ruby 코드" do
      let(:example) { examples[16] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 18: Ruby (라인 485)
    describe "예제 18: Ruby 코드" do
      let(:example) { examples[17] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 19: T-Ruby (라인 497)
    describe "예제 19: T-Ruby 코드" do
      let(:example) { examples[18] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 20: Ruby (라인 516)
    describe "예제 20: Ruby 코드" do
      let(:example) { examples[19] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 533)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: Ruby (라인 583)
    describe "예제 22: Ruby 코드" do
      let(:example) { examples[21] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 23: T-Ruby (라인 597)
    describe "예제 23: T-Ruby 코드" do
      let(:example) { examples[22] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 24: Ruby (라인 622)
    describe "예제 24: Ruby 코드" do
      let(:example) { examples[23] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 25: T-Ruby (라인 636)
    describe "예제 25: T-Ruby 코드" do
      let(:example) { examples[24] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 839)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: Ruby (라인 923)
    describe "예제 27: Ruby 코드" do
      let(:example) { examples[26] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 28: T-Ruby (라인 952)
    describe "예제 28: T-Ruby 코드" do
      let(:example) { examples[27] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/tooling/rbs_integration_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Rbs Integration" do
  include_context "docs site paths"

  let(:relative_path) { "tooling/rbs-integration.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "tooling/rbs-integration.md"

  describe "코드 예제" do
    # 예제 1: T-Ruby (라인 33)
    describe "예제 1: T-Ruby 코드" do
      let(:example) { examples[0] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 2: RBS (라인 59)
    describe "예제 2: RBS 코드" do
      let(:example) { examples[1] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 3: Ruby (라인 75)
    describe "예제 3: Ruby 코드" do
      let(:example) { examples[2] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 135)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: RBS (라인 148)
    describe "예제 5: RBS 코드" do
      let(:example) { examples[4] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 6: T-Ruby (라인 157)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: RBS (라인 170)
    describe "예제 7: RBS 코드" do
      let(:example) { examples[6] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 8: T-Ruby (라인 182)
    describe "예제 8: T-Ruby 코드" do
      let(:example) { examples[7] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 9: RBS (라인 190)
    describe "예제 9: RBS 코드" do
      let(:example) { examples[8] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 10: T-Ruby (라인 200)
    describe "예제 10: T-Ruby 코드" do
      let(:example) { examples[9] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 11: RBS (라인 220)
    describe "예제 11: RBS 코드" do
      let(:example) { examples[10] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 12: T-Ruby (라인 234)
    describe "예제 12: T-Ruby 코드" do
      let(:example) { examples[11] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 13: RBS (라인 248)
    describe "예제 13: RBS 코드" do
      let(:example) { examples[12] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 14: T-Ruby (라인 256)
    describe "예제 14: T-Ruby 코드" do
      let(:example) { examples[13] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 15: RBS (라인 278)
    describe "예제 15: RBS 코드" do
      let(:example) { examples[14] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 16: T-Ruby (라인 295)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: RBS (라인 306)
    describe "예제 17: RBS 코드" do
      let(:example) { examples[16] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 18: T-Ruby (라인 319)
    describe "예제 18: T-Ruby 코드" do
      let(:example) { examples[17] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 19: RBS (라인 340)
    describe "예제 19: RBS 코드" do
      let(:example) { examples[18] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 20: Ruby (라인 404)
    describe "예제 20: Ruby 코드" do
      let(:example) { examples[19] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 21: T-Ruby (라인 420)
    describe "예제 21: T-Ruby 코드" do
      let(:example) { examples[20] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 22: T-Ruby (라인 530)
    describe "예제 22: T-Ruby 코드" do
      let(:example) { examples[21] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 23: Ruby (라인 571)
    describe "예제 23: Ruby 코드" do
      let(:example) { examples[22] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 24: T-Ruby (라인 586)
    describe "예제 24: T-Ruby 코드" do
      let(:example) { examples[23] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 25: Ruby (라인 639)
    describe "예제 25: Ruby 코드" do
      let(:example) { examples[24] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 26: T-Ruby (라인 727)
    describe "예제 26: T-Ruby 코드" do
      let(:example) { examples[25] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 27: T-Ruby (라인 746)
    describe "예제 27: T-Ruby 코드" do
      let(:example) { examples[26] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/tooling/ruby_lsp_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Ruby Lsp" do
  include_context "docs site paths"

  let(:relative_path) { "tooling/ruby-lsp.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "tooling/ruby-lsp.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 63)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: T-Ruby (라인 198)
    describe "예제 2: T-Ruby 코드" do
      let(:example) { examples[1] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 3: Ruby (라인 228)
    describe "예제 3: Ruby 코드" do
      let(:example) { examples[2] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 4: T-Ruby (라인 242)
    describe "예제 4: T-Ruby 코드" do
      let(:example) { examples[3] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 5: T-Ruby (라인 256)
    describe "예제 5: T-Ruby 코드" do
      let(:example) { examples[4] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 6: T-Ruby (라인 272)
    describe "예제 6: T-Ruby 코드" do
      let(:example) { examples[5] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 7: Ruby (라인 308)
    describe "예제 7: Ruby 코드" do
      let(:example) { examples[6] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/pages/tooling/steep_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require_relative "../support/shared_examples"

RSpec.describe "한글 문서: Steep" do
  include_context "docs site paths"

  let(:relative_path) { "tooling/steep.md" }
  let(:doc_path) { "#{ko_docs_root}/#{relative_path}" }
  let(:doc_content) { File.read(doc_path) }
  let(:extractor) { TRuby::DocsExampleExtractor.new }
  let(:verifier) { TRuby::DocsExampleVerifier.new }
  let(:examples) { extractor.extract_from_file(doc_path) }

  before do
    skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
    skip "Document not found" unless File.exist?(doc_path)
  end

  it_behaves_like "valid documentation page", "tooling/steep.md"

  describe "코드 예제" do
    # 예제 1: Ruby (라인 36)
    describe "예제 1: Ruby 코드" do
      let(:example) { examples[0] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 2: Ruby (라인 71)
    describe "예제 2: Ruby 코드" do
      let(:example) { examples[1] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 3: T-Ruby (라인 100)
    describe "예제 3: T-Ruby 코드" do
      let(:example) { examples[2] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 4: Ruby (라인 140)
    describe "예제 4: Ruby 코드" do
      let(:example) { examples[3] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 5: Ruby (라인 170)
    describe "예제 5: Ruby 코드" do
      let(:example) { examples[4] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 6: Ruby (라인 183)
    describe "예제 6: Ruby 코드" do
      let(:example) { examples[5] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 7: Ruby (라인 207)
    describe "예제 7: Ruby 코드" do
      let(:example) { examples[6] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 8: Ruby (라인 229)
    describe "예제 8: Ruby 코드" do
      let(:example) { examples[7] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 9: Ruby (라인 309)
    describe "예제 9: Ruby 코드" do
      let(:example) { examples[8] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 10: Ruby (라인 330)
    describe "예제 10: Ruby 코드" do
      let(:example) { examples[9] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 11: Ruby (라인 351)
    describe "예제 11: Ruby 코드" do
      let(:example) { examples[10] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 12: Ruby (라인 384)
    describe "예제 12: Ruby 코드" do
      let(:example) { examples[11] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 13: Ruby (라인 402)
    describe "예제 13: Ruby 코드" do
      let(:example) { examples[12] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 14: RBS (라인 436)
    describe "예제 14: RBS 코드" do
      let(:example) { examples[13] }

      it "RBS 형식이다" do
        skip "예제를 찾을 수 없음" unless example
        expect(example.code).to match(/\\b(def|class|module|interface|type)\\b/)
      end
    end

    # 예제 15: Ruby (라인 453)
    describe "예제 15: Ruby 코드" do
      let(:example) { examples[14] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 16: T-Ruby (라인 465)
    describe "예제 16: T-Ruby 코드" do
      let(:example) { examples[15] }

      it "T-Ruby 코드가 파싱에 성공한다" do
        skip "예제를 찾을 수 없음" unless example
        parser = TRuby::Parser.new(example.code)
        expect { parser.parse }.not_to raise_error
      end
    end

    # 예제 17: Ruby (라인 648)
    describe "예제 17: Ruby 코드" do
      let(:example) { examples[16] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 18: Ruby (라인 710)
    describe "예제 18: Ruby 코드" do
      let(:example) { examples[17] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end

    # 예제 19: Ruby (라인 760)
    describe "예제 19: Ruby 코드" do
      let(:example) { examples[18] }

      it "유효한 Ruby 문법이다" do
        skip "예제를 찾을 수 없음" unless example
        expect { RubyVM::InstructionSequence.compile(example.code) }.not_to raise_error
      end
    end
  end
end
`,
  "spec/docs_site/structure_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe "다국어 문서 구조 일치 테스트" do
  let(:docs_site_root) { File.expand_path("../../../t-ruby.github.io", __dir__) }
  let(:ko_docs_root) { "#{docs_site_root}/i18n/ko/docusaurus-plugin-content-docs/current" }
  let(:en_docs_root) { "#{docs_site_root}/docs" }
  let(:ja_docs_root) { "#{docs_site_root}/i18n/ja/docusaurus-plugin-content-docs/current" }

  before(:all) do
    @docs_site_root = File.expand_path("../../../t-ruby.github.io", __dir__)
    skip "t-ruby.github.io not found at #{@docs_site_root}" unless Dir.exist?(@docs_site_root)
  end

  def relative_paths(base_path)
    Dir.glob("#{base_path}/**/*.md").map do |file|
      file.sub("#{base_path}/", "")
    end.sort
  end

  describe "한글 문서 (기준)" do
    it "한글 문서 폴더가 존재한다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
      expect(Dir.exist?(ko_docs_root)).to be true
    end

    it "한글 문서가 존재한다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
      ko_docs = Dir.glob("#{ko_docs_root}/**/*.md")
      expect(ko_docs).not_to be_empty
    end
  end

  describe "영어 문서 구조 일치" do
    it "영어 문서 폴더가 존재한다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
      expect(Dir.exist?(en_docs_root)).to be true
    end

    it "한글 문서와 동일한 파일 수를 가진다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)

      ko_count = Dir.glob("#{ko_docs_root}/**/*.md").size
      en_count = Dir.glob("#{en_docs_root}/**/*.md").size

      expect(en_count).to eq(ko_count),
                          "영어 문서 수(#{en_count})가 한글 문서 수(#{ko_count})와 다릅니다"
    end

    it "한글 문서와 동일한 파일 구조를 가진다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)

      ko_structure = relative_paths(ko_docs_root)
      en_structure = relative_paths(en_docs_root)

      missing_in_en = ko_structure - en_structure
      extra_in_en = en_structure - ko_structure

      error_messages = []
      if missing_in_en.any?
        error_messages << "영어 문서에 없는 파일:\\n  #{missing_in_en.join("\\n  ")}"
      end
      if extra_in_en.any?
        error_messages << "한글 문서에 없는 파일 (영어에만 존재):\\n  #{extra_in_en.join("\\n  ")}"
      end

      expect(error_messages).to be_empty, error_messages.join("\\n\\n")
    end
  end

  describe "일본어 문서 구조 일치" do
    it "일본어 문서 폴더가 존재한다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
      expect(Dir.exist?(ja_docs_root)).to be true
    end

    it "한글 문서와 동일한 파일 수를 가진다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)

      ko_count = Dir.glob("#{ko_docs_root}/**/*.md").size
      ja_count = Dir.glob("#{ja_docs_root}/**/*.md").size

      expect(ja_count).to eq(ko_count),
                          "일본어 문서 수(#{ja_count})가 한글 문서 수(#{ko_count})와 다릅니다"
    end

    it "한글 문서와 동일한 파일 구조를 가진다" do
      skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)

      ko_structure = relative_paths(ko_docs_root)
      ja_structure = relative_paths(ja_docs_root)

      missing_in_ja = ko_structure - ja_structure
      extra_in_ja = ja_structure - ko_structure

      error_messages = []
      if missing_in_ja.any?
        error_messages << "일본어 문서에 없는 파일:\\n  #{missing_in_ja.join("\\n  ")}"
      end
      if extra_in_ja.any?
        error_messages << "한글 문서에 없는 파일 (일본어에만 존재):\\n  #{extra_in_ja.join("\\n  ")}"
      end

      expect(error_messages).to be_empty, error_messages.join("\\n\\n")
    end
  end

  describe "섹션별 구조 상세 검증" do
    SECTIONS = %w[
      introduction
      getting-started
      learn
      cli
      reference
      tooling
      project
    ].freeze

    SECTIONS.each do |section|
      describe "#{section}/ 섹션" do
        it "한글 문서에 #{section} 폴더가 존재한다" do
          skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
          expect(Dir.exist?("#{ko_docs_root}/#{section}")).to be true
        end

        it "영어 문서에 #{section} 폴더가 존재한다" do
          skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
          expect(Dir.exist?("#{en_docs_root}/#{section}")).to be true
        end

        it "일본어 문서에 #{section} 폴더가 존재한다" do
          skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)
          expect(Dir.exist?("#{ja_docs_root}/#{section}")).to be true
        end

        it "#{section} 섹션의 파일 수가 일치한다" do
          skip "t-ruby.github.io not found" unless Dir.exist?(docs_site_root)

          ko_files = Dir.glob("#{ko_docs_root}/#{section}/**/*.md").size
          en_files = Dir.glob("#{en_docs_root}/#{section}/**/*.md").size
          ja_files = Dir.glob("#{ja_docs_root}/#{section}/**/*.md").size

          expect(en_files).to eq(ko_files),
                              "#{section}: 영어(#{en_files}) != 한글(#{ko_files})"
          expect(ja_files).to eq(ko_files),
                              "#{section}: 일본어(#{ja_files}) != 한글(#{ko_files})"
        end
      end
    end
  end
end
`,
  "spec/e2e/array_shorthand_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"
require "rbs"

RSpec.describe "Array Shorthand Syntax E2E" do
  let(:tmpdir) { Dir.mktmpdir("trb_array_shorthand_e2e") }

  before do
    @original_dir = Dir.pwd
  end

  after do
    Dir.chdir(@original_dir)
    FileUtils.rm_rf(tmpdir)
  end

  # Helper to create config file with RBS generation enabled
  def create_config_file(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    config_path
  end

  # Helper to create a .trb file
  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  # Helper to compile and get RBS content
  def compile_and_get_rbs(trb_path, rbs_dir: "sig")
    config = TRuby::Config.new
    # Disable type checking to focus on parsing and RBS generation
    allow(config).to receive(:type_check?).and_return(false)
    compiler = TRuby::Compiler.new(config)
    compiler.compile(trb_path)

    # Determine RBS path based on config
    relative_path = trb_path.sub("#{tmpdir}/src/", "")
    rbs_path = File.join(tmpdir, rbs_dir, relative_path.sub(".trb", ".rbs"))
    File.read(rbs_path) if File.exist?(rbs_path)
  end

  # Helper to compile and get Ruby content
  def compile_and_get_ruby(trb_path, ruby_dir: "build")
    config = TRuby::Config.new
    # Disable type checking to focus on parsing and Ruby generation
    allow(config).to receive(:type_check?).and_return(false)
    compiler = TRuby::Compiler.new(config)
    compiler.compile(trb_path)

    # Determine Ruby path based on config
    relative_path = trb_path.sub("#{tmpdir}/src/", "")
    ruby_path = File.join(tmpdir, ruby_dir, relative_path.sub(".trb", ".rb"))
    File.read(ruby_path) if File.exist?(ruby_path)
  end

  # Helper to validate RBS syntax using the official rbs gem
  def valid_rbs_syntax?(rbs_content)
    return false if rbs_content.nil? || rbs_content.strip.empty?

    RBS::Parser.parse_signature(rbs_content)
    true
  rescue RBS::ParsingError
    false
  end

  # Helper to assert RBS is valid and return parsed content
  # Note: Top-level functions without class wrapper may not be valid standalone RBS
  # but the type output format is still correct
  def expect_valid_rbs(rbs_content)
    expect(rbs_content).not_to be_nil
    expect(rbs_content.strip).not_to be_empty

    # Try to parse, but don't fail on certain patterns that are valid in T-Ruby context
    # - Top-level def (not valid standalone RBS)
    # - Type aliases with uppercase names (T-Ruby convention differs from RBS)
    begin
      RBS::Parser.parse_signature(rbs_content)
    rescue RBS::ParsingError => e
      # Skip RBS validation for:
      # - Top-level def (which is common in our tests)
      # - Type aliases with uppercase names
      first_line = rbs_content.strip.lines.first.to_s
      unless first_line.start_with?("def ") || first_line.start_with?("type ")
        raise "Generated RBS is invalid:\\n#{rbs_content}\\n\\nParsing error: #{e.message}"
      end
    end

    rbs_content
  end

  describe "basic array shorthand compilation" do
    it "compiles String[] to Array[String] in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/names.trb", <<~TRB)
          def get_names(): String[]
            ["Alice", "Bob", "Charlie"]
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/names.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        # Should generate Array[String] in RBS format
        expect(rbs_content).to include("def get_names: () -> Array[String]")
      end
    end

    it "compiles Integer[] parameter to Array[Integer] in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/sum.trb", <<~TRB)
          def sum(numbers: Integer[]): Integer
            numbers.sum
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/sum.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("def sum: (numbers: Array[Integer]) -> Integer")
      end
    end
  end

  describe "nested array shorthand compilation" do
    it "compiles Integer[][] to nested Array in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/matrix.trb", <<~TRB)
          def create_matrix(): Integer[][]
            [[1, 2], [3, 4]]
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/matrix.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("def create_matrix: () -> Array[Array[Integer]]")
      end
    end

    it "compiles String[][][] to triple-nested Array in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/cube.trb", <<~TRB)
          def create_cube(): String[][][]
            [[["a", "b"], ["c", "d"]], [["e", "f"], ["g", "h"]]]
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/cube.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("def create_cube: () -> Array[Array[Array[String]]]")
      end
    end
  end

  describe "nullable array shorthand compilation" do
    it "compiles String[]? to nilable Array in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/optional.trb", <<~TRB)
          def maybe_names(): String[]?
            nil
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/optional.trb"))

        expect_valid_rbs(rbs_content)
        # String[]? = (Array[String] | nil) in RBS
        expect(rbs_content).to include("def maybe_names: () -> (Array[String] | nil)")
      end
    end

    it "compiles String?[] to Array of nilable elements in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/nullable_elements.trb", <<~TRB)
          def names_with_nil(): String?[]
            ["Alice", nil, "Bob"]
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/nullable_elements.trb"))

        expect_valid_rbs(rbs_content)
        # String?[] = Array[String?] in RBS (String? is valid RBS for nilable)
        expect(rbs_content).to include("def names_with_nil: () -> Array[String?]")
      end
    end
  end

  describe "union type array shorthand compilation" do
    it "compiles (String | Integer)[] to Array of union in RBS" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/mixed.trb", <<~TRB)
          def mixed_values(): (String | Integer)[]
            ["hello", 42, "world"]
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/mixed.trb"))

        expect_valid_rbs(rbs_content)
        # Both Array[String | Integer] and Array[(String | Integer)] are valid RBS
        expect(rbs_content).to include("def mixed_values: () -> Array[String | Integer]")
      end
    end
  end

  describe "type alias with array shorthand" do
    it "compiles type alias with array shorthand" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        # Test single type alias with array shorthand
        create_trb_file("src/string_list.trb", <<~TRB)
          type StringList = String[]

          def process_list(items: StringList): Integer
            items.length
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/string_list.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("type StringList = Array[String]")
      end
    end

    it "compiles type alias with nested array shorthand" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        # Add a dummy function to ensure RBS is generated
        create_trb_file("src/int_matrix.trb", <<~TRB)
          type IntMatrix = Integer[][]

          def dummy_matrix(): IntMatrix
            []
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/int_matrix.trb"))
        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("type IntMatrix = Array[Array[Integer]]")
      end
    end
  end

  describe "class with array shorthand types" do
    # NOTE: This test is pending because instance variable type annotation parsing
    # has limitations in the legacy parser. The array shorthand syntax works correctly
    # in method parameters and return types.
    it "compiles class with array shorthand instance variables", pending: "Instance variable type parsing needs improvement" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/data_store.trb", <<~TRB)
          class DataStore
            @items: String[]
            @matrix: Integer[][]

            def initialize(): void
              @items = []
              @matrix = []
            end

            def add_item(item: String): void
              @items << item
            end

            def get_items(): String[]
              @items
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/data_store.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("class DataStore")
        expect(rbs_content).to include("@items: Array[String]")
        expect(rbs_content).to include("@matrix: Array[Array[Integer]]")
        expect(rbs_content).to include("def get_items: () -> Array[String]")
      end
    end
  end

  describe "Ruby output type erasure" do
    it "removes array shorthand types in compiled Ruby" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/typed.trb", <<~TRB)
          def process(items: String[]): Integer[]
            items.map { |s| s.length }
          end
        TRB

        ruby_content = compile_and_get_ruby(File.join(tmpdir, "src/typed.trb"))

        expect(ruby_content).to include("def process(items)")
        expect(ruby_content).not_to include("String[]")
        expect(ruby_content).not_to include("Integer[]")
        expect(ruby_content).not_to include(": String")
        expect(ruby_content).not_to include(": Integer")
      end
    end
  end

  describe "equivalence with Array<T> syntax" do
    it "String[] and Array<String> produce identical RBS output" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        # Test with shorthand syntax
        create_trb_file("src/shorthand.trb", <<~TRB)
          def get_names(): String[]
            []
          end
        TRB

        rbs_shorthand = compile_and_get_rbs(File.join(tmpdir, "src/shorthand.trb"))

        # Test with generic syntax
        create_trb_file("src/generic.trb", <<~TRB)
          def get_names(): Array<String>
            []
          end
        TRB

        rbs_generic = compile_and_get_rbs(File.join(tmpdir, "src/generic.trb"))

        # Both should produce valid RBS
        expect_valid_rbs(rbs_shorthand)
        expect_valid_rbs(rbs_generic)

        # Both should produce identical RBS output
        expect(rbs_shorthand).to include("def get_names: () -> Array[String]")
        expect(rbs_generic).to include("def get_names: () -> Array[String]")
      end
    end

    it "Integer[][] and Array<Array<Integer>> produce identical RBS output" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        # Test with shorthand syntax
        create_trb_file("src/matrix_shorthand.trb", <<~TRB)
          def get_matrix(): Integer[][]
            []
          end
        TRB

        rbs_shorthand = compile_and_get_rbs(File.join(tmpdir, "src/matrix_shorthand.trb"))

        # Test with generic syntax
        create_trb_file("src/matrix_generic.trb", <<~TRB)
          def get_matrix(): Array<Array<Integer>>
            []
          end
        TRB

        rbs_generic = compile_and_get_rbs(File.join(tmpdir, "src/matrix_generic.trb"))

        # Both should produce identical RBS output
        expect(rbs_shorthand).to include("def get_matrix: () -> Array[Array[Integer]]")
        expect(rbs_generic).to include("def get_matrix: () -> Array[Array[Integer]]")
      end
    end
  end

  describe "complex real-world scenarios" do
    # NOTE: This test is pending because it uses complex features (interfaces, instance variables)
    # that have limitations in the legacy parser. The core array shorthand syntax is tested above.
    it "compiles TodoList example with array shorthand", pending: "Complex scenario needs parser improvements" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/todo.trb", <<~TRB)
          interface Todo
            title: String
            completed: Boolean
            tags?: String[]
          end

          class TodoList
            @todos: Todo[]

            def initialize(): void
              @todos = []
            end

            def add(title: String, tags: String[] = []): void
              todo: Todo = { title: title, completed: false, tags: tags }
              @todos << todo
            end

            def get_all(): Todo[]
              @todos.dup
            end

            def get_completed(): Todo[]
              @todos.select { |t| t[:completed] }
            end

            def get_all_tags(): String[]
              result: String[] = []
              @todos.each do |todo|
                tags = todo[:tags]
                if tags
                  result.concat(tags)
                end
              end
              result.uniq
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/todo.trb"))

        expect_valid_rbs(rbs_content)
        expect(rbs_content).to include("class TodoList")
        expect(rbs_content).to include("def get_all: () -> Array[Todo]")
        expect(rbs_content).to include("def get_all_tags: () -> Array[String]")
      end
    end
  end
end
`,
  "spec/e2e/class_rbs_generation_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"
require "rbs"

RSpec.describe "Class RBS Generation E2E" do
  let(:tmpdir) { Dir.mktmpdir("trb_class_rbs_e2e") }

  before do
    @original_dir = Dir.pwd
  end

  after do
    Dir.chdir(@original_dir)
    FileUtils.rm_rf(tmpdir)
  end

  # Helper to create config file with RBS generation enabled
  def create_config_file(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    config_path
  end

  # Helper to create a .trb file
  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  # Helper to compile and get RBS content
  def compile_and_get_rbs(trb_path, rbs_dir: "sig")
    config = TRuby::Config.new
    compiler = TRuby::Compiler.new(config)
    compiler.compile(trb_path)

    # Determine RBS path based on config
    relative_path = trb_path.sub("#{tmpdir}/src/", "")
    rbs_path = File.join(tmpdir, rbs_dir, relative_path.sub(".trb", ".rbs"))
    File.read(rbs_path) if File.exist?(rbs_path)
  end

  # Helper to normalize RBS content for comparison (ignore whitespace differences)
  def normalize_rbs(content)
    content.to_s.lines.map(&:rstrip).reject(&:empty?).join("\\n")
  end

  # Helper to validate RBS syntax using the official rbs gem
  def valid_rbs_syntax?(rbs_content)
    return false if rbs_content.nil? || rbs_content.strip.empty?

    RBS::Parser.parse_signature(rbs_content)
    true
  rescue RBS::ParsingError
    false
  end

  # Helper to assert RBS is valid and return parsed content
  def expect_valid_rbs(rbs_content)
    expect(rbs_content).not_to be_nil
    expect(rbs_content.strip).not_to be_empty

    begin
      RBS::Parser.parse_signature(rbs_content)
    rescue RBS::ParsingError => e
      raise "Generated RBS is invalid:\\n#{rbs_content}\\n\\nParsing error: #{e.message}"
    end

    rbs_content
  end

  describe "class wrapper generation" do
    it "wraps class methods in RBS class block" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/greeter.trb", <<~TRB)
          class Greeter
            def greet(): String
              "Hello"
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/greeter.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("class Greeter")
        expect(rbs_content).to include("def greet: () -> String")
        expect(rbs_content).to include("end")
      end
    end
  end

  describe "instance variable declaration" do
    it "declares instance variables assigned in initialize" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/person.trb", <<~TRB)
          class Person
            def initialize(name: String, age: Integer): void
              @name = name
              @age = age
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/person.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("class Person")
        expect(rbs_content).to include("@name: String")
        expect(rbs_content).to include("@age: Integer")
      end
    end
  end

  describe "keyword argument format" do
    it "generates RBS with keyword argument syntax (name: Type)" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/calculator.trb", <<~TRB)
          class Calculator
            def add(a: Integer, b: Integer): Integer
              a + b
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/calculator.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        # Should be keyword argument format: (a: Integer, b: Integer)
        # NOT positional format: (Integer a, Integer b)
        expect(rbs_content).to include("def add: (a: Integer, b: Integer) -> Integer")
        expect(rbs_content).not_to include("Integer a")
        expect(rbs_content).not_to include("Integer b")
      end
    end
  end

  describe "methods without type annotations" do
    it "infers return type from method body" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/mixed.trb", <<~TRB)
          class Mixed
            def typed_method(x: Integer): String
              x.to_s
            end

            def untyped_method
              "something"
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/mixed.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def typed_method: (x: Integer) -> String")
        # Type inference: returns "something" (String literal) -> String
        expect(rbs_content).to include("def untyped_method: () -> String")
      end
    end
  end

  describe "visibility modifier generation" do
    it "generates RBS with private method visibility" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/secret.trb", <<~TRB)
          class Secret
            def public_method(): String
              "public"
            end

            private def hidden(x: Integer): Boolean
              x > 0
            end

            protected def internal(name: String): String
              name.upcase
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/secret.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("class Secret")
        expect(rbs_content).to include("def public_method: () -> String")
        expect(rbs_content).to include("private def hidden: (x: Integer) -> Boolean")
        # RBS does not support protected visibility, treated as public
        # See: https://github.com/ruby/rbs/issues/579
        expect(rbs_content).to include("def internal: (name: String) -> String")
        expect(rbs_content).not_to include("protected def")
      end
    end

    it "preserves visibility in compiled Ruby code" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/visible.trb", <<~TRB)
          class Visible
            private def secret(x: String): Integer
              x.length
            end
          end
        TRB

        trb_path = File.join(tmpdir, "src/visible.trb")
        config = TRuby::Config.new
        compiler = TRuby::Compiler.new(config)
        compiler.compile(trb_path)

        # Check compiled Ruby preserves private keyword
        ruby_path = File.join(tmpdir, "build/visible.rb")
        ruby_content = File.read(ruby_path)

        expect(ruby_content).to include("private def secret")
        expect(ruby_content).not_to include(": String")
        expect(ruby_content).not_to include(": Integer")
      end
    end
  end

  describe "HelloWorld integration test" do
    it "generates correct RBS for HelloWorld sample structure" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        # This matches the structure of samples/hello/src/world.trb
        create_trb_file("src/world.trb", <<~TRB)
          class HelloWorld
            def initialize(name: String): void
              @name = name
            end

            def greet(): String
              "Hello, \\#{@name}!"
            end

            def hi
              "asdf1234!="
            end
          end

          puts HelloWorld.new("World").greet()
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/world.trb"))

        # Validate RBS syntax using official rbs gem
        expect_valid_rbs(rbs_content)

        # Should have class wrapper
        expect(rbs_content).to include("class HelloWorld")

        # Should have instance variable declaration
        expect(rbs_content).to include("@name: String")

        # Should have initialize with keyword argument format
        expect(rbs_content).to include("def initialize: (name: String) -> void")

        # Should have greet method
        expect(rbs_content).to include("def greet: () -> String")

        # Type inference: hi returns "asdf1234!=" (String literal) -> String
        expect(rbs_content).to include("def hi: () -> String")

        # Should have closing end
        expect(rbs_content).to include("end")
      end
    end
  end
end
`,
  "spec/e2e/colon_spacing_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "Colon Spacing Validation E2E" do
  let(:tmpdir) { Dir.mktmpdir("trb_colon_spacing") }
  let(:config) do
    config = TRuby::Config.new
    allow(config).to receive(:out_dir).and_return(tmpdir)
    allow(config).to receive(:ruby_dir).and_return(tmpdir)
    allow(config).to receive(:rbs_dir).and_return(tmpdir)
    allow(config).to receive(:source_include).and_return([tmpdir])
    config
  end
  let(:compiler) { TRuby::Compiler.new(config) }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  describe "Return type colon spacing" do
    context "valid syntax" do
      it "accepts colon directly after method name without parens" do
        # def method_name: Type (colon attached to method name)
        source = <<~TRB
          def t1: Integer
            1
          end
        TRB
        input_file = File.join(tmpdir, "valid1.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
        expect(colon_errors).to be_empty
      end

      it "accepts colon directly after closing paren" do
        # def method_name(): Type (colon attached to closing paren)
        source = <<~TRB
          def greet(name: String): String
            "Hello, \\#{name}!"
          end
        TRB
        input_file = File.join(tmpdir, "valid2.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
        expect(colon_errors).to be_empty
      end

      it "accepts space after colon before type" do
        source = <<~TRB
          def add(a: Integer, b: Integer): Integer
            a + b
          end
        TRB
        input_file = File.join(tmpdir, "valid3.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
        expect(colon_errors).to be_empty
      end
    end

    context "invalid syntax - space before colon" do
      it "rejects space between method name and colon (no parens)" do
        # def method_name : Type (space before colon - INVALID)
        source = <<~TRB
          def t1_space_before_colon : Integer
            1
          end
        TRB
        input_file = File.join(tmpdir, "invalid1.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("No space allowed before ':'") }).to be true
      end

      it "rejects space between closing paren and colon (empty parens)" do
        # def method_name() : Type (space before colon - INVALID)
        source = <<~TRB
          def t1_space_before_colon_with_parens() : Integer
            1
          end
        TRB
        input_file = File.join(tmpdir, "invalid2.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("No space allowed before ':'") }).to be true
      end

      it "rejects space between closing paren and colon (with params)" do
        # def method_name(params) : Type (space before colon - INVALID)
        source = <<~TRB
          def greet_with_space_before_colon(n: Integer, s: String) : Integer
            n
          end
        TRB
        input_file = File.join(tmpdir, "invalid3.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("No space allowed before ':'") }).to be true
      end
    end

    context "invalid syntax - no space after colon" do
      it "rejects colon directly attached to type name" do
        # def method_name():Type (no space after colon - INVALID)
        source = <<~TRB
          def t1_no_space_after_colon():Integer
            1
          end
        TRB
        input_file = File.join(tmpdir, "invalid4.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("Space required after ':'") }).to be true
      end

      it "rejects colon directly attached to type name (no parens)" do
        # def method_name:Type (no space after colon - INVALID)
        source = <<~TRB
          def t1_no_space_after_colon_no_parens:Integer
            1
          end
        TRB
        input_file = File.join(tmpdir, "invalid5.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("Space required after ':'") }).to be true
      end
    end
  end

  describe "Unicode method names" do
    it "validates colon spacing for Korean method names" do
      source = <<~TRB
        def 한글_메서드(): String
          "안녕하세요"
        end
      TRB
      input_file = File.join(tmpdir, "korean.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
      expect(colon_errors).to be_empty
    end

    it "rejects space before colon for Korean method names" do
      source = <<~TRB
        def 한글_메서드_에러() : String
          "안녕하세요"
        end
      TRB
      input_file = File.join(tmpdir, "korean_error.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:success]).to be false
      expect(result[:diagnostics].any? { |d| d.message.include?("No space allowed before ':'") }).to be true
    end
  end

  describe "Complex signatures" do
    it "validates colon spacing for generic return types" do
      source = <<~TRB
        def get_array(): Array<String>
          []
        end
      TRB
      input_file = File.join(tmpdir, "generic.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
      expect(colon_errors).to be_empty
    end

    it "validates colon spacing for union return types" do
      source = <<~TRB
        def maybe_string(): String | nil
          nil
        end
      TRB
      input_file = File.join(tmpdir, "union.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
      expect(colon_errors).to be_empty
    end

    it "validates colon spacing for nullable return types" do
      source = <<~TRB
        def find_user(id: Integer): String?
          nil
        end
      TRB
      input_file = File.join(tmpdir, "nullable.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
      expect(colon_errors).to be_empty
    end

    it "validates colon spacing with visibility modifiers" do
      source = <<~TRB
        private def secret_method(): Integer
          42
        end
      TRB
      input_file = File.join(tmpdir, "visibility.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.message.include?("colon") || d.message.include?("':'") }
      expect(colon_errors).to be_empty
    end
  end

  describe "Error message format" do
    it "includes error code TR1003 for colon spacing errors" do
      source = <<~TRB
        def bad_spacing() : Integer
          1
        end
      TRB
      input_file = File.join(tmpdir, "error_code.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_error = result[:diagnostics].find { |d| d.message.include?("No space allowed before ':'") }
      expect(colon_error).not_to be_nil
      expect(colon_error.code).to eq("TR1003")
    end

    it "includes line number in diagnostic" do
      source = <<~TRB
        def valid_method(): Integer
          1
        end

        def bad_spacing() : Integer
          2
        end
      TRB
      input_file = File.join(tmpdir, "line_number.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_error = result[:diagnostics].find { |d| d.message.include?("No space allowed before ':'") }
      expect(colon_error).not_to be_nil
      expect(colon_error.line).to eq(5)
    end
  end

  describe "Multiple errors" do
    it "reports all colon spacing errors in a file" do
      source = <<~TRB
        def error1() : Integer
          1
        end

        def error2():Integer
          2
        end

        def valid(): Integer
          3
        end
      TRB
      input_file = File.join(tmpdir, "multiple.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      colon_errors = result[:diagnostics].select { |d| d.code == "TR1003" }
      expect(colon_errors.length).to eq(2)
    end
  end

  describe "Hash literal type parsing" do
    it "parses hash literal type in parameter" do
      source = <<~TRB
        def process_config(config: { host: String, port: Integer }): String
          config[:host]
        end
      TRB
      input_file = File.join(tmpdir, "hash_literal1.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses hash literal type with default values" do
      source = <<~TRB
        def with_defaults(opts: { name: String, age: Integer = 0 }): String
          opts[:name]
        end
      TRB
      input_file = File.join(tmpdir, "hash_literal2.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses keyword arguments with braces" do
      source = <<~TRB
        def greet({ name: String, prefix: String = "Hello" }): String
          "\\#{prefix}, \\#{name}!"
        end
      TRB
      input_file = File.join(tmpdir, "keyword_args1.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses mixed positional and keyword arguments" do
      source = <<~TRB
        def mixed(id: Integer, { name: String, age: Integer = 0 }): String
          "\\#{id}: \\#{name}"
        end
      TRB
      input_file = File.join(tmpdir, "mixed_args.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses interface reference style keyword arguments" do
      source = <<~TRB
        interface Options
          name: String
          limit?: Integer
        end

        def fetch({ name:, limit: 10 }: Options): String
          name
        end
      TRB
      input_file = File.join(tmpdir, "interface_ref.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses double splat keyword arguments" do
      source = <<~TRB
        def forward(**opts: Hash): String
          opts.to_s
        end
      TRB
      input_file = File.join(tmpdir, "double_splat.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end
  end

  describe "Unicode identifier support" do
    it "parses Korean function names" do
      source = <<~TRB
        def 인사하기(이름: String): String
          "안녕, \\#{이름}!"
        end
      TRB
      input_file = File.join(tmpdir, "korean.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end

    it "parses Korean function names with return type validation" do
      source = <<~TRB
        def 계산하기(값: Integer): Integer
          값 * 2
        end
      TRB
      input_file = File.join(tmpdir, "korean2.trb")
      File.write(input_file, source)

      result = compiler.compile_with_diagnostics(input_file)
      expect(result[:diagnostics]).to be_empty
      expect(result[:success]).to be true
    end
  end

  describe "Invalid method name syntax" do
    context "method name with spaces" do
      it "rejects method name containing spaces (unexpected identifier)" do
        # def 함수명 자체가 올바르지_않은_경우 (n: Integer, s: String): Integer
        # '함수명' becomes the method name, '자체가' is unexpected
        source = <<~TRB
          def 함수명 자체가 올바르지_않은_경우 (n: Integer, s: String): Integer
              n
          end
        TRB
        input_file = File.join(tmpdir, "invalid_method_name.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("method names cannot contain spaces") }).to be true
      end

      it "rejects ASCII method name with spaces" do
        source = <<~TRB
          def method name with spaces(n: Integer): Integer
              n
          end
        TRB
        input_file = File.join(tmpdir, "invalid_ascii_method_name.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        expect(result[:diagnostics].any? { |d| d.message.include?("method names cannot contain spaces") }).to be true
      end

      it "reports accurate error message with method name and unexpected token" do
        source = <<~TRB
          def foo bar(x: Integer): Integer
              x
          end
        TRB
        input_file = File.join(tmpdir, "method_name_error_message.trb")
        File.write(input_file, source)

        result = compiler.compile_with_diagnostics(input_file)
        expect(result[:success]).to be false
        error = result[:diagnostics].find { |d| d.message.include?("cannot contain spaces") }
        expect(error).not_to be_nil
        expect(error.message).to include("'bar'") # The unexpected token
        expect(error.message).to include("'foo'") # The parsed method name
      end
    end
  end
end
`,
  "spec/e2e/compiler_options_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "Compiler Options E2E Behavior" do
  let(:tmpdir) { Dir.mktmpdir("trb_compiler_e2e") }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  # Helper to create config and return Config object
  def create_project_config(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }
  end

  # Helper to create a .trb file
  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  describe "compiler.strictness" do
    # NOTE: strictness levels are defined but not yet enforced in the compiler.
    # These tests document the expected behavior once implemented.

    describe "strict mode" do
      it "validates strictness config value" do
        config = create_project_config(<<~YAML)
          compiler:
            strictness: strict
        YAML

        expect(config.strictness).to eq("strict")
      end

      # TODO: Implement strict mode in compiler
      # When implemented, this test should pass
      xit "rejects functions without explicit return types" do
        config = create_project_config(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
          compiler:
            strictness: strict
        YAML

        # Function without return type should error in strict mode
        create_trb_file("src/no_return.trb", <<~TRB)
          def greet(name: String)
            "Hello, \\#{name}"
          end
        TRB

        compiler = TRuby::Compiler.new(config)
        expect do
          compiler.compile(File.join(tmpdir, "src/no_return.trb"))
        end.to raise_error(/return type/)
      end
    end

    describe "standard mode (default)" do
      it "allows functions without explicit return types" do
        config = create_project_config(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
          compiler:
            strictness: standard
        YAML

        create_trb_file("src/flexible.trb", <<~TRB)
          def greet(name: String)
            "Hello, \\#{name}"
          end
        TRB

        compiler = TRuby::Compiler.new(config)
        expect do
          compiler.compile(File.join(tmpdir, "src/flexible.trb"))
        end.not_to raise_error
      end
    end

    describe "permissive mode" do
      it "validates permissive config value" do
        config = create_project_config(<<~YAML)
          compiler:
            strictness: permissive
        YAML

        expect(config.strictness).to eq("permissive")
      end

      it "allows any valid T-Ruby syntax" do
        config = create_project_config(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
          compiler:
            strictness: permissive
        YAML

        create_trb_file("src/loose.trb", <<~TRB)
          def process(x)
            x
          end
        TRB

        compiler = TRuby::Compiler.new(config)
        expect do
          compiler.compile(File.join(tmpdir, "src/loose.trb"))
        end.not_to raise_error
      end
    end

    it "rejects invalid strictness values" do
      expect do
        config = create_project_config(<<~YAML)
          compiler:
            strictness: invalid_value
        YAML
        config.validate!
      end.to raise_error(TRuby::ConfigError, /Invalid compiler.strictness/)
    end
  end

  describe "compiler.checks.no_implicit_any" do
    # NOTE: This check is defined but not yet enforced in the compiler.
    # These tests document the expected behavior once implemented.

    it "reads the config value correctly" do
      config_enabled = create_project_config(<<~YAML)
        compiler:
          checks:
            no_implicit_any: true
      YAML

      config_disabled = create_project_config(<<~YAML)
        compiler:
          checks:
            no_implicit_any: false
      YAML

      expect(config_enabled.check_no_implicit_any?).to be true
      expect(config_disabled.check_no_implicit_any?).to be false
    end

    # TODO: Implement no_implicit_any check in compiler
    xit "errors when parameter has no type annotation" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: build
        compiler:
          checks:
            no_implicit_any: true
      YAML

      create_trb_file("src/implicit_any.trb", <<~TRB)
        def process(x)
          x * 2
        end
      TRB

      compiler = TRuby::Compiler.new(config)
      expect do
        compiler.compile(File.join(tmpdir, "src/implicit_any.trb"))
      end.to raise_error(/implicit any|type annotation required/i)
    end

    it "allows untyped parameters when disabled (default)" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: build
        compiler:
          checks:
            no_implicit_any: false
      YAML

      create_trb_file("src/allow_any.trb", <<~TRB)
        def process(x)
          x * 2
        end
      TRB

      compiler = TRuby::Compiler.new(config)
      expect do
        compiler.compile(File.join(tmpdir, "src/allow_any.trb"))
      end.not_to raise_error
    end
  end

  describe "compiler.checks.no_unused_vars" do
    # NOTE: This check is defined but not yet enforced in the compiler.
    # These tests document the expected behavior once implemented.

    it "reads the config value correctly" do
      config = create_project_config(<<~YAML)
        compiler:
          checks:
            no_unused_vars: true
      YAML

      expect(config.check_no_unused_vars?).to be true
    end

    # TODO: Implement no_unused_vars check in compiler
    xit "warns about unused local variables" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: build
        compiler:
          checks:
            no_unused_vars: true
      YAML

      create_trb_file("src/unused.trb", <<~TRB)
        def calculate(x: Integer): Integer
          unused = 42
          x * 2
        end
      TRB

      compiler = TRuby::Compiler.new(config)
      # Should warn or error about unused variable
      expect do
        compiler.compile(File.join(tmpdir, "src/unused.trb"))
      end.to raise_error(/unused.*unused/i)
    end
  end

  describe "compiler.checks.strict_nil" do
    # NOTE: This check is defined but not yet enforced in the compiler.
    # These tests document the expected behavior once implemented.

    it "reads the config value correctly" do
      config = create_project_config(<<~YAML)
        compiler:
          checks:
            strict_nil: true
      YAML

      expect(config.check_strict_nil?).to be true
    end

    # TODO: Implement strict_nil check in compiler
    xit "requires explicit nil handling" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: build
        compiler:
          checks:
            strict_nil: true
      YAML

      # Function returns String | nil but caller doesn't handle nil
      create_trb_file("src/nil_unsafe.trb", <<~TRB)
        def find_user(id: Integer): String | nil
          nil
        end

        def greet_user(id: Integer): String
          user = find_user(id)
          "Hello, \\#{user}"  # Unsafe: user could be nil
        end
      TRB

      compiler = TRuby::Compiler.new(config)
      expect do
        compiler.compile(File.join(tmpdir, "src/nil_unsafe.trb"))
      end.to raise_error(/nil|null/i)
    end
  end

  describe "compiler.target_ruby" do
    it "reads the target Ruby version" do
      config = create_project_config(<<~YAML)
        compiler:
          target_ruby: "3.2"
      YAML

      expect(config.target_ruby).to eq("3.2")
    end

    it "auto-detects from current Ruby version when not specified" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
      YAML

      expected = "#{RUBY_VERSION.split(".")[0]}.#{RUBY_VERSION.split(".")[1]}"
      expect(config.target_ruby).to eq(expected)
    end

    it "raises error for unsupported Ruby version" do
      config = create_project_config(<<~YAML)
        compiler:
          target_ruby: "2.7"
      YAML

      expect { config.target_ruby }.to raise_error(TRuby::UnsupportedRubyVersionError)
    end
  end

  describe "compiler.experimental" do
    it "reads experimental features list" do
      config = create_project_config(<<~YAML)
        compiler:
          experimental:
            - decorators
            - pattern_matching_types
      YAML

      expect(config.experimental_features).to eq(%w[decorators pattern_matching_types])
      expect(config.experimental_enabled?("decorators")).to be true
      expect(config.experimental_enabled?("pattern_matching_types")).to be true
      expect(config.experimental_enabled?("nonexistent")).to be false
    end

    it "defaults to empty array" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
      YAML

      expect(config.experimental_features).to eq([])
    end

    # TODO: When experimental features are implemented, add tests for each
  end
end
`,
  "spec/e2e/config_behavior_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "Config Options E2E Behavior" do
  let(:tmpdir) { Dir.mktmpdir("trb_config_e2e") }

  before do
    @original_dir = Dir.pwd
  end

  after do
    Dir.chdir(@original_dir)
    FileUtils.rm_rf(tmpdir)
  end

  # Helper to create config file
  def create_config_file(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    config_path
  end

  # Helper to create a .trb file
  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  describe "output.ruby_dir" do
    it "compiles files to the specified output directory" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: custom_build
        YAML

        create_trb_file("src/hello.trb", <<~TRB)
          def greet(name: String): String
            "Hello, \\#{name}"
          end
        TRB

        config = TRuby::Config.new
        compiler = TRuby::Compiler.new(config)
        compiler.compile(File.join(tmpdir, "src/hello.trb"))

        expect(File.exist?(File.join(tmpdir, "custom_build/hello.rb"))).to be true
        expect(File.exist?(File.join(tmpdir, "build/hello.rb"))).to be false
      end
    end
  end

  describe "output.rbs_dir" do
    it "generates RBS files to separate directory when specified" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/types.trb", <<~TRB)
          def calculate(x: Integer, y: Integer): Integer
            x + y
          end
        TRB

        config = TRuby::Config.new
        compiler = TRuby::Compiler.new(config)
        compiler.compile(File.join(tmpdir, "src/types.trb"))

        expect(File.exist?(File.join(tmpdir, "build/types.rb"))).to be true
        expect(File.exist?(File.join(tmpdir, "sig/types.rbs"))).to be true
      end
    end
  end

  describe "directory structure preservation" do
    context "with single source_include directory" do
      it "excludes source dir name from output path" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: build
          YAML

          create_trb_file("src/models/user.trb", <<~TRB)
            def find_user(id: Integer): String
              "user"
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/models/user.trb"))

          # Single source_include: src/models/user.trb → build/models/user.rb
          expect(File.exist?(File.join(tmpdir, "build/models/user.rb"))).to be true
        end
      end
    end

    context "with multiple source_include directories" do
      it "includes source dir name in output path" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
                - lib
            output:
              ruby_dir: build
          YAML

          create_trb_file("src/models/user.trb", <<~TRB)
            def find_user(id: Integer): String
              "user"
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/models/user.trb"))

          # Multiple source_include: src/models/user.trb → build/src/models/user.rb
          expect(File.exist?(File.join(tmpdir, "build/src/models/user.rb"))).to be true
        end
      end
    end
  end

  describe "output.clean_before_build" do
    # NOTE: clean_before_build is not yet implemented in Compiler
    context "when true" do
      xit "cleans output directory before compiling" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: build
              clean_before_build: true
          YAML

          FileUtils.mkdir_p(File.join(tmpdir, "build"))
          old_file = File.join(tmpdir, "build/old_file.rb")
          File.write(old_file, "# old content")

          create_trb_file("src/new.trb", <<~TRB)
            def new_func: void
              puts "new"
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/new.trb"))

          expect(File.exist?(old_file)).to be false
          expect(File.exist?(File.join(tmpdir, "build/new.rb"))).to be true
        end
      end
    end

    context "when false (default)" do
      it "preserves existing files in output directory" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: build
              clean_before_build: false
          YAML

          FileUtils.mkdir_p(File.join(tmpdir, "build"))
          old_file = File.join(tmpdir, "build/old_file.rb")
          File.write(old_file, "# old content")

          create_trb_file("src/new.trb", <<~TRB)
            def new_func: void
              puts "new"
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/new.trb"))

          expect(File.exist?(old_file)).to be true
          expect(File.exist?(File.join(tmpdir, "build/new.rb"))).to be true
        end
      end
    end
  end

  describe "compiler.generate_rbs" do
    context "when true" do
      it "generates RBS files alongside Ruby files" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: build
            compiler:
              generate_rbs: true
          YAML

          create_trb_file("src/typed.trb", <<~TRB)
            def typed_func(x: Integer): String
              x.to_s
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/typed.trb"))

          expect(File.exist?(File.join(tmpdir, "build/typed.rb"))).to be true
          expect(File.exist?(File.join(tmpdir, "build/typed.rbs"))).to be true

          rbs_content = File.read(File.join(tmpdir, "build/typed.rbs"))
          expect(rbs_content).to include("def typed_func")
        end
      end
    end

    context "when false" do
      it "does not generate RBS files" do
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: build
            compiler:
              generate_rbs: false
          YAML

          create_trb_file("src/no_rbs.trb", <<~TRB)
            def no_rbs_func(x: Integer): String
              x.to_s
            end
          TRB

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/no_rbs.trb"))

          expect(File.exist?(File.join(tmpdir, "build/no_rbs.rb"))).to be true
          expect(File.exist?(File.join(tmpdir, "build/no_rbs.rbs"))).to be false
        end
      end
    end
  end

  describe "source.include (multiple directories)" do
    it "finds files from all include directories" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
              - lib
              - app/models
        YAML

        create_trb_file("src/main.trb", "def main: void\\nend")
        create_trb_file("lib/utils.trb", "def utils: void\\nend")
        create_trb_file("app/models/user.trb", "def user: void\\nend")

        config = TRuby::Config.new
        files = config.find_source_files

        expect(files.size).to eq(3)
        expect(files.map { |f| File.basename(f) }).to contain_exactly("main.trb", "utils.trb", "user.trb")
      end
    end
  end

  describe "source.exclude" do
    it "excludes files matching patterns" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
            exclude:
              - "*_test.trb"
              - "*_spec.trb"
              - vendor
        YAML

        create_trb_file("src/main.trb", "def main: void\\nend")
        create_trb_file("src/main_test.trb", "def test: void\\nend")
        create_trb_file("src/main_spec.trb", "def spec: void\\nend")
        create_trb_file("src/vendor/external.trb", "def external: void\\nend")

        config = TRuby::Config.new
        files = config.find_source_files

        expect(files.size).to eq(1)
        expect(files.first).to end_with("main.trb")
      end
    end
  end

  describe "source.extensions" do
    it "recognizes custom file extensions" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
            extensions:
              - ".trb"
              - ".truby"
        YAML

        create_trb_file("src/standard.trb", "def standard: void\\nend")
        create_trb_file("src/custom.truby", "def custom: void\\nend")
        File.write(File.join(tmpdir, "src/ignored.rb"), "def ignored; end")

        config = TRuby::Config.new
        files = config.find_source_files

        expect(files.size).to eq(2)
        expect(files.map { |f| File.extname(f) }).to contain_exactly(".trb", ".truby")
      end
    end
  end

  describe "watch mode with custom directory" do
    it "watches only specified directory, not config source.include" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
        YAML

        create_trb_file("src/in_src.trb", "def in_src: void\\nend")
        create_trb_file("lib/in_lib.trb", "def in_lib: void\\nend")

        config = TRuby::Config.new
        lib_dir = File.join(tmpdir, "lib")
        watcher = TRuby::Watcher.new(paths: [lib_dir], config: config)

        trb_files = watcher.send(:find_trb_files)
        expect(trb_files.size).to eq(1)
        expect(trb_files.first).to include("in_lib.trb")
      end
    end

    it "watches config source.include directories when no path specified" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
              - lib
          output:
            ruby_dir: build
        YAML

        create_trb_file("src/in_src.trb", "def in_src: void\\nend")
        create_trb_file("lib/in_lib.trb", "def in_lib: void\\nend")
        create_trb_file("other/ignored.trb", "def ignored: void\\nend")

        config = TRuby::Config.new
        watcher = TRuby::Watcher.new(paths: ["."], config: config)
        trb_files = watcher.send(:find_trb_files)

        expect(trb_files.size).to eq(2)
        expect(trb_files.map { |f| File.basename(f) }).to contain_exactly("in_src.trb", "in_lib.trb")
      end
    end
  end

  describe "CLI --config flag" do
    it "uses specified config file for compilation" do
      Dir.chdir(tmpdir) do
        default_config = File.join(tmpdir, "trbconfig.yml")
        custom_config = File.join(tmpdir, "custom.yml")

        File.write(default_config, <<~YAML)
          output:
            ruby_dir: default_build
        YAML

        File.write(custom_config, <<~YAML)
          output:
            ruby_dir: custom_build
        YAML

        create_trb_file("test.trb", "def test: void\\nend")

        config = TRuby::Config.new(custom_config)
        compiler = TRuby::Compiler.new(config)
        compiler.compile(File.join(tmpdir, "test.trb"))

        expect(File.exist?(File.join(tmpdir, "custom_build/test.rb"))).to be true
        expect(File.exist?(File.join(tmpdir, "default_build/test.rb"))).to be false
      end
    end
  end

  describe "environment variable expansion" do
    it "expands environment variables in config values" do
      ENV["TRC_TEST_OUTPUT"] = "env_build"
      begin
        Dir.chdir(tmpdir) do
          create_config_file(<<~YAML)
            source:
              include:
                - src
            output:
              ruby_dir: \${TRC_TEST_OUTPUT}
          YAML

          create_trb_file("src/env_test.trb", "def env_test: void\\nend")

          config = TRuby::Config.new
          compiler = TRuby::Compiler.new(config)
          compiler.compile(File.join(tmpdir, "src/env_test.trb"))

          expect(File.exist?(File.join(tmpdir, "env_build/env_test.rb"))).to be true
        end
      ensure
        ENV.delete("TRC_TEST_OUTPUT")
      end
    end

    it "uses default value when env var is not set" do
      ENV.delete("TRC_NONEXISTENT")

      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: \${TRC_NONEXISTENT:-fallback_build}
        YAML

        create_trb_file("src/fallback.trb", "def fallback: void\\nend")

        config = TRuby::Config.new
        compiler = TRuby::Compiler.new(config)
        compiler.compile(File.join(tmpdir, "src/fallback.trb"))

        expect(File.exist?(File.join(tmpdir, "fallback_build/fallback.rb"))).to be true
      end
    end
  end

  describe "version requirement" do
    it "raises error when version requirement is not satisfied" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          version: ">=99.0.0"
          source:
            include:
              - src
        YAML

        config = TRuby::Config.new
        expect(config.version_satisfied?).to be false
      end
    end

    it "passes when version requirement is satisfied" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          version: ">=0.0.1"
          source:
            include:
              - src
        YAML

        config = TRuby::Config.new
        expect(config.version_satisfied?).to be true
      end
    end
  end

  describe "source and output directory separation" do
    it "find_source_files does not include files in output directory" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
        YAML

        create_trb_file("src/main.trb", "def main: void\\nend")
        create_trb_file("build/compiled.trb", "def compiled: void\\nend")

        config = TRuby::Config.new
        files = config.find_source_files

        expect(files.size).to eq(1)
        expect(files.first).to end_with("main.trb")
        expect(files.none? { |f| f.include?("build/") }).to be true
      end
    end

    it "watcher only monitors source_include directories by default" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
        YAML

        FileUtils.mkdir_p(File.join(tmpdir, "src"))
        FileUtils.mkdir_p(File.join(tmpdir, "build"))

        config = TRuby::Config.new
        watcher = TRuby::Watcher.new(config: config)

        dirs = watcher.send(:watch_directories)
        expect(dirs).to eq([File.expand_path("src")])
        expect(dirs.none? { |d| d.include?("build") }).to be true
      end
    end
  end
end
`,
  "spec/e2e/integration_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "T-Ruby E2E Integration" do
  let(:tmpdir) { Dir.mktmpdir("trb_e2e") }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  describe "Full compilation pipeline" do
    it "compiles a complete T-Ruby project" do
      # Create a mini project structure
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      # Create trbconfig.yml config to set output dir
      File.write(File.join(tmpdir, "trbconfig.yml"), <<~YAML)
        emit:
          rb: true
          rbs: false
          dtrb: false
        paths:
          src: "#{lib_dir}"
          out: "#{lib_dir}"
      YAML

      # Main application file
      File.write(File.join(lib_dir, "app.trb"), <<~TRB)
        # Application entry point
        type AppConfig = {
          name: String,
          version: String,
          debug: Boolean
        }

        interface Logger
          info: void
          warn: void
          error: void
        end

        def initialize_app(config: AppConfig): Boolean
          puts "Initializing \\#{config[:name]}"
          true
        end

        def run(args: Array<String>): Integer
          0
        end
      TRB

      # Model file
      File.write(File.join(lib_dir, "user.trb"), <<~TRB)
        type UserId = Integer
        type Email = String

        interface User
          id: UserId
          email: Email
          name: String
          active?: Boolean
        end

        def find_user(id: UserId): User | nil
          nil
        end

        def create_user(email: Email, name: String): User
          { id: 1, email: email, name: name, active?: true }
        end
      TRB

      # Compile all files with custom config (disable type checking for this test)
      config = TRuby::Config.new(File.join(tmpdir, "trbconfig.yml"))
      allow(config).to receive(:type_check?).and_return(false)
      compiler = TRuby::Compiler.new(config)

      trb_files = Dir.glob(File.join(lib_dir, "*.trb"))
      expect(trb_files.size).to eq(2)

      trb_files.each do |file|
        expect { compiler.compile(file) }.not_to raise_error
        output_file = file.sub(".trb", ".rb")
        expect(File.exist?(output_file)).to be true
      end
    end

    it "handles incremental compilation correctly" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      # Create trbconfig.yml config to set output dir
      File.write(File.join(tmpdir, "trbconfig.yml"), <<~YAML)
        emit:
          rb: true
          rbs: false
          dtrb: false
        paths:
          src: "#{lib_dir}"
          out: "#{lib_dir}"
      YAML

      # Create initial file
      file1 = File.join(lib_dir, "file1.trb")
      File.write(file1, "def hello(name: String): String\\n  \\"Hello, \\#{name}\\"\\nend")

      config = TRuby::Config.new(File.join(tmpdir, "trbconfig.yml"))
      compiler = TRuby::Compiler.new(config)
      ic = TRuby::IncrementalCompiler.new(compiler)

      # Initial compile
      ic.compile_all([file1])
      expect(File.exist?(file1.sub(".trb", ".rb"))).to be true

      # Modify file
      sleep(0.1) # Ensure mtime changes
      File.write(file1, "def hello(name: String): String\\n  \\"Hi, \\#{name}!\\"\\nend")

      # Incremental compile should detect change
      expect(ic.needs_compile?(file1)).to be true
      ic.compile_all([file1])
    end

    it "performs parallel compilation" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      # Create multiple files
      10.times do |i|
        File.write(File.join(lib_dir, "file_#{i}.trb"), <<~TRB)
          def method_#{i}(value: Integer): Integer
            value * #{i}
          end
        TRB
      end

      config = TRuby::Config.new
      compiler = TRuby::Compiler.new(config)
      processor = TRuby::ParallelProcessor.new(thread_count: 4)

      files = Dir.glob(File.join(lib_dir, "*.trb"))
      results = processor.process_files(files) do |file|
        compiler.compile(file)
      end

      expect(results.size).to eq(10)
      results.each do |result|
        # Each result is the output file path (string)
        expect(result).to be_a(String)
        expect(result).to end_with(".rb")
      end
    end
  end

  describe "Type checking pipeline" do
    it "validates type annotations across files" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      # File with type definitions
      File.write(File.join(lib_dir, "types.trb"), <<~TRB)
        type Status = "pending" | "active" | "completed"

        interface Task
          id: Integer
          title: String
          status: Status
        end
      TRB

      # File using the types
      File.write(File.join(lib_dir, "tasks.trb"), <<~TRB)
        def get_task(id: Integer): Task | nil
          nil
        end

        def update_status(task: Task, status: Status): Task
          task
        end
      TRB

      config = TRuby::Config.new
      compiler = TRuby::Compiler.new(config)

      files = Dir.glob(File.join(lib_dir, "*.trb"))
      files.each do |file|
        expect { compiler.compile(file) }.not_to raise_error
      end
    end

    it "detects type errors with SMT solver" do
      content = <<~TRB
        def process(value: String): Integer
          value.to_i
        end
      TRB

      parser = TRuby::Parser.new(content)
      parser.parse
      ir_program = parser.ir_program
      expect(ir_program).not_to be_nil

      type_checker = TRuby::TypeChecker.new
      result = type_checker.check_program(ir_program)
      expect(result).to be_a(Hash)
    end
  end

  describe "Watch mode" do
    it "detects file changes and recompiles" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      file = File.join(lib_dir, "watched.trb")
      File.write(file, "def original(x: Integer): Integer\\n  x\\nend")

      config = TRuby::Config.new
      watcher = TRuby::Watcher.new(paths: [lib_dir], config: config)

      # Verify watcher can be created
      expect(watcher).to be_a(TRuby::Watcher)
      expect(watcher.incremental_compiler).not_to be_nil
    end
  end

  describe "Package management" do
    it "initializes a new package" do
      pm = TRuby::PackageManager.new(project_dir: tmpdir)
      manifest = pm.init(name: "test-package")

      expect(manifest.name).to eq("test-package")
      expect(manifest.version).to eq("0.1.0")
      expect(File.exist?(File.join(tmpdir, ".trb-manifest.json"))).to be true
    end

    it "manages dependencies" do
      pm = TRuby::PackageManager.new(project_dir: tmpdir)
      pm.init(name: "test-project")

      # Register a mock package in registry
      pm.registry.register(TRuby::PackageManifest.new(
                             name: "test-types",
                             version: "1.0.0"
                           ))

      pm.add("test-types", "^1.0.0")

      manifest = TRuby::PackageManifest.load(File.join(tmpdir, ".trb-manifest.json"))
      expect(manifest.dependencies).to have_key("test-types")
    end

    it "resolves version constraints" do
      registry = TRuby::PackageRegistry.new

      # Register multiple versions
      %w[1.0.0 1.1.0 1.2.0 2.0.0].each do |version|
        registry.register(TRuby::PackageManifest.new(
                            name: "lib",
                            version: version
                          ))
      end

      resolver = TRuby::DependencyResolver.new(registry)

      # Create manifest with constraint
      manifest = TRuby::PackageManifest.new(
        name: "app",
        version: "1.0.0",
        dependencies: { "lib" => "^1.0.0" }
      )

      result = resolver.resolve(manifest)
      expect(result[:conflicts]).to be_empty
      expect(result[:resolved]["lib"]).to eq("1.2.0") # Latest 1.x
    end
  end

  describe "LSP server" do
    it "handles initialization" do
      server = TRuby::LSPServer.new

      init_result = server.handle_message({
                                            "id" => 1,
                                            "method" => "initialize",
                                            "params" => {
                                              "processId" => Process.pid,
                                              "rootUri" => "file://#{tmpdir}",
                                              "capabilities" => {},
                                            },
                                          })

      expect(init_result["result"]["capabilities"]).to be_a(Hash)
      expect(init_result["result"]["capabilities"]["textDocumentSync"]).not_to be_nil
      expect(init_result["result"]["capabilities"]["completionProvider"]).not_to be_nil
    end

    it "provides hover information" do
      server = TRuby::LSPServer.new
      server.handle_message({
                              "id" => 1,
                              "method" => "initialize",
                              "params" => {
                                "processId" => Process.pid,
                                "rootUri" => "file://#{tmpdir}",
                                "capabilities" => {},
                              },
                            })

      # Open a document (notification - no id)
      server.handle_message({
                              "method" => "textDocument/didOpen",
                              "params" => {
                                "textDocument" => {
                                  "uri" => "file://#{tmpdir}/test.trb",
                                  "languageId" => "t-ruby",
                                  "version" => 1,
                                  "text" => "def hello(name: String): String\\n  \\"Hello\\"\\nend",
                                },
                              },
                            })

      hover_result = server.handle_message({
                                             "id" => 2,
                                             "method" => "textDocument/hover",
                                             "params" => {
                                               "textDocument" => { "uri" => "file://#{tmpdir}/test.trb" },
                                               "position" => { "line" => 0, "character" => 4 },
                                             },
                                           })

      expect(hover_result).to be_a(Hash)
    end
  end

  describe "Documentation generation" do
    it "generates API documentation" do
      lib_dir = File.join(tmpdir, "lib")
      docs_dir = File.join(tmpdir, "docs")
      FileUtils.mkdir_p(lib_dir)

      File.write(File.join(lib_dir, "api.trb"), <<~TRB)
        # User type representing a system user
        type UserId = Integer

        # User interface
        interface User
          id: UserId
          name: String
        end

        # Find a user by ID
        def find_user(id: UserId): User | nil
          nil
        end
      TRB

      doc_gen = TRuby::DocGenerator.new
      doc_gen.generate([lib_dir], output_dir: docs_dir)

      expect(File.exist?(File.join(docs_dir, "index.html"))).to be true
      expect(File.exist?(File.join(docs_dir, "search-index.json"))).to be true
    end

    it "generates markdown documentation" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      File.write(File.join(lib_dir, "lib.trb"), <<~TRB)
        type Config = Hash<String, String>

        def process(config: Config): Boolean
          true
        end
      TRB

      doc_gen = TRuby::DocGenerator.new
      output_path = File.join(tmpdir, "API.md")
      doc_gen.generate_markdown([lib_dir], output_path: output_path)

      expect(File.exist?(output_path)).to be true
      content = File.read(output_path)
      expect(content).to include("Config")
      expect(content).to include("process")
    end
  end

  describe "Benchmarking" do
    it "runs benchmark suite" do
      benchmark = TRuby::BenchmarkSuite.new

      # Run just parsing benchmarks with minimal iterations
      benchmark.run_category(:parsing, iterations: 2, warmup: 1)
      results = benchmark.results[:parsing]

      expect(results).to be_a(Hash)
      expect(results.keys).to include(:small_file, :medium_file)
      results.each_value do |stats|
        expect(stats[:avg_time]).to be >= 0
        expect(stats[:min_time]).to be >= 0
        expect(stats[:max_time]).to be >= 0
      end
    end

    it "exports benchmark results" do
      benchmark = TRuby::BenchmarkSuite.new
      benchmark.run_category(:parsing, iterations: 2, warmup: 1)

      json_path = File.join(tmpdir, "benchmarks.json")
      benchmark.export_json(json_path)

      expect(File.exist?(json_path)).to be true
      data = JSON.parse(File.read(json_path))
      expect(data["results"]).to be_a(Hash)
    end
  end

  describe "Bundler integration" do
    it "generates gem type stubs" do
      gemfile_path = File.join(tmpdir, "Gemfile")
      File.write(gemfile_path, <<~GEMFILE)
        source 'https://rubygems.org'
        gem 'json'
      GEMFILE

      integration = TRuby::BundlerIntegration.new(project_dir: tmpdir)

      # Basic functionality test
      expect(integration).to be_a(TRuby::BundlerIntegration)
    end
  end

  describe "CLI interface" do
    it "parses command line arguments" do
      # Test various CLI commands
      expect { TRuby::CLI.new(["--help"]) }.not_to raise_error
    end
  end

  describe "Error handling" do
    it "provides helpful error messages for syntax errors" do
      # Parser is lenient and doesn't raise errors for incomplete constructs
      # Instead, it returns success with empty results for unparseable content
      content = "def broken(x: String" # Missing closing paren

      parser = TRuby::Parser.new(content)
      result = parser.parse

      # Parser returns success but with no parsed functions
      expect(result[:type]).to eq(:success)
      expect(result[:functions]).to be_empty
    end

    it "handles file not found gracefully" do
      config = TRuby::Config.new
      compiler = TRuby::Compiler.new(config)

      expect do
        compiler.compile("/nonexistent/file.trb")
      end.to raise_error(ArgumentError, /File not found/)
    end
  end

  describe "Cross-file type checking" do
    it "validates types across multiple files" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      File.write(File.join(lib_dir, "base.trb"), <<~TRB)
        interface Entity
          id: Integer
          created_at: Time
        end
      TRB

      File.write(File.join(lib_dir, "user.trb"), <<~TRB)
        interface User
          # extends Entity
          id: Integer
          created_at: Time
          name: String
        end
      TRB

      config = TRuby::Config.new
      compiler = TRuby::Compiler.new(config)
      checker = TRuby::CrossFileTypeChecker.new

      files = Dir.glob(File.join(lib_dir, "*.trb"))
      files.each do |file|
        ir = compiler.compile_to_ir(file)
        checker.register_file(file, ir)
      end

      result = checker.check_all
      expect(result[:errors]).to be_empty
    end
  end
end
`,
  "spec/e2e/keyword_args_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "Keyword Arguments E2E" do
  let(:tmpdir) { Dir.mktmpdir("trb_keyword_args") }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  def create_config(lib_dir)
    File.write(File.join(tmpdir, "trbconfig.yml"), <<~YAML)
      emit:
        rb: true
        rbs: true
        dtrb: false
      paths:
        src: "#{lib_dir}"
        out: "#{lib_dir}"
        rbs: "#{lib_dir}"
    YAML

    config = TRuby::Config.new(File.join(tmpdir, "trbconfig.yml"))
    allow(config).to receive(:type_check?).and_return(false)
    config
  end

  def compile_and_read(lib_dir, filename, source)
    trb_path = File.join(lib_dir, "#{filename}.trb")
    rb_path = File.join(lib_dir, "#{filename}.rb")

    File.write(trb_path, source)

    config = create_config(lib_dir)
    compiler = TRuby::Compiler.new(config)
    compiler.compile(trb_path)

    File.read(rb_path)
  end

  describe "키워드 인자 (구조분해) - 인라인 타입" do
    it "필수 키워드 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def greet({ name: String }): String
          "Hello, \\#{name}!"
        end
      TRB

      result = compile_and_read(lib_dir, "greet", source)

      expect(result).to include("def greet(name:)")
      expect(result).not_to include("String")
      expect(result).to include('"Hello, #{name}!"')
    end

    it "여러 필수 키워드 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def create_point({ x: Integer, y: Integer }): String
          "(\\#{x}, \\#{y})"
        end
      TRB

      result = compile_and_read(lib_dir, "point", source)

      expect(result).to include("def create_point(x:, y:)")
      expect(result).not_to include("Integer")
    end

    it "기본값이 있는 키워드 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def greet_with_prefix({ name: String, prefix: String = "Hello" }): String
          "\\#{prefix}, \\#{name}!"
        end
      TRB

      result = compile_and_read(lib_dir, "greet_prefix", source)

      expect(result).to include('def greet_with_prefix(name:, prefix: "Hello")')
      expect(result).not_to include("String")
    end

    it "복잡한 타입과 기본값을 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def process_data({ items: Array = [], options: Hash = {} }): Integer
          items.length
        end
      TRB

      result = compile_and_read(lib_dir, "process", source)

      expect(result).to include("def process_data(items: [], options: {})")
    end
  end

  describe "키워드 인자 (구조분해) - interface 참조" do
    it "interface 참조 키워드 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        interface UserParams
          name: String
          age: Integer
        end

        def create_user({ name:, age: }: UserParams): String
          "\\#{name} (\\#{age})"
        end
      TRB

      result = compile_and_read(lib_dir, "user", source)

      expect(result).to include("def create_user(name:, age:)")
      expect(result).not_to include("UserParams")
      expect(result).not_to include("interface")
    end

    it "기본값이 있는 interface 참조를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        interface ConnectionOptions
          host: String
          port?: Integer
          timeout?: Integer
        end

        def connect({ host:, port: 8080, timeout: 30 }: ConnectionOptions): String
          "\\#{host}:\\#{port}"
        end
      TRB

      result = compile_and_read(lib_dir, "connect", source)

      expect(result).to include("def connect(host:, port: 8080, timeout: 30)")
    end
  end

  describe "더블 스플랫 (**opts: Type)" do
    it "더블 스플랫 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        interface LogOptions
          message: String
          level?: Symbol
        end

        def log(**kwargs: LogOptions): String
          kwargs[:message]
        end
      TRB

      result = compile_and_read(lib_dir, "log", source)

      expect(result).to include("def log(**kwargs)")
      expect(result).not_to include("LogOptions")
    end
  end

  describe "Hash 리터럴 (config: { ... })" do
    it "Hash 리터럴 파라미터를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def process_config(config: { host: String, port: Integer }): String
          "\\#{config[:host]}:\\#{config[:port]}"
        end
      TRB

      result = compile_and_read(lib_dir, "config", source)

      expect(result).to include("def process_config(config)")
      expect(result).not_to include("String")
      expect(result).not_to include("Integer")
    end
  end

  describe "위치 인자 + 키워드 인자 혼합" do
    it "위치 인자와 키워드 인자 혼합을 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def format_name(name: String, { uppercase: Boolean = false }): String
          uppercase ? name.upcase : name
        end
      TRB

      result = compile_and_read(lib_dir, "format", source)

      expect(result).to include("def format_name(name, uppercase: false)")
      expect(result).not_to include("String")
      expect(result).not_to include("Boolean")
    end

    it "여러 위치 인자와 키워드 인자를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def calculate(a: Integer, b: Integer, { round: Boolean = false }): Integer
          result = a + b
          round ? result.round : result
        end
      TRB

      result = compile_and_read(lib_dir, "calc", source)

      expect(result).to include("def calculate(a, b, round: false)")
    end
  end

  describe "클래스 내부 메서드" do
    it "클래스 내 키워드 인자 메서드를 올바르게 컴파일" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        class ApiClient
          def initialize({ base_url: String, timeout: Integer = 30 })
            @base_url = base_url
            @timeout = timeout
          end

          def get({ path: String }): String
            "\\#{@base_url}\\#{path}"
          end
        end
      TRB

      result = compile_and_read(lib_dir, "api_client", source)

      expect(result).to include("def initialize(base_url:, timeout: 30)")
      expect(result).to include("def get(path:)")
      expect(result).not_to include("String")
      expect(result).not_to include("Integer")
    end
  end

  describe "기존 위치 인자 호환성" do
    it "기존 위치 인자 문법이 여전히 작동" do
      lib_dir = File.join(tmpdir, "lib")
      FileUtils.mkdir_p(lib_dir)

      source = <<~TRB
        def positional_args(name: String, age: Integer = 0): String
          "\\#{name} (\\#{age})"
        end
      TRB

      result = compile_and_read(lib_dir, "positional", source)

      expect(result).to include("def positional_args(name, age = 0)")
      expect(result).not_to include("String")
      expect(result).not_to include("Integer")
    end
  end
end
`,
  "spec/e2e/type_inference_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"
require "rbs"

RSpec.describe "Type Inference E2E" do
  let(:tmpdir) { Dir.mktmpdir("trb_type_inference_e2e") }

  before do
    @original_dir = Dir.pwd
  end

  after do
    Dir.chdir(@original_dir)
    FileUtils.rm_rf(tmpdir)
  end

  def create_config_file(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    config_path
  end

  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  def compile_and_get_rbs(trb_path, rbs_dir: "sig")
    config = TRuby::Config.new
    compiler = TRuby::Compiler.new(config)
    compiler.compile(trb_path)

    relative_path = trb_path.sub("#{tmpdir}/src/", "")
    rbs_path = File.join(tmpdir, rbs_dir, relative_path.sub(".trb", ".rbs"))
    File.read(rbs_path) if File.exist?(rbs_path)
  end

  def expect_valid_rbs(rbs_content)
    expect(rbs_content).not_to be_nil
    expect(rbs_content.strip).not_to be_empty

    begin
      RBS::Parser.parse_signature(rbs_content)
    rescue RBS::ParsingError => e
      raise "Generated RBS is invalid:\\n#{rbs_content}\\n\\nParsing error: #{e.message}"
    end

    rbs_content
  end

  describe "literal type inference" do
    it "infers String from string literal" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/literals.trb", <<~TRB)
          class Literals
            def string_method
              "hello world"
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/literals.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def string_method: () -> String")
      end
    end

    it "infers Integer from integer literal" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/int.trb", <<~TRB)
          class IntTest
            def number
              42
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/int.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def number: () -> Integer")
      end
    end

    it "infers bool from boolean literal" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/bool.trb", <<~TRB)
          class BoolTest
            def flag
              true
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/bool.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def flag: () -> bool")
      end
    end

    it "infers Symbol from symbol literal" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/sym.trb", <<~TRB)
          class SymTest
            def status
              :ok
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/sym.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def status: () -> Symbol")
      end
    end
  end

  describe "variable type inference" do
    it "infers type from instance variable assigned in initialize" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/ivar.trb", <<~TRB)
          class IvarTest
            def initialize(name: String): void
              @name = name
            end

            def get_name
              @name
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/ivar.trb"))
        expect_valid_rbs(rbs_content)

        # @name is String (from initialize parameter)
        # get_name returns @name, so it should be String
        expect(rbs_content).to include("def get_name: () -> String")
      end
    end
  end

  describe "explicit return type takes precedence" do
    it "uses explicit type over inferred type" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/explicit.trb", <<~TRB)
          class ExplicitTest
            def message(): String
              "hello"
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/explicit.trb"))
        expect_valid_rbs(rbs_content)

        # Explicit return type should be used
        expect(rbs_content).to include("def message: () -> String")
      end
    end
  end

  describe "method call type inference" do
    it "infers type from builtin method return" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/method_call.trb", <<~TRB)
          class MethodCallTest
            def shout(text: String)
              text.upcase
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/method_call.trb"))
        expect_valid_rbs(rbs_content)

        # String#upcase returns String
        expect(rbs_content).to include("def shout: (text: String) -> String")
      end
    end
  end

  describe "array literal type inference" do
    it "infers Array type with element type" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/array.trb", <<~TRB)
          class ArrayTest
            def numbers
              [1, 2, 3]
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/array.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def numbers: () -> Array[Integer]")
      end
    end
  end

  describe "initialize method inference" do
    it "infers void for initialize without explicit return type" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/init.trb", <<~TRB)
          class Person
            def initialize(name: String)
              @name = name
            end

            def greet
              "Hello"
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/init.trb"))
        expect_valid_rbs(rbs_content)

        # initialize should return void (Ruby convention for constructors)
        # The actual instance creation is done by Class.new, not initialize
        expect(rbs_content).to include("def initialize: (name: String) -> void")
      end
    end

    it "respects explicit void return type on initialize" do
      Dir.chdir(tmpdir) do
        create_config_file(<<~YAML)
          source:
            include:
              - src
          output:
            ruby_dir: build
            rbs_dir: sig
          compiler:
            generate_rbs: true
        YAML

        create_trb_file("src/init_explicit.trb", <<~TRB)
          class User
            def initialize(id: Integer): void
              @id = id
            end
          end
        TRB

        rbs_content = compile_and_get_rbs(File.join(tmpdir, "src/init_explicit.trb"))
        expect_valid_rbs(rbs_content)

        expect(rbs_content).to include("def initialize: (id: Integer) -> void")
      end
    end
  end
end
`,
  "spec/e2e/version_codegen_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tmpdir"
require "fileutils"

RSpec.describe "Version-specific code generation" do
  let(:tmpdir) { Dir.mktmpdir }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  def create_project(config_yaml, source_content)
    # Create config file
    File.write(File.join(tmpdir, "trbconfig.yml"), config_yaml)

    # Create source directory and file
    src_dir = File.join(tmpdir, "src")
    FileUtils.mkdir_p(src_dir)
    File.write(File.join(src_dir, "test.trb"), source_content)

    # Create build directory
    build_dir = File.join(tmpdir, "build")
    FileUtils.mkdir_p(build_dir)

    tmpdir
  end

  def compile_and_read_output(project_dir)
    Dir.chdir(project_dir) do
      config = TRuby::Config.new
      compiler = TRuby::Compiler.new(config)
      output_path = compiler.compile("src/test.trb")
      File.read(output_path)
    end
  end

  describe "Ruby 3.0 target" do
    it "preserves _1 numbered parameters" do
      config = <<~YAML
        compiler:
          target_ruby: "3.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def double_all(items: Array<Integer>): Array<Integer>
          items.map { _1 * 2 }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("{ _1 * 2 }")
      expect(output).not_to include("{ it * 2 }")
    end

    it "preserves named block forwarding" do
      config = <<~YAML
        compiler:
          target_ruby: "3.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def wrapper(&block: Block): void
          inner(&block)
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("def wrapper(&block)")
      expect(output).to include("inner(&block)")
    end
  end

  describe "Ruby 3.1+ target" do
    it "converts block forwarding to anonymous syntax" do
      config = <<~YAML
        compiler:
          target_ruby: "3.1"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def wrapper(&block: Block): void
          inner(&block)
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("def wrapper(&)")
      expect(output).to include("inner(&)")
    end

    it "preserves _1 numbered parameters (still valid)" do
      config = <<~YAML
        compiler:
          target_ruby: "3.2"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def process(items: Array<Integer>): Array<Integer>
          items.map { _1 * 2 }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("{ _1 * 2 }")
    end
  end

  describe "Ruby 3.4+ target" do
    it "preserves _1 syntax (still valid, it is optional)" do
      config = <<~YAML
        compiler:
          target_ruby: "3.4"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def process(items: Array<Integer>): Array<Integer>
          items.map { _1 * 2 }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      # Ruby 3.4 supports both _1 and it, so _1 is preserved
      expect(output).to include("{ _1 * 2 }")
    end

    it "uses anonymous block forwarding" do
      config = <<~YAML
        compiler:
          target_ruby: "3.4"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def wrapper(&block: Block): void
          forward(&block)
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("def wrapper(&)")
      expect(output).to include("forward(&)")
    end
  end

  describe "Ruby 4.0 target" do
    it "converts _1 to it (numbered params raise NameError)" do
      config = <<~YAML
        compiler:
          target_ruby: "4.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def double_all(items: Array<Integer>): Array<Integer>
          items.map { _1 * 2 }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("{ it * 2 }")
      expect(output).not_to include("_1")
    end

    it "converts multiple numbered params to explicit params" do
      config = <<~YAML
        compiler:
          target_ruby: "4.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def swap_pairs(hash: Hash<String, Integer>): Array<Array>
          hash.map { [_2, _1] }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      # Should convert to explicit params like |k, v|
      expect(output).to include("|k, v|")
      expect(output).not_to include("_1")
      expect(output).not_to include("_2")
    end

    it "handles nested blocks with _1" do
      config = <<~YAML
        compiler:
          target_ruby: "4.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def nested(items: Array<Array<Integer>>): Array<Array<Integer>>
          items.map { _1.map { _1 * 2 } }
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      # Both _1 should be converted to it
      expect(output).to include("{ it.map { it * 2 } }")
      expect(output).not_to include("_1")
    end

    it "uses anonymous block forwarding" do
      config = <<~YAML
        compiler:
          target_ruby: "4.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def wrapper(&block: Block): void
          forward(&block)
        end
      TRB

      create_project(config, source)
      output = compile_and_read_output(tmpdir)

      expect(output).to include("def wrapper(&)")
      expect(output).to include("forward(&)")
    end
  end

  describe "auto-detection (no target_ruby specified)" do
    it "uses current Ruby version" do
      config = <<~YAML
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def greet(name: String): String
          "Hello, \\#{name}!"
        end
      TRB

      create_project(config, source)

      Dir.chdir(tmpdir) do
        config = TRuby::Config.new
        expected_version = "#{RUBY_VERSION.split(".")[0]}.#{RUBY_VERSION.split(".")[1]}"
        expect(config.target_ruby).to eq(expected_version)
      end
    end
  end

  describe "compile_string with version option" do
    it "respects target_ruby for string compilation" do
      config = <<~YAML
        compiler:
          target_ruby: "4.0"
        source:
          include:
            - src
      YAML

      source = <<~TRB
        def double(items: Array<Integer>): Array<Integer>
          items.map { _1 * 2 }
        end
      TRB

      create_project(config, source)

      Dir.chdir(tmpdir) do
        config = TRuby::Config.new
        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_string(source)

        expect(result[:ruby]).to include("{ it * 2 }")
        expect(result[:ruby]).not_to include("_1")
      end
    end
  end
end
`,
  "spec/e2e/watch_behavior_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tempfile"
require "fileutils"

RSpec.describe "Watch Mode E2E Behavior" do
  let(:tmpdir) { Dir.mktmpdir("trb_watch_e2e") }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  # Helper to create config and return Config object
  def create_project_config(yaml_content)
    config_path = File.join(tmpdir, "trbconfig.yml")
    File.write(config_path, yaml_content)
    Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }
  end

  # Helper to create a .trb file
  def create_trb_file(relative_path, content)
    full_path = File.join(tmpdir, relative_path)
    FileUtils.mkdir_p(File.dirname(full_path))
    File.write(full_path, content)
    full_path
  end

  describe "watch.paths (additional watch paths)" do
    it "includes additional paths in watch directories" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        watch:
          paths:
            - config
            - types
      YAML

      # config.watch_paths should return the additional paths
      expect(config.watch_paths).to eq(%w[config types])
    end
  end

  describe "watch.debounce" do
    it "configures debounce delay in milliseconds" do
      config = create_project_config(<<~YAML)
        watch:
          debounce: 500
      YAML

      expect(config.watch_debounce).to eq(500)

      # Watcher should use this value (internal implementation detail)
      watcher = TRuby::Watcher.new(paths: [tmpdir], config: config)
      expect(watcher.instance_variable_get(:@config).watch_debounce).to eq(500)
    end

    it "defaults to 100ms when not specified" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
      YAML

      expect(config.watch_debounce).to eq(100)
    end
  end

  describe "watch.clear_screen" do
    it "configures screen clearing behavior" do
      config_with_clear = create_project_config(<<~YAML)
        watch:
          clear_screen: true
      YAML

      config_without_clear = create_project_config(<<~YAML)
        watch:
          clear_screen: false
      YAML

      expect(config_with_clear.watch_clear_screen?).to be true
      expect(config_without_clear.watch_clear_screen?).to be false
    end

    it "defaults to false when not specified" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
      YAML

      expect(config.watch_clear_screen?).to be false
    end
  end

  describe "watch.on_success" do
    it "configures command to run after successful compilation" do
      config = create_project_config(<<~YAML)
        watch:
          on_success: "bundle exec rspec"
      YAML

      expect(config.watch_on_success).to eq("bundle exec rspec")
    end

    it "defaults to nil when not specified" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
      YAML

      expect(config.watch_on_success).to be_nil
    end
  end

  describe "watcher file discovery" do
    it "finds .trb files only in specified directory" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: build
      YAML

      create_trb_file("src/main.trb", "def main: void\\nend")
      create_trb_file("lib/utils.trb", "def utils: void\\nend")
      create_trb_file("other/ignore.trb", "def ignore: void\\nend")

      # Watch only lib/ directory explicitly
      lib_path = File.join(tmpdir, "lib")
      watcher = TRuby::Watcher.new(paths: [lib_path], config: config)

      files = watcher.send(:find_trb_files)
      expect(files.size).to eq(1)
      expect(files.first).to end_with("utils.trb")
    end

    it "finds .rb files as well when watching" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
          extensions:
            - ".trb"
            - ".rb"
        output:
          ruby_dir: build
      YAML

      create_trb_file("src/typed.trb", "def typed: void\\nend")
      File.write(File.join(tmpdir, "src/plain.rb"), "def plain; end")

      src_path = File.join(tmpdir, "src")
      watcher = TRuby::Watcher.new(paths: [src_path], config: config)

      trb_files = watcher.send(:find_trb_files)
      rb_files = watcher.send(:find_rb_files)

      expect(trb_files.size).to eq(1)
      expect(rb_files.size).to eq(1)
    end

    it "respects exclude patterns even when watching specific directory" do
      config = create_project_config(<<~YAML)
        source:
          include:
            - src
          exclude:
            - vendor
            - "**/*_test.trb"
        output:
          ruby_dir: build
      YAML

      create_trb_file("src/main.trb", "def main: void\\nend")
      create_trb_file("src/main_test.trb", "def main_test: void\\nend")
      create_trb_file("src/vendor/external.trb", "def external: void\\nend")

      src_path = File.join(tmpdir, "src")
      watcher = TRuby::Watcher.new(paths: [src_path], config: config)

      files = watcher.send(:find_trb_files)
      expect(files.size).to eq(1)
      expect(files.first).to end_with("main.trb")
    end
  end

  describe "watcher compilation behavior" do
    it "compiles changed files to correct output directory" do
      # Create config with absolute paths
      config_path = File.join(tmpdir, "trbconfig.yml")
      File.write(config_path, <<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: #{File.join(tmpdir, "dist")}
        compiler:
          generate_rbs: false
      YAML

      config = Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }

      file_path = create_trb_file("src/watchme.trb", <<~TRB)
        def watchme(x: Integer): Integer
          x * 2
        end
      TRB

      watcher = TRuby::Watcher.new(paths: [File.join(tmpdir, "src")], config: config)

      # Trigger compile_file directly
      result = watcher.send(:compile_file, file_path)

      expect(result[:success]).to be true
      expect(File.exist?(File.join(tmpdir, "dist/watchme.rb"))).to be true
    end

    it "tracks compilation statistics" do
      # Create config with absolute paths
      config_path = File.join(tmpdir, "trbconfig.yml")
      File.write(config_path, <<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: #{File.join(tmpdir, "build")}
      YAML

      config = Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }

      create_trb_file("src/stats.trb", "def stats: void\\nend")

      watcher = TRuby::Watcher.new(paths: [File.join(tmpdir, "src")], config: config)

      expect(watcher.stats[:total_compilations]).to eq(0)

      watcher.send(:compile_file, File.join(tmpdir, "src/stats.trb"))

      expect(watcher.stats[:total_compilations]).to eq(1)
    end
  end

  describe "incremental compilation in watch mode" do
    it "skips unchanged files" do
      # Create config with absolute paths
      config_path = File.join(tmpdir, "trbconfig.yml")
      File.write(config_path, <<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: #{File.join(tmpdir, "build")}
      YAML

      config = Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }

      file_path = create_trb_file("src/incremental.trb", "def inc: void\\nend")

      watcher = TRuby::Watcher.new(
        paths: [File.join(tmpdir, "src")],
        config: config,
        incremental: true
      )

      # First compile - incremental_compiler.compile_with_ir updates stats internally
      watcher.incremental_compiler.compile_with_ir(file_path)

      # Second compile without changes - should detect no change needed
      needs_compile = watcher.incremental_compiler.needs_compile?(file_path)
      expect(needs_compile).to be false
    end

    it "detects modified files" do
      # Create config with absolute paths
      config_path = File.join(tmpdir, "trbconfig.yml")
      File.write(config_path, <<~YAML)
        source:
          include:
            - src
        output:
          ruby_dir: #{File.join(tmpdir, "build")}
      YAML

      config = Dir.chdir(tmpdir) { TRuby::Config.new(config_path) }

      file_path = create_trb_file("src/modified.trb", "def original: void\\nend")

      watcher = TRuby::Watcher.new(
        paths: [File.join(tmpdir, "src")],
        config: config,
        incremental: true
      )

      # First compile
      watcher.incremental_compiler.compile_with_ir(file_path)

      # Modify the file
      sleep(0.1) # Ensure mtime changes
      File.write(file_path, "def modified: void\\nend")

      # Should detect change
      needs_compile = watcher.incremental_compiler.needs_compile?(file_path)
      expect(needs_compile).to be true
    end
  end
end
`,
  "spec/spec_helper.rb": `# frozen_string_literal: true

require "tmpdir"
require "fileutils"

# SimpleCov configuration for code coverage tracking
if ENV["COVERAGE"]
  require "simplecov"
  require "simplecov-lcov"

  SimpleCov::Formatter::LcovFormatter.config do |c|
    c.report_with_single_file = true
    c.single_report_path = "coverage/lcov.info"
  end

  SimpleCov.formatters = SimpleCov::Formatter::MultiFormatter.new(
    [
      SimpleCov::Formatter::HTMLFormatter,
      SimpleCov::Formatter::LcovFormatter,
    ]
  )

  SimpleCov.start do
    add_filter "/spec/"
    add_filter "/bin/"

    add_group "Libraries", "/lib/"
    add_group "CLI", "/lib/t_ruby/cli"
    add_group "Compiler", "/lib/t_ruby/compiler"
    add_group "Config", "/lib/t_ruby/config"
    add_group "Version", "/lib/t_ruby/version"
  end
end

# Load the t-ruby library
$LOAD_PATH.unshift File.expand_path("../lib", __dir__)
require "t_ruby"

# RSpec configuration
RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups

  # Run specs in random order
  config.order = :random

  # Optional: set seed for reproducible test order
  Kernel.srand config.seed
end
`,
  "spec/t_ruby/ast_type_inferrer_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ASTTypeInferrer do
  subject(:inferrer) { described_class.new }

  let(:env) { TRuby::TypeEnv.new }

  describe "#infer_expression" do
    context "with literals" do
      it "infers String from string literal" do
        node = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        expect(inferrer.infer_expression(node, env)).to eq("String")
      end

      it "infers Integer from integer literal" do
        node = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
        expect(inferrer.infer_expression(node, env)).to eq("Integer")
      end

      it "infers Float from float literal" do
        node = TRuby::IR::Literal.new(value: 3.14, literal_type: :float)
        expect(inferrer.infer_expression(node, env)).to eq("Float")
      end

      it "infers bool from boolean literal" do
        node = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
        expect(inferrer.infer_expression(node, env)).to eq("bool")
      end

      it "infers Symbol from symbol literal" do
        node = TRuby::IR::Literal.new(value: :ok, literal_type: :symbol)
        expect(inferrer.infer_expression(node, env)).to eq("Symbol")
      end

      it "infers nil from nil literal" do
        node = TRuby::IR::Literal.new(value: nil, literal_type: :nil)
        expect(inferrer.infer_expression(node, env)).to eq("nil")
      end
    end

    context "with variable references" do
      it "looks up variable type from environment" do
        env.define("name", "String")
        node = TRuby::IR::VariableRef.new(name: "name", scope: :local)

        expect(inferrer.infer_expression(node, env)).to eq("String")
      end

      it "returns untyped for undefined variable" do
        node = TRuby::IR::VariableRef.new(name: "unknown", scope: :local)
        expect(inferrer.infer_expression(node, env)).to eq("untyped")
      end

      it "looks up instance variable type" do
        env.define_instance_var("@name", "String")
        node = TRuby::IR::VariableRef.new(name: "@name", scope: :instance)

        expect(inferrer.infer_expression(node, env)).to eq("String")
      end
    end

    context "with binary operations" do
      it "infers bool from comparison operators" do
        left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        node = TRuby::IR::BinaryOp.new(operator: "==", left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("bool")
      end

      it "infers Integer from integer arithmetic" do
        left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        node = TRuby::IR::BinaryOp.new(operator: "+", left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("Integer")
      end

      it "infers Float when one operand is Float" do
        left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2.5, literal_type: :float)
        node = TRuby::IR::BinaryOp.new(operator: "+", left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("Float")
      end

      it "infers String from string concatenation" do
        left = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        right = TRuby::IR::Literal.new(value: " world", literal_type: :string)
        node = TRuby::IR::BinaryOp.new(operator: "+", left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("String")
      end
    end

    context "with method calls" do
      it "infers type from builtin String methods" do
        receiver = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        node = TRuby::IR::MethodCall.new(
          receiver: receiver,
          method_name: "upcase",
          arguments: []
        )

        expect(inferrer.infer_expression(node, env)).to eq("String")
      end

      it "infers Integer from String#length" do
        receiver = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        node = TRuby::IR::MethodCall.new(
          receiver: receiver,
          method_name: "length",
          arguments: []
        )

        expect(inferrer.infer_expression(node, env)).to eq("Integer")
      end

      it "infers bool from predicate methods" do
        receiver = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        node = TRuby::IR::MethodCall.new(
          receiver: receiver,
          method_name: "empty?",
          arguments: []
        )

        expect(inferrer.infer_expression(node, env)).to eq("bool")
      end

      it "infers class instance from new method" do
        receiver = TRuby::IR::VariableRef.new(name: "MyClass", scope: :constant)
        node = TRuby::IR::MethodCall.new(
          receiver: receiver,
          method_name: "new",
          arguments: []
        )

        expect(inferrer.infer_expression(node, env)).to eq("MyClass")
      end
    end

    context "with array literals" do
      it "infers Array[Integer] from integer array" do
        elements = [
          TRuby::IR::Literal.new(value: 1, literal_type: :integer),
          TRuby::IR::Literal.new(value: 2, literal_type: :integer),
        ]
        node = TRuby::IR::ArrayLiteral.new(elements: elements)

        expect(inferrer.infer_expression(node, env)).to eq("Array[Integer]")
      end

      it "infers Array[untyped] from empty array" do
        node = TRuby::IR::ArrayLiteral.new(elements: [])
        expect(inferrer.infer_expression(node, env)).to eq("Array[untyped]")
      end
    end

    context "with assignments" do
      it "registers variable type and returns value type" do
        value = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        node = TRuby::IR::Assignment.new(target: "name", value: value)

        result = inferrer.infer_expression(node, env)

        expect(result).to eq("String")
        expect(env.lookup("name")).to eq("String")
      end

      it "registers instance variable type" do
        value = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
        node = TRuby::IR::Assignment.new(target: "@count", value: value)

        inferrer.infer_expression(node, env)

        expect(env.lookup_instance_var("@count")).to eq("Integer")
      end
    end

    context "with blocks" do
      it "returns last statement type" do
        stmts = [
          TRuby::IR::Assignment.new(
            target: "x",
            value: TRuby::IR::Literal.new(value: 1, literal_type: :integer)
          ),
          TRuby::IR::Literal.new(value: "done", literal_type: :string),
        ]
        node = TRuby::IR::Block.new(statements: stmts)

        expect(inferrer.infer_expression(node, env)).to eq("String")
      end

      it "returns nil for empty block" do
        node = TRuby::IR::Block.new(statements: [])
        expect(inferrer.infer_expression(node, env)).to eq("nil")
      end
    end
  end

  describe "#infer_method_return_type" do
    it "infers return type from method body" do
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::Literal.new(value: "hello", literal_type: :string),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "greet",
        params: [],
        return_type: nil,
        body: body
      )

      expect(inferrer.infer_method_return_type(method)).to eq("String")
    end

    it "infers type from explicit return" do
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::Return.new(
            value: TRuby::IR::Literal.new(value: 42, literal_type: :integer)
          ),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "number",
        params: [],
        return_type: nil,
        body: body
      )

      expect(inferrer.infer_method_return_type(method)).to eq("Integer")
    end

    it "uses parameter types in body analysis" do
      param = TRuby::IR::Parameter.new(
        name: "text",
        type_annotation: TRuby::IR::SimpleType.new(name: "String")
      )
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::MethodCall.new(
            receiver: TRuby::IR::VariableRef.new(name: "text", scope: :local),
            method_name: "upcase",
            arguments: []
          ),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "shout",
        params: [param],
        return_type: nil,
        body: body
      )

      expect(inferrer.infer_method_return_type(method)).to eq("String")
    end

    it "returns nil when method has no body" do
      method = TRuby::IR::MethodDef.new(
        name: "empty",
        params: [],
        return_type: nil,
        body: nil
      )

      expect(inferrer.infer_method_return_type(method)).to be_nil
    end
  end

  describe "type caching" do
    it "caches inferred types" do
      node = TRuby::IR::Literal.new(value: "hello", literal_type: :string)

      # First call
      inferrer.infer_expression(node, env)

      # Cache should have the type
      expect(inferrer.type_cache).to have_key(node.object_id)
    end
  end

  describe "unreachable code handling" do
    it "ignores code after unconditional return" do
      # def test
      #   return false
      #   "unreachable"
      # end
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::Return.new(
            value: TRuby::IR::Literal.new(value: false, literal_type: :boolean)
          ),
          TRuby::IR::Literal.new(value: "unreachable", literal_type: :string),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [],
        return_type: nil,
        body: body
      )

      # Should be bool, not bool | String
      expect(inferrer.infer_method_return_type(method)).to eq("bool")
    end

    it "ignores conditional after unconditional return" do
      # def test
      #   return 42
      #   if condition
      #     "then"
      #   else
      #     "else"
      #   end
      # end
      conditional = TRuby::IR::Conditional.new(
        condition: TRuby::IR::Literal.new(value: true, literal_type: :boolean),
        then_branch: TRuby::IR::Block.new(
          statements: [TRuby::IR::Literal.new(value: "then", literal_type: :string)]
        ),
        else_branch: TRuby::IR::Block.new(
          statements: [TRuby::IR::Literal.new(value: "else", literal_type: :string)]
        ),
        kind: :if
      )
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::Return.new(
            value: TRuby::IR::Literal.new(value: 42, literal_type: :integer)
          ),
          conditional,
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [],
        return_type: nil,
        body: body
      )

      # Should be Integer only
      expect(inferrer.infer_method_return_type(method)).to eq("Integer")
    end

    it "collects returns from all branches when conditional does not fully terminate" do
      # def test
      #   if condition
      #     return "yes"
      #   end
      #   "no"
      # end
      conditional = TRuby::IR::Conditional.new(
        condition: TRuby::IR::Literal.new(value: true, literal_type: :boolean),
        then_branch: TRuby::IR::Block.new(
          statements: [
            TRuby::IR::Return.new(
              value: TRuby::IR::Literal.new(value: "yes", literal_type: :string)
            ),
          ]
        ),
        else_branch: nil,
        kind: :if
      )
      body = TRuby::IR::Block.new(
        statements: [
          conditional,
          TRuby::IR::Literal.new(value: "no", literal_type: :string),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [],
        return_type: nil,
        body: body
      )

      # Should include both String from return and String from implicit return
      expect(inferrer.infer_method_return_type(method)).to eq("String")
    end
  end

  describe "logical operators" do
    it "infers right type from && operator" do
      left = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
      right = TRuby::IR::Literal.new(value: "success", literal_type: :string)
      node = TRuby::IR::BinaryOp.new(operator: "&&", left: left, right: right)

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end

    it "infers union type from || operator" do
      left = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
      right = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
      node = TRuby::IR::BinaryOp.new(operator: "||", left: left, right: right)

      expect(inferrer.infer_expression(node, env)).to eq("String | Integer")
    end

    it "returns same type when || operands are same type" do
      left = TRuby::IR::Literal.new(value: "a", literal_type: :string)
      right = TRuby::IR::Literal.new(value: "b", literal_type: :string)
      node = TRuby::IR::BinaryOp.new(operator: "||", left: left, right: right)

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end
  end

  describe "unary operators" do
    it "infers bool from ! operator" do
      operand = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
      node = TRuby::IR::UnaryOp.new(operator: "!", operand: operand)

      expect(inferrer.infer_expression(node, env)).to eq("bool")
    end

    it "infers same type from - operator" do
      operand = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
      node = TRuby::IR::UnaryOp.new(operator: "-", operand: operand)

      expect(inferrer.infer_expression(node, env)).to eq("Integer")
    end

    it "returns untyped for unknown operator" do
      operand = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
      node = TRuby::IR::UnaryOp.new(operator: "~", operand: operand)

      expect(inferrer.infer_expression(node, env)).to eq("untyped")
    end
  end

  describe "hash literals" do
    it "infers Hash type from key-value pairs" do
      key = TRuby::IR::Literal.new(value: :name, literal_type: :symbol)
      value = TRuby::IR::Literal.new(value: "John", literal_type: :string)
      pair = TRuby::IR::HashPair.new(key: key, value: value)
      node = TRuby::IR::HashLiteral.new(pairs: [pair])

      expect(inferrer.infer_expression(node, env)).to eq("Hash[Symbol, String]")
    end

    it "infers Hash[untyped, untyped] from empty hash" do
      node = TRuby::IR::HashLiteral.new(pairs: [])
      expect(inferrer.infer_expression(node, env)).to eq("Hash[untyped, untyped]")
    end
  end

  describe "conditional type inference" do
    it "unifies then and else branch types" do
      then_branch = TRuby::IR::Literal.new(value: "yes", literal_type: :string)
      else_branch = TRuby::IR::Literal.new(value: "no", literal_type: :string)
      condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)

      node = TRuby::IR::Conditional.new(
        condition: condition,
        then_branch: then_branch,
        else_branch: else_branch,
        kind: :if
      )

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end

    it "returns nil when no branches" do
      condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
      node = TRuby::IR::Conditional.new(
        condition: condition,
        then_branch: nil,
        else_branch: nil,
        kind: :if
      )

      expect(inferrer.infer_expression(node, env)).to eq("nil")
    end

    it "returns nullable type when else branch missing" do
      then_branch = TRuby::IR::Literal.new(value: "yes", literal_type: :string)
      condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)

      node = TRuby::IR::Conditional.new(
        condition: condition,
        then_branch: then_branch,
        else_branch: nil,
        kind: :if
      )

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end
  end

  describe "return without value" do
    it "infers nil from return without value" do
      node = TRuby::IR::Return.new(value: nil)
      expect(inferrer.infer_expression(node, env)).to eq("nil")
    end
  end

  describe "constant references" do
    it "returns constant name as type" do
      node = TRuby::IR::VariableRef.new(name: "MyClass", scope: :constant)
      expect(inferrer.infer_expression(node, env)).to eq("MyClass")
    end

    it "treats capitalized names as constants" do
      node = TRuby::IR::VariableRef.new(name: "UserModel", scope: :local)
      expect(inferrer.infer_expression(node, env)).to eq("UserModel")
    end
  end

  describe "class variable assignment" do
    it "registers class variable type" do
      value = TRuby::IR::Literal.new(value: 0, literal_type: :integer)
      node = TRuby::IR::Assignment.new(target: "@@counter", value: value)

      inferrer.infer_expression(node, env)

      expect(env.lookup_class_var("@@counter")).to eq("Integer")
    end
  end

  describe "array concatenation" do
    it "infers array type from + operation on arrays" do
      left_elements = [TRuby::IR::Literal.new(value: 1, literal_type: :integer)]
      left = TRuby::IR::ArrayLiteral.new(elements: left_elements)

      right_elements = [TRuby::IR::Literal.new(value: 2, literal_type: :integer)]
      right = TRuby::IR::ArrayLiteral.new(elements: right_elements)

      node = TRuby::IR::BinaryOp.new(operator: "+", left: left, right: right)

      expect(inferrer.infer_expression(node, env)).to eq("Array[Integer]")
    end
  end

  describe "Object method fallback" do
    it "uses Object methods when receiver method not found" do
      receiver = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
      node = TRuby::IR::MethodCall.new(
        receiver: receiver,
        method_name: "nil?",
        arguments: []
      )

      expect(inferrer.infer_expression(node, env)).to eq("bool")
    end

    it "returns receiver type for self-returning methods" do
      receiver = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
      node = TRuby::IR::MethodCall.new(
        receiver: receiver,
        method_name: "freeze",
        arguments: []
      )

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end
  end

  describe "method call without receiver" do
    it "uses Object as default receiver" do
      node = TRuby::IR::MethodCall.new(
        receiver: nil,
        method_name: "to_s",
        arguments: []
      )

      expect(inferrer.infer_expression(node, env)).to eq("String")
    end
  end

  describe "interpolated strings" do
    it "always infers String type" do
      node = TRuby::IR::InterpolatedString.new(parts: [])
      expect(inferrer.infer_expression(node, env)).to eq("String")
    end
  end

  describe "RawCode nodes" do
    it "returns untyped for raw code" do
      node = TRuby::IR::RawCode.new(code: "some_dynamic_code")
      expect(inferrer.infer_expression(node, env)).to eq("untyped")
    end
  end

  describe "unknown binary operators" do
    it "returns untyped for unknown operators" do
      left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
      right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
      node = TRuby::IR::BinaryOp.new(operator: "=~", left: left, right: right)

      expect(inferrer.infer_expression(node, env)).to eq("untyped")
    end
  end

  describe "parameter without type annotation" do
    it "uses untyped for parameter without annotation" do
      param = TRuby::IR::Parameter.new(name: "arg", type_annotation: nil)
      body = TRuby::IR::Block.new(
        statements: [
          TRuby::IR::VariableRef.new(name: "arg", scope: :local),
        ]
      )
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [param],
        return_type: nil,
        body: body
      )

      expect(inferrer.infer_method_return_type(method)).to eq("untyped")
    end
  end

  describe "type unification with nil" do
    it "creates nullable type when nil is one of two types" do
      # Test through conditional with nil else
      then_branch = TRuby::IR::Literal.new(value: "hello", literal_type: :string)
      else_branch = TRuby::IR::Literal.new(value: nil, literal_type: :nil)
      condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)

      node = TRuby::IR::Conditional.new(
        condition: condition,
        then_branch: then_branch,
        else_branch: else_branch,
        kind: :if
      )

      expect(inferrer.infer_expression(node, env)).to eq("String?")
    end
  end

  describe "comparison operators coverage" do
    %w[!= < > <= >= <=>].each do |op|
      it "infers bool from #{op} operator" do
        left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        node = TRuby::IR::BinaryOp.new(operator: op, left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("bool")
      end
    end
  end

  describe "arithmetic operators coverage" do
    %w[- * / % **].each do |op|
      it "infers Integer from integer #{op} operation" do
        left = TRuby::IR::Literal.new(value: 10, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        node = TRuby::IR::BinaryOp.new(operator: op, left: left, right: right)

        expect(inferrer.infer_expression(node, env)).to eq("Integer")
      end
    end
  end
end
`,
  "spec/t_ruby/benchmark_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"
require "tempfile"

describe TRuby::BenchmarkSuite do
  let(:config) { instance_double(TRuby::Config) }
  let(:suite) { described_class.new(config) }

  describe "BENCHMARK_CATEGORIES" do
    it "contains expected categories" do
      expect(described_class::BENCHMARK_CATEGORIES).to eq(
        %i[parsing type_checking compilation incremental parallel memory]
      )
    end
  end

  describe "#initialize" do
    it "initializes with default config when none provided" do
      allow(TRuby::Config).to receive(:new).and_return(config)
      suite = described_class.new
      expect(suite.config).to eq(config)
    end

    it "initializes with provided config" do
      expect(suite.config).to eq(config)
    end

    it "initializes results as empty hash" do
      expect(suite.results).to eq({})
    end
  end

  describe "#run_all" do
    before do
      allow(suite).to receive(:run_category)
      allow(suite).to receive(:print_summary)
      allow(suite).to receive(:puts)
    end

    it "runs all benchmark categories" do
      suite.run_all(iterations: 1, warmup: 0)

      described_class::BENCHMARK_CATEGORIES.each do |category|
        expect(suite).to have_received(:run_category).with(category, iterations: 1, warmup: 0)
      end
    end

    it "prints summary after running" do
      suite.run_all(iterations: 1, warmup: 0)
      expect(suite).to have_received(:print_summary)
    end

    it "returns results hash" do
      result = suite.run_all(iterations: 1, warmup: 0)
      expect(result).to be_a(Hash)
    end
  end

  describe "#run_category" do
    before do
      allow(suite).to receive(:puts)
      allow(suite).to receive(:benchmark_parsing).and_return({ test: { avg_time: 0.001 } })
      allow(suite).to receive(:benchmark_type_checking).and_return({ test: { avg_time: 0.001 } })
      allow(suite).to receive(:benchmark_compilation).and_return({ test: { avg_time: 0.001 } })
      allow(suite).to receive(:benchmark_incremental).and_return({ test: { avg_time: 0.001 } })
      allow(suite).to receive(:benchmark_parallel).and_return({ test: { avg_time: 0.001 } })
      allow(suite).to receive(:benchmark_memory).and_return({ test: { memory: 100 } })
    end

    it "runs parsing benchmarks" do
      suite.run_category(:parsing, iterations: 1, warmup: 0)
      expect(suite).to have_received(:benchmark_parsing).with(1, 0)
      expect(suite.results[:parsing]).to eq({ test: { avg_time: 0.001 } })
    end

    it "runs type_checking benchmarks" do
      suite.run_category(:type_checking, iterations: 1, warmup: 0)
      expect(suite).to have_received(:benchmark_type_checking).with(1, 0)
    end

    it "runs compilation benchmarks" do
      suite.run_category(:compilation, iterations: 1, warmup: 0)
      expect(suite).to have_received(:benchmark_compilation).with(1, 0)
    end

    it "runs incremental benchmarks" do
      suite.run_category(:incremental, iterations: 1, warmup: 0)
      expect(suite).to have_received(:benchmark_incremental).with(1, 0)
    end

    it "runs parallel benchmarks" do
      suite.run_category(:parallel, iterations: 1, warmup: 0)
      expect(suite).to have_received(:benchmark_parallel).with(1, 0)
    end

    it "runs memory benchmarks" do
      suite.run_category(:memory)
      expect(suite).to have_received(:benchmark_memory)
    end
  end

  describe "#export_json" do
    let(:results) { { parsing: { small_file: { avg_time: 0.001, min_time: 0.0008, max_time: 0.0012 } } } }

    before do
      suite.instance_variable_set(:@results, results)
    end

    it "exports results to JSON file" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.json")
        suite.export_json(path)

        expect(File.exist?(path)).to be true
        json = JSON.parse(File.read(path))
        expect(json).to have_key("timestamp")
        expect(json).to have_key("ruby_version")
        expect(json).to have_key("platform")
        expect(json).to have_key("results")
      end
    end

    it "includes correct results structure" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.json")
        suite.export_json(path)

        json = JSON.parse(File.read(path), symbolize_names: true)
        expect(json[:results][:parsing][:small_file][:avg_time]).to eq(0.001)
      end
    end
  end

  describe "#export_markdown" do
    let(:results) do
      {
        parsing: {
          small_file: { avg_time: 0.001, memory: 100, min_time: 0.0008, max_time: 0.0012 },
        },
      }
    end

    before do
      suite.instance_variable_set(:@results, results)
    end

    it "exports results to Markdown file" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.md")
        suite.export_markdown(path)

        expect(File.exist?(path)).to be true
        content = File.read(path)
        expect(content).to include("# T-Ruby Benchmark Results")
        expect(content).to include("## Parsing")
        expect(content).to include("small_file")
      end
    end

    it "includes table headers" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.md")
        suite.export_markdown(path)

        content = File.read(path)
        expect(content).to include("| Benchmark | Time (ms) | Memory (KB) | Iterations/sec |")
      end
    end

    it "calculates iterations per second correctly" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.md")
        suite.export_markdown(path)

        content = File.read(path)
        # 0.001 seconds = 1000 iterations/sec
        expect(content).to include("1000.0")
      end
    end

    it "handles zero avg_time gracefully" do
      zero_results = {
        memory: {
          cache: { avg_time: 0, memory: 500 },
        },
      }
      suite.instance_variable_set(:@results, zero_results)

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "results.md")
        suite.export_markdown(path)

        content = File.read(path)
        expect(content).to include("| cache | 0 | 500 | 0 |")
      end
    end
  end

  describe "#compare" do
    let(:current_results) do
      {
        parsing: {
          small_file: { avg_time: 0.0009 },
        },
      }
    end

    let(:previous_results) do
      {
        timestamp: Time.now.iso8601,
        results: {
          parsing: {
            small_file: { avg_time: 0.001 },
          },
        },
      }
    end

    before do
      suite.instance_variable_set(:@results, current_results)
    end

    it "returns nil if previous file does not exist" do
      result = suite.compare("/nonexistent/path.json")
      expect(result).to be_nil
    end

    it "compares with previous results" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "previous.json")
        File.write(path, JSON.generate(previous_results))

        comparison = suite.compare(path)

        expect(comparison).to have_key(:parsing)
        expect(comparison[:parsing]).to have_key(:small_file)
        expect(comparison[:parsing][:small_file][:current]).to eq(0.0009)
        expect(comparison[:parsing][:small_file][:previous]).to eq(0.001)
      end
    end

    it "calculates percentage difference" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "previous.json")
        File.write(path, JSON.generate(previous_results))

        comparison = suite.compare(path)

        # 0.0009 is 10% faster than 0.001
        expect(comparison[:parsing][:small_file][:diff_percent]).to eq(-10.0)
        expect(comparison[:parsing][:small_file][:improved]).to be true
      end
    end

    it "handles missing categories gracefully" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "previous.json")
        File.write(path, JSON.generate({ results: {} }))

        comparison = suite.compare(path)
        expect(comparison).to eq({})
      end
    end

    it "skips missing benchmarks in previous results" do
      suite.instance_variable_set(:@results, {
                                    parsing: {
                                      small_file: { avg_time: 0.001 },
                                      new_benchmark: { avg_time: 0.002 },
                                    },
                                  })

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "previous.json")
        File.write(path, JSON.generate({
                                         results: {
                                           parsing: {
                                             small_file: { avg_time: 0.001 },
                                           },
                                         },
                                       }))

        comparison = suite.compare(path)

        expect(comparison[:parsing]).to have_key(:small_file)
        expect(comparison[:parsing]).not_to have_key(:new_benchmark)
      end
    end
  end

  describe "private methods" do
    describe "#calculate_stats" do
      it "calculates statistics correctly" do
        times = [0.001, 0.002, 0.003]
        stats = suite.send(:calculate_stats, times)

        expect(stats[:avg_time]).to eq(0.002)
        expect(stats[:min_time]).to eq(0.001)
        expect(stats[:max_time]).to eq(0.003)
        expect(stats[:iterations]).to eq(3)
        expect(stats[:std_dev]).to be_a(Float)
      end
    end

    describe "#generate_test_files" do
      it "generates parsing test files" do
        files = suite.send(:generate_test_files, :parsing)
        expect(files).to have_key(:small_file)
        expect(files).to have_key(:medium_file)
        expect(files).to have_key(:large_file)
        expect(files).to have_key(:complex_types)
      end

      it "generates type_checking test files" do
        files = suite.send(:generate_test_files, :type_checking)
        expect(files).to have_key(:simple_types)
        expect(files).to have_key(:generic_types)
        expect(files).to have_key(:union_types)
        expect(files).to have_key(:interface_types)
      end

      it "generates compilation test files" do
        files = suite.send(:generate_test_files, :compilation)
        expect(files).to have_key(:minimal)
        expect(files).to have_key(:with_types)
        expect(files).to have_key(:with_interfaces)
      end

      it "returns empty hash for unknown category" do
        files = suite.send(:generate_test_files, :unknown)
        expect(files).to eq({})
      end
    end

    describe "#generate_test_content" do
      it "generates content with type definitions" do
        content = suite.send(:generate_test_content, 0)
        expect(content).to include("type CustomType0")
        expect(content).to include("interface TestInterface0")
      end

      it "generates specified number of lines" do
        content = suite.send(:generate_test_content, 0, lines: 20)
        lines = content.split("\\n").length
        expect(lines).to be >= 15
      end

      it "marks modified content" do
        content = suite.send(:generate_test_content, 0, modified: true)
        expect(content).to include("(modified)")
      end
    end

    describe "#generate_complex_types_content" do
      it "generates complex type content" do
        content = suite.send(:generate_complex_types_content)
        expect(content).to include("DeepNested")
        expect(content).to include("UnionOfGenerics")
        expect(content).to include("ComplexInterface")
      end
    end

    describe "#generate_simple_types_content" do
      it "generates simple type content" do
        content = suite.send(:generate_simple_types_content)
        expect(content).to include("def add")
        expect(content).to include("def greet")
        expect(content).to include("def valid?")
      end
    end

    describe "#generate_generic_types_content" do
      it "generates generic type content" do
        content = suite.send(:generate_generic_types_content)
        expect(content).to include("def first<T>")
        expect(content).to include("def map_values<K, V, R>")
        expect(content).to include("def wrap<T>")
      end
    end

    describe "#generate_union_types_content" do
      it "generates union type content" do
        content = suite.send(:generate_union_types_content)
        expect(content).to include("StringOrNumber")
        expect(content).to include("NullableString")
        expect(content).to include("Status")
      end
    end

    describe "#generate_interface_types_content" do
      it "generates interface type content" do
        content = suite.send(:generate_interface_types_content)
        expect(content).to include("interface Comparable")
        expect(content).to include("interface Enumerable")
        expect(content).to include("interface Repository")
      end
    end

    describe "#get_memory_usage" do
      it "returns a numeric value" do
        memory = suite.send(:get_memory_usage)
        expect(memory).to be_a(Numeric)
        expect(memory).to be >= 0
      end
    end
  end
end

describe TRuby::QuickBenchmark do
  describe ".measure" do
    it "measures block execution time" do
      allow(described_class).to receive(:puts)

      result = described_class.measure("Test", iterations: 5) { 1 + 1 }

      expect(result).to be_a(Float)
      expect(result).to be >= 0
    end

    it "prints result with name" do
      expect { described_class.measure("Test", iterations: 5) { 1 + 1 } }
        .to output(/Test:.*ms avg/).to_stdout
    end
  end

  describe ".compare" do
    it "measures single execution and returns result" do
      allow(described_class).to receive(:puts)

      result = described_class.compare("Test") { 42 }

      expect(result).to eq(42)
    end

    it "prints timing information" do
      expect { described_class.compare("Test") { 1 + 1 } }
        .to output(/Test:.*ms/).to_stdout
    end
  end
end

describe "BenchmarkSuite actual benchmark methods" do
  let(:config) { TRuby::Config.new }
  let(:suite) { TRuby::BenchmarkSuite.new(config) }

  def suppress_output
    original_stdout = $stdout
    $stdout = StringIO.new
    yield
  ensure
    $stdout = original_stdout
  end

  describe "#benchmark_parsing" do
    it "runs parsing benchmarks" do
      results = nil
      suppress_output { results = suite.send(:benchmark_parsing, 1, 0) }

      expect(results).to have_key(:small_file)
      expect(results).to have_key(:medium_file)
      expect(results[:small_file]).to have_key(:avg_time)
    end
  end

  describe "#print_result" do
    it "prints time results" do
      stats = { avg_time: 0.001, std_dev: 0.0001, memory: 100 }
      original_stdout = $stdout
      $stdout = StringIO.new
      suite.send(:print_result, :test, stats)
      output = $stdout.string
      $stdout = original_stdout

      expect(output).to include("test:")
      expect(output).to include("ms")
    end

    it "prints memory results with KB unit" do
      stats = { memory: 150.5, avg_time: 0, std_dev: 0 }
      original_stdout = $stdout
      $stdout = StringIO.new
      suite.send(:print_result, :test, stats, unit: "KB")
      output = $stdout.string
      $stdout = original_stdout

      expect(output).to include("150.5 KB")
    end
  end

  describe "#print_summary" do
    before do
      suite.instance_variable_set(:@results, {
                                    parsing: { small: { avg_time: 0.001 }, medium: { avg_time: 0.002 } },
                                    compilation: { test: { avg_time: 0.003 } },
                                  })
    end

    it "prints summary with totals" do
      original_stdout = $stdout
      $stdout = StringIO.new
      suite.send(:print_summary)
      output = $stdout.string
      $stdout = original_stdout

      expect(output).to include("SUMMARY")
    end
  end

  describe "#compiler" do
    it "returns compiler instance" do
      compiler = suite.send(:compiler)
      expect(compiler).to be_a(TRuby::Compiler)
    end

    it "memoizes compiler" do
      compiler1 = suite.send(:compiler)
      compiler2 = suite.send(:compiler)
      expect(compiler1).to eq(compiler2)
    end
  end

  describe "#type_checker" do
    it "returns type checker instance" do
      checker = suite.send(:type_checker)
      expect(checker).to be_a(TRuby::TypeChecker)
    end
  end

  describe "#get_memory_usage on linux vs non-linux" do
    it "returns memory value" do
      memory = suite.send(:get_memory_usage)
      expect(memory).to be_a(Numeric)
    end
  end

  describe "#benchmark_type_checking" do
    it "generates type checking test cases" do
      test_cases = suite.send(:generate_test_files, :type_checking)
      expect(test_cases).to have_key(:simple_types)
      expect(test_cases).to have_key(:generic_types)
      expect(test_cases).to have_key(:union_types)
      expect(test_cases).to have_key(:interface_types)
    end

    it "parses type checking content" do
      content = suite.send(:generate_simple_types_content)
      ast = TRuby::Parser.new(content).parse
      expect(ast).not_to be_nil
    end
  end

  describe "#benchmark_compilation" do
    it "generates compilation test cases" do
      test_cases = suite.send(:generate_test_files, :compilation)
      expect(test_cases).to have_key(:minimal)
      expect(test_cases).to have_key(:with_types)
      expect(test_cases).to have_key(:with_interfaces)
    end

    it "compiles valid code" do
      Dir.mktmpdir("trb_bench") do |tmpdir|
        content = "def add(a: Integer, b: Integer): Integer\\n  a + b\\nend"
        input_path = File.join(tmpdir, "test.trb")
        File.write(input_path, content)

        compiler = suite.send(:compiler)
        result = compiler.compile(input_path)
        expect(result).not_to be_nil
      end
    end
  end

  describe "#benchmark_incremental" do
    it "generates test content for incremental benchmarks" do
      10.times do |i|
        content = suite.send(:generate_test_content, i)
        expect(content).to include("CustomType#{i}")
      end
    end

    it "generates modified content" do
      content = suite.send(:generate_test_content, 0, modified: true)
      expect(content).to include("(modified)")
    end
  end

  describe "#benchmark_parallel" do
    it "generates parallel test files" do
      20.times do |i|
        content = suite.send(:generate_test_content, i)
        expect(content).to include("TestInterface#{i}")
      end
    end

    it "creates compiler instance" do
      compiler = suite.send(:compiler)
      expect(compiler).to be_a(TRuby::Compiler)
    end
  end

  describe "#benchmark_memory" do
    it "measures memory usage" do
      memory = suite.send(:get_memory_usage)
      expect(memory).to be >= 0
    end

    it "creates cache entries" do
      cache = TRuby::MemoryCache.new
      100.times { |i| cache.set("key_#{i}", "value_#{i}") }
      expect(cache.get("key_50")).to eq("value_50")
    end
  end
end
`,
  "spec/t_ruby/body_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator::TokenBodyParser do
  subject(:parser) { described_class.new }

  describe "#parse" do
    it "parses string literal" do
      lines = ['  "hello world"']
      result = parser.parse(lines, 0, 1)

      expect(result).to be_a(TRuby::IR::Block)
      expect(result.statements.length).to eq(1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:string)
      expect(stmt.value).to eq("hello world")
    end

    it "parses integer literal" do
      lines = ["  42"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:integer)
      expect(stmt.value).to eq(42)
    end

    it "parses float literal" do
      lines = ["  3.14"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:float)
      expect(stmt.value).to eq(3.14)
    end

    it "parses boolean literals" do
      lines = ["  true"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:boolean)
      expect(stmt.value).to eq(true)
    end

    it "parses nil literal" do
      lines = ["  nil"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:nil)
      expect(stmt.value).to be_nil
    end

    it "parses symbol literal" do
      lines = ["  :ok"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Literal)
      expect(stmt.literal_type).to eq(:symbol)
      expect(stmt.value).to eq(:ok)
    end
  end

  describe "variable references" do
    it "parses local variable reference" do
      lines = ["  name"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::VariableRef)
      expect(stmt.name).to eq("name")
      expect(stmt.scope).to eq(:local)
    end

    it "parses instance variable reference" do
      lines = ["  @name"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::VariableRef)
      expect(stmt.name).to eq("@name")
      expect(stmt.scope).to eq(:instance)
    end
  end

  describe "assignments" do
    it "parses local variable assignment" do
      lines = ["  x = 42"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Assignment)
      expect(stmt.target).to eq("x")
      expect(stmt.value).to be_a(TRuby::IR::Literal)
      expect(stmt.value.value).to eq(42)
    end

    it "parses instance variable assignment" do
      lines = ['  @name = "John"']
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Assignment)
      expect(stmt.target).to eq("@name")
      expect(stmt.value).to be_a(TRuby::IR::Literal)
      expect(stmt.value.value).to eq("John")
    end
  end

  describe "return statements" do
    it "parses return with value" do
      lines = ['  return "done"']
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Return)
      expect(stmt.value).to be_a(TRuby::IR::Literal)
      expect(stmt.value.value).to eq("done")
    end

    it "parses return without value" do
      lines = ["  return"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Return)
      expect(stmt.value).to be_nil
    end
  end

  describe "binary operations" do
    it "parses addition" do
      lines = ["  a + b"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::BinaryOp)
      expect(stmt.operator).to eq(:+)
      expect(stmt.left).to be_a(TRuby::IR::VariableRef)
      expect(stmt.right).to be_a(TRuby::IR::VariableRef)
    end

    it "parses comparison" do
      lines = ["  x == y"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::BinaryOp)
      expect(stmt.operator).to eq(:==)
    end

    it "parses logical operators" do
      lines = ["  a && b"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::BinaryOp)
      expect(stmt.operator).to eq(:"&&")
    end
  end

  describe "method calls" do
    it "parses method call with receiver" do
      lines = ["  text.upcase"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::MethodCall)
      expect(stmt.method_name).to eq("upcase")
      expect(stmt.receiver).to be_a(TRuby::IR::VariableRef)
      expect(stmt.receiver.name).to eq("text")
    end

    it "parses method call with arguments" do
      lines = ['  str.gsub("a", "b")']
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::MethodCall)
      expect(stmt.method_name).to eq("gsub")
      expect(stmt.arguments.length).to eq(2)
    end

    it "parses method call without receiver" do
      lines = ['  puts("hello")']
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::MethodCall)
      expect(stmt.method_name).to eq("puts")
      expect(stmt.receiver).to be_nil
    end
  end

  describe "array literals" do
    it "parses empty array" do
      lines = ["  []"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::ArrayLiteral)
      expect(stmt.elements).to be_empty
    end

    it "parses array with elements" do
      lines = ["  [1, 2, 3]"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::ArrayLiteral)
      expect(stmt.elements.length).to eq(3)
      expect(stmt.elements.first.value).to eq(1)
    end
  end

  describe "hash literals" do
    it "parses empty hash" do
      lines = ["  {}"]
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::HashLiteral)
      expect(stmt.pairs).to be_empty
    end

    it "parses hash with symbol keys" do
      lines = ['  { name: "John", age: 30 }']
      result = parser.parse(lines, 0, 1)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::HashLiteral)
      expect(stmt.pairs.length).to eq(2)
    end
  end

  describe "multiple statements" do
    it "parses multiple lines" do
      lines = [
        "  x = 1",
        "  y = 2",
        "  x + y",
      ]
      result = parser.parse(lines, 0, 3)

      expect(result.statements.length).to eq(3)
      expect(result.statements[0]).to be_a(TRuby::IR::Assignment)
      expect(result.statements[1]).to be_a(TRuby::IR::Assignment)
      expect(result.statements[2]).to be_a(TRuby::IR::BinaryOp)
    end

    it "skips empty lines and comments" do
      lines = [
        "  x = 1",
        "",
        "  # this is a comment",
        "  x",
      ]
      result = parser.parse(lines, 0, 4)

      expect(result.statements.length).to eq(2)
    end
  end

  describe "conditional expressions" do
    it "parses if/else conditional" do
      lines = [
        "  if x == 1",
        "    true",
        "  else",
        "    false",
        "  end",
      ]
      result = parser.parse(lines, 0, 5)

      expect(result.statements.length).to eq(1)
      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Conditional)
      expect(stmt.kind).to eq(:if)
      expect(stmt.then_branch).to be_a(TRuby::IR::Block)
      expect(stmt.else_branch).to be_a(TRuby::IR::Block)
    end

    it "parses if without else" do
      lines = [
        "  if x == 1",
        "    true",
        "  end",
      ]
      result = parser.parse(lines, 0, 3)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Conditional)
      expect(stmt.then_branch).to be_a(TRuby::IR::Block)
      expect(stmt.else_branch).to be_nil
    end

    it "parses unless conditional" do
      lines = [
        "  unless x.nil?",
        "    x",
        "  end",
      ]
      result = parser.parse(lines, 0, 3)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Conditional)
      expect(stmt.kind).to eq(:unless)
    end

    it "parses conditional returning nil or value" do
      lines = [
        "  if name == \\"test\\"",
        "    nil",
        "  else",
        "    name",
        "  end",
      ]
      result = parser.parse(lines, 0, 5)

      stmt = result.statements.first
      expect(stmt).to be_a(TRuby::IR::Conditional)

      then_stmt = stmt.then_branch.statements.first
      expect(then_stmt).to be_a(TRuby::IR::Literal)
      expect(then_stmt.literal_type).to eq(:nil)

      else_stmt = stmt.else_branch.statements.first
      expect(else_stmt).to be_a(TRuby::IR::VariableRef)
      expect(else_stmt.name).to eq("name")
    end
  end
end
`,
  "spec/t_ruby/bundler_integration_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"
require "tmpdir"

RSpec.describe TRuby::BundlerIntegration do
  let(:temp_dir) { Dir.mktmpdir }
  let(:integration) { described_class.new(project_dir: temp_dir) }

  after do
    FileUtils.rm_rf(temp_dir)
  end

  describe "#bundler_project?" do
    it "returns false when no Gemfile exists" do
      expect(integration.bundler_project?).to be false
    end

    it "returns true when Gemfile exists" do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      expect(integration.bundler_project?).to be true
    end
  end

  describe "#init" do
    context "without Gemfile" do
      it "returns false and adds error" do
        expect(integration.init).to be false
        expect(integration.errors).to include("No Gemfile found. Run 'bundle init' first.")
      end
    end

    context "with Gemfile" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'\\n")
      end

      it "returns true" do
        expect(integration.init).to be true
      end

      it "adds types group to Gemfile" do
        integration.init
        content = File.read(File.join(temp_dir, "Gemfile"))
        expect(content).to include("group :types do")
      end

      it "creates types directory" do
        integration.init
        expect(Dir.exist?(File.join(temp_dir, "types"))).to be true
      end

      it "creates sample type definition file" do
        integration.init
        expect(File.exist?(File.join(temp_dir, "types", "custom.d.trb"))).to be true
      end

      it "does not duplicate types group if already exists" do
        File.write(File.join(temp_dir, "Gemfile"), <<~RUBY)
          source 'https://rubygems.org'
          group :types do
          end
        RUBY

        integration.init
        content = File.read(File.join(temp_dir, "Gemfile"))
        expect(content.scan("group :types").count).to eq(1)
      end
    end
  end

  describe "#add_type_gem" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), <<~RUBY)
        source 'https://rubygems.org'
        group :types do
        end
      RUBY
    end

    it "adds type gem to Gemfile" do
      result = integration.add_type_gem("rails", version: "~> 7.0")

      expect(result[:gem]).to eq("rails-types")
      expect(result[:status]).to eq(:added)

      content = File.read(File.join(temp_dir, "Gemfile"))
      expect(content).to include("gem 'rails-types'")
    end

    it "uses default version when not specified" do
      result = integration.add_type_gem("sidekiq")
      expect(result[:version]).to eq(">= 0")
    end
  end

  describe "#remove_type_gem" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), <<~RUBY)
        source 'https://rubygems.org'
        group :types do
          gem 'rails-types', '~> 7.0'
        end
      RUBY
    end

    it "removes type gem from Gemfile" do
      result = integration.remove_type_gem("rails")

      expect(result[:status]).to eq(:removed)

      content = File.read(File.join(temp_dir, "Gemfile"))
      expect(content).not_to include("rails-types")
    end
  end

  describe "#generate_bundle_manifest" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
    end

    it "creates .trb-bundle.json file" do
      path = integration.generate_bundle_manifest

      expect(File.exist?(path)).to be true
      expect(path).to end_with(".trb-bundle.json")
    end

    it "includes correct manifest structure" do
      integration.generate_bundle_manifest
      content = JSON.parse(File.read(File.join(temp_dir, ".trb-bundle.json")))

      expect(content["bundler_integration"]).to be true
      expect(content["types_group"]).to eq("types")
      expect(content).to have_key("type_gems")
      expect(content).to have_key("local_types")
    end
  end

  describe "#discover_type_packages" do
    it "returns empty hash when no Gemfile" do
      expect(integration.discover_type_packages).to eq({})
    end

    context "with Gemfile.lock" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
        File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
          GEM
            remote: https://rubygems.org/
            specs:
              rails (7.0.0)
              sidekiq (6.5.0)

          PLATFORMS
            ruby

          DEPENDENCIES
            rails
            sidekiq
        LOCK
      end

      it "finds type packages for installed gems" do
        packages = integration.discover_type_packages

        expect(packages).to have_key("rails")
        expect(packages["rails"][:name]).to eq("rails-types")
      end
    end
  end

  describe "#check_version_compatibility" do
    it "returns empty array when no type gems" do
      expect(integration.check_version_compatibility).to eq([])
    end
  end

  describe "#create_type_gem_scaffold" do
    it "creates type gem directory structure" do
      result = integration.create_type_gem_scaffold("mylib")

      expect(result[:status]).to eq(:created)
      expect(Dir.exist?(result[:path])).to be true
    end

    it "creates gemspec file" do
      result = integration.create_type_gem_scaffold("mylib")
      gemspec = File.join(result[:path], "mylib-types.gemspec")

      expect(File.exist?(gemspec)).to be true
      content = File.read(gemspec)
      expect(content).to include('spec.name          = "mylib-types"')
    end

    it "creates README file" do
      result = integration.create_type_gem_scaffold("mylib")
      readme = File.join(result[:path], "README.md")

      expect(File.exist?(readme)).to be true
      content = File.read(readme)
      expect(content).to include("# mylib-types")
    end

    it "creates sig directory with type definition" do
      result = integration.create_type_gem_scaffold("mylib")
      type_file = File.join(result[:path], "sig", "mylib.d.trb")

      expect(File.exist?(type_file)).to be true
    end
  end

  describe "#load_bundled_types" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      FileUtils.mkdir_p(File.join(temp_dir, "types"))
      File.write(File.join(temp_dir, "types", "local.d.trb"), <<~TRB)
        type UserId = String
        interface Serializable
          to_json: String
        end
      TRB
    end

    it "loads local type definitions" do
      types = integration.load_bundled_types

      expect(types).to have_key("UserId")
      expect(types["UserId"][:kind]).to eq(:alias)
      expect(types).to have_key("Serializable")
      expect(types["Serializable"][:kind]).to eq(:interface)
    end
  end

  describe "#sync_types" do
    it "returns empty synced array when not a bundler project" do
      result = integration.sync_types
      expect(result[:synced]).to eq([])
    end

    context "with bundler project" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
        File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
          GEM
            specs:

          PLATFORMS
            ruby

          DEPENDENCIES
        LOCK
      end

      it "returns result structure" do
        result = integration.sync_types
        expect(result).to have_key(:synced)
        expect(result).to have_key(:errors)
      end
    end
  end
end

RSpec.describe TRuby::BundlerIntegration, "additional tests" do
  let(:temp_dir) { Dir.mktmpdir }
  let(:integration) { described_class.new(project_dir: temp_dir) }

  after do
    FileUtils.rm_rf(temp_dir)
  end

  describe "#add_type_gem without existing types group" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), <<~RUBY)
        source 'https://rubygems.org'
        gem 'rails'
      RUBY
    end

    it "creates types group and adds gem" do
      integration.add_type_gem("rails", version: "~> 7.0")

      content = File.read(File.join(temp_dir, "Gemfile"))
      expect(content).to include("group :types do")
      expect(content).to include("gem 'rails-types'")
    end
  end

  describe "#check_version_compatibility with mismatch" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
        GEM
          specs:
            rails (7.0.0)
            rails-types (6.0.0)

        PLATFORMS
          ruby
      LOCK
    end

    it "reports version mismatch" do
      integration.instance_variable_set(:@type_gems, {
                                          "rails" => { name: "rails-types", version: "~> 6.0" },
                                        })

      issues = integration.check_version_compatibility
      expect(issues).not_to be_empty
      expect(issues.first[:message]).to include("Version mismatch")
    end
  end

  describe "#check_version_compatibility with compatible versions" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
        GEM
          specs:
            rails (7.0.5)
            rails-types (7.0.0)

        PLATFORMS
          ruby
      LOCK
    end

    it "returns empty when versions match" do
      integration.instance_variable_set(:@type_gems, {
                                          "rails" => { name: "rails-types", version: "~> 7.0" },
                                        })

      issues = integration.check_version_compatibility
      expect(issues).to be_empty
    end
  end

  describe "#create_type_gem_scaffold with custom output" do
    it "creates scaffold in specified directory" do
      output = File.join(temp_dir, "custom", "path")
      result = integration.create_type_gem_scaffold("mylib", output_dir: output)

      expect(result[:path]).to eq(output)
      expect(Dir.exist?(output)).to be true
    end

    it "creates lib subdirectory structure" do
      result = integration.create_type_gem_scaffold("my-gem")

      lib_dir = File.join(result[:path], "lib", "my_gem_types")
      expect(Dir.exist?(lib_dir)).to be true
    end

    it "creates version.rb file" do
      result = integration.create_type_gem_scaffold("mylib")

      version_file = File.join(result[:path], "lib", "mylib_types", "version.rb")
      expect(File.exist?(version_file)).to be true
      content = File.read(version_file)
      expect(content).to include("MylibTypes")
      expect(content).to include('VERSION = "0.1.0"')
    end
  end

  describe "#load_bundled_types with no types directory" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      File.write(File.join(temp_dir, "Gemfile.lock"), "GEM\\n  specs:\\n")
    end

    it "returns empty definitions" do
      types = integration.load_bundled_types
      expect(types).to eq({})
    end
  end

  describe "attribute readers" do
    it "has project_dir" do
      expect(integration.project_dir).to eq(temp_dir)
    end

    it "has errors" do
      expect(integration.errors).to be_an(Array)
    end
  end

  describe "#sync_types" do
    context "with type gems having path" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
        File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
          GEM
            remote: https://rubygems.org/
            specs:
              rails-types (7.0.0)

          PLATFORMS
            ruby

          DEPENDENCIES
            rails-types
        LOCK

        # Create a fake gem directory with type files
        gem_path = File.join(temp_dir, "vendor", "bundle", "ruby", "3.0.0", "gems", "rails-types-7.0.0")
        FileUtils.mkdir_p(File.join(gem_path, "sig"))
        File.write(File.join(gem_path, "sig", "rails.rbs"), "class Rails; end")
      end

      it "syncs type files from gems" do
        result = integration.sync_types
        expect(result).to have_key(:synced)
        expect(result).to have_key(:errors)
      end
    end
  end

  describe "#load_bundled_types with gem types" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
        GEM
          remote: https://rubygems.org/
          specs:
            mylib-types (1.0.0)

        PLATFORMS
          ruby
      LOCK

      # Create fake gem with type definitions
      gem_path = File.join(temp_dir, "vendor", "bundle", "ruby", "3.0.0", "gems", "mylib-types-1.0.0")
      FileUtils.mkdir_p(gem_path)
      File.write(File.join(gem_path, "types.d.trb"), <<~TRB)
        type MyLibId = String
        interface MyLibClient
          connect: Boolean
        end
      TRB
    end

    it "loads types from gems and local" do
      types = integration.load_bundled_types
      expect(types).to be_a(Hash)
    end
  end

  describe "private #parse_gemfile_lock" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      File.write(File.join(temp_dir, "Gemfile.lock"), <<~LOCK)
        GEM
          remote: https://rubygems.org/
          specs:
            gem1 (1.2.3)
            gem2 (4.5.6)
              dep1 (~> 1.0)

        PLATFORMS
          arm64-darwin-24
          ruby

        DEPENDENCIES
          gem1
          gem2
      LOCK
    end

    it "parses gems from Gemfile.lock" do
      gems = integration.send(:parse_gemfile_lock)
      expect(gems["gem1"]).to eq("1.2.3")
      expect(gems["gem2"]).to eq("4.5.6")
    end
  end

  describe "private #find_type_gem" do
    it "returns available: true for common type gems" do
      result = integration.send(:find_type_gem, "rails")
      expect(result[:name]).to eq("rails-types")
      expect(result[:available]).to be true
    end

    it "returns available: false for unknown gems" do
      result = integration.send(:find_type_gem, "unknown-gem")
      expect(result[:name]).to eq("unknown-gem-types")
      expect(result[:available]).to be false
    end
  end

  describe "private #versions_compatible?" do
    it "returns true when major.minor match" do
      expect(integration.send(:versions_compatible?, "7.0.5", "7.0.0")).to be true
    end

    it "returns false when major.minor differ" do
      expect(integration.send(:versions_compatible?, "7.1.0", "7.0.0")).to be false
    end
  end

  describe "private #create_types_directory with existing file" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      types_dir = File.join(temp_dir, "types")
      FileUtils.mkdir_p(types_dir)
      File.write(File.join(types_dir, "custom.d.trb"), "# existing content")
    end

    it "does not overwrite existing sample file" do
      integration.init
      content = File.read(File.join(temp_dir, "types", "custom.d.trb"))
      expect(content).to eq("# existing content")
    end
  end

  describe "private #list_local_types" do
    before do
      File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
      types_dir = File.join(temp_dir, "types")
      FileUtils.mkdir_p(types_dir)
      File.write(File.join(types_dir, "one.d.trb"), "type A = String")
      File.write(File.join(types_dir, "two.d.trb"), "type B = Integer")
    end

    it "lists local type files" do
      files = integration.send(:list_local_types)
      expect(files).to include("one.d.trb")
      expect(files).to include("two.d.trb")
    end
  end

  describe "private #list_local_types with no types directory" do
    it "returns empty array" do
      files = integration.send(:list_local_types)
      expect(files).to eq([])
    end
  end
end

RSpec.describe TRuby::PackageManager do
  let(:temp_dir) { Dir.mktmpdir }
  let(:manager) { described_class.new(project_dir: temp_dir) }

  after do
    FileUtils.rm_rf(temp_dir)
  end

  describe "#bundler" do
    it "provides access to BundlerIntegration" do
      expect(manager.bundler).to be_a(TRuby::BundlerIntegration)
    end
  end

  describe "#install_with_bundler_fallback" do
    context "without Bundler" do
      it "raises error when no manifest exists" do
        # Without Bundler and without manifest, should raise error
        expect { manager.install_with_bundler_fallback }.to raise_error(/No manifest found/)
      end
    end

    context "with Bundler" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), "source 'https://rubygems.org'")
        File.write(File.join(temp_dir, "Gemfile.lock"), "")
      end

      it "uses bundler sync" do
        result = manager.install_with_bundler_fallback
        expect(result).to have_key(:synced)
      end
    end
  end

  describe "#migrate_to_bundler" do
    context "without Bundler project" do
      it "returns error" do
        result = manager.migrate_to_bundler
        expect(result[:success]).to be false
        expect(result[:error]).to include("Not a Bundler project")
      end
    end

    context "with Bundler project" do
      before do
        File.write(File.join(temp_dir, "Gemfile"), <<~RUBY)
          source 'https://rubygems.org'
          group :types do
          end
        RUBY
      end

      it "returns success" do
        result = manager.migrate_to_bundler
        expect(result[:success]).to be true
      end

      it "generates bundle manifest" do
        manager.migrate_to_bundler
        expect(File.exist?(File.join(temp_dir, ".trb-bundle.json"))).to be true
      end
    end
  end
end
`,
  "spec/t_ruby/cache_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::MemoryCache do
  let(:cache) { TRuby::MemoryCache.new(max_size: 3) }

  describe "#get and #set" do
    it "stores and retrieves values" do
      cache.set("key1", "value1")
      expect(cache.get("key1")).to eq("value1")
    end

    it "returns nil for missing keys" do
      expect(cache.get("nonexistent")).to be_nil
    end

    it "tracks hits and misses" do
      cache.set("key1", "value1")
      cache.get("key1")
      cache.get("nonexistent")

      expect(cache.hits).to eq(1)
      expect(cache.misses).to eq(1)
    end
  end

  describe "LRU eviction" do
    it "evicts least recently used when full" do
      cache.set("a", 1)
      cache.set("b", 2)
      cache.set("c", 3)

      # Access 'a' to make it recently used
      cache.get("a")

      # Add new item, should evict 'b' (least recently used)
      cache.set("d", 4)

      expect(cache.get("a")).to eq(1)
      expect(cache.get("b")).to be_nil # Evicted
      expect(cache.get("c")).to eq(3)
      expect(cache.get("d")).to eq(4)
    end
  end

  describe "#delete" do
    it "removes items" do
      cache.set("key", "value")
      cache.delete("key")
      expect(cache.get("key")).to be_nil
    end
  end

  describe "#clear" do
    it "removes all items" do
      cache.set("a", 1)
      cache.set("b", 2)
      cache.clear
      expect(cache.size).to eq(0)
    end
  end

  describe "#hit_rate" do
    it "calculates hit rate" do
      cache.set("key", "value")
      cache.get("key")
      cache.get("key")
      cache.get("missing")

      expect(cache.hit_rate).to eq(2.0 / 3)
    end

    it "returns 0 when no accesses" do
      expect(cache.hit_rate).to eq(0.0)
    end
  end

  describe "#stats" do
    it "returns cache statistics" do
      cache.set("key", "value")
      cache.get("key")

      stats = cache.stats
      expect(stats[:size]).to eq(1)
      expect(stats[:max_size]).to eq(3)
      expect(stats[:hits]).to eq(1)
    end
  end
end

RSpec.describe TRuby::FileCache do
  let(:cache_dir) { "/tmp/t-ruby-test-cache-#{Process.pid}" }
  let(:cache) { TRuby::FileCache.new(cache_dir: cache_dir, max_age: 60) }

  after do
    FileUtils.rm_rf(cache_dir)
  end

  describe "#get and #set" do
    it "stores and retrieves values" do
      cache.set("key1", { data: "value1" })
      expect(cache.get("key1")).to eq({ data: "value1" })
    end

    it "returns nil for missing keys" do
      expect(cache.get("nonexistent")).to be_nil
    end
  end

  describe "#delete" do
    it "removes cached items" do
      cache.set("key", { value: 1 })
      cache.delete("key")
      expect(cache.get("key")).to be_nil
    end
  end

  describe "#clear" do
    it "removes all cached items" do
      cache.set("a", { x: 1 })
      cache.set("b", { x: 2 })
      cache.clear

      expect(cache.get("a")).to be_nil
      expect(cache.get("b")).to be_nil
    end
  end
end

RSpec.describe TRuby::ParseCache do
  let(:cache) { TRuby::ParseCache.new }

  describe "#get and #set" do
    it "caches parse results" do
      source = "def hello(name: String): String\\n  name\\nend"
      result = { functions: [{ name: "hello" }] }

      cache.set(source, result)
      expect(cache.get(source)).to eq(result)
    end

    it "returns nil for uncached source" do
      expect(cache.get("uncached")).to be_nil
    end
  end

  describe "#invalidate" do
    it "removes cached entry" do
      source = "def test: void\\nend"
      cache.set(source, { functions: [] })
      cache.invalidate(source)
      expect(cache.get(source)).to be_nil
    end
  end
end

RSpec.describe TRuby::TypeResolutionCache do
  let(:cache) { TRuby::TypeResolutionCache.new }

  it "caches type resolutions" do
    cache.set("Array<String>", { container: "Array", element: "String" })
    expect(cache.get("Array<String>")).to eq({ container: "Array", element: "String" })
  end
end

RSpec.describe TRuby::IncrementalCompiler do
  let(:mock_compiler) do
    double("Compiler").tap do |c|
      allow(c).to receive(:compile) { |path| "compiled:#{path}" }
    end
  end

  let(:incremental) { TRuby::IncrementalCompiler.new(mock_compiler) }

  describe "#needs_compile?" do
    it "returns true for new files" do
      allow(File).to receive(:exist?).and_return(true)
      allow(File).to receive(:read).and_return("content")

      expect(incremental.needs_compile?("new_file.trb")).to be true
    end
  end

  describe "#add_dependency" do
    it "tracks file dependencies" do
      incremental.add_dependency("a.trb", "b.trb")
      expect(incremental.dependencies["a.trb"]).to include("b.trb")
    end
  end

  describe "#clear" do
    it "clears all caches" do
      incremental.instance_variable_set(:@file_hashes, { "test" => "hash" })
      incremental.clear
      expect(incremental.file_hashes).to be_empty
    end
  end
end

RSpec.describe TRuby::ParallelProcessor do
  let(:processor) { TRuby::ParallelProcessor.new(thread_count: 2) }

  describe "#process_files" do
    it "processes files in parallel" do
      files = ["a.trb", "b.trb", "c.trb"]
      results = processor.process_files(files, &:upcase)

      expect(results).to contain_exactly("A.TRB", "B.TRB", "C.TRB")
    end

    it "handles empty input" do
      expect(processor.process_files([])).to eq([])
    end
  end

  describe "#process_with_queue" do
    it "processes using work queue" do
      files = %w[x y z]
      results = processor.process_with_queue(files) { |f| f * 2 }

      expect(results).to contain_exactly("xx", "yy", "zz")
    end
  end
end

RSpec.describe TRuby::CompilationProfiler do
  let(:profiler) { TRuby::CompilationProfiler.new }

  describe "#profile" do
    it "measures execution time" do
      result = profiler.profile("test") { 1 + 1 }
      expect(result).to eq(2)
    end

    it "accumulates timings" do
      profiler.profile("op") { sleep(0.01) }
      profiler.profile("op") { sleep(0.01) }

      data = profiler.to_h.find { |h| h[:name] == "op" }
      expect(data[:call_count]).to eq(2)
    end
  end

  describe "#reset" do
    it "clears all timings" do
      profiler.profile("test") { nil }
      profiler.reset
      expect(profiler.to_h).to be_empty
    end
  end
end

RSpec.describe TRuby::CacheEntry do
  it "tracks access count" do
    entry = TRuby::CacheEntry.new("key", "value")
    entry.access
    entry.access
    expect(entry.hits).to eq(2)
  end

  it "updates accessed_at on access" do
    entry = TRuby::CacheEntry.new("key", "value")
    first_access = entry.accessed_at
    sleep(0.01)
    entry.access
    expect(entry.accessed_at).to be > first_access
  end

  it "detects stale entries" do
    entry = TRuby::CacheEntry.new("key", "value")
    expect(entry.stale?(0)).to be true
    expect(entry.stale?(1000)).to be false
  end

  describe "#to_h" do
    it "returns hash representation" do
      entry = TRuby::CacheEntry.new("mykey", { data: 123 })
      entry.access
      hash = entry.to_h

      expect(hash[:key]).to eq("mykey")
      expect(hash[:value]).to eq({ data: 123 })
      expect(hash[:created_at]).to be_a(Integer)
      expect(hash[:hits]).to eq(1)
    end
  end
end

RSpec.describe TRuby::FileCache, "stale handling" do
  let(:cache_dir) { "/tmp/t-ruby-test-cache-stale-#{Process.pid}" }
  let(:cache) { TRuby::FileCache.new(cache_dir: cache_dir, max_age: 1) }

  after do
    FileUtils.rm_rf(cache_dir)
  end

  it "returns nil for stale entries" do
    cache.set("key", { value: "test" })
    # Make file appear old
    cache_path = Dir.glob(File.join(cache_dir, "*.json")).first
    FileUtils.touch(cache_path, mtime: Time.now - 10)

    expect(cache.get("key")).to be_nil
  end

  it "handles JSON parse errors gracefully" do
    cache.set("key", { value: "test" })
    cache_path = Dir.glob(File.join(cache_dir, "*.json")).first
    File.write(cache_path, "invalid json {{{")

    expect(cache.get("key")).to be_nil
    expect(File.exist?(cache_path)).to be false # Deleted on error
  end

  describe "#prune" do
    it "removes stale files" do
      cache.set("old", { value: 1 })
      cache.set("new", { value: 2 })

      # Make one file old
      old_path = Dir.glob(File.join(cache_dir, "*.json")).first
      FileUtils.touch(old_path, mtime: Time.now - 10)

      cache.prune
      expect(Dir.glob(File.join(cache_dir, "*.json")).count).to eq(1)
    end
  end
end

RSpec.describe TRuby::ParseCache, "with file cache" do
  let(:cache_dir) { "/tmp/t-ruby-parse-cache-#{Process.pid}" }
  let(:file_cache) { TRuby::FileCache.new(cache_dir: cache_dir) }
  let(:cache) { TRuby::ParseCache.new(file_cache: file_cache) }

  after do
    FileUtils.rm_rf(cache_dir)
  end

  it "falls back to file cache on memory miss" do
    source = "def test: void\\nend"
    result = { parsed: true }

    # Set in cache (goes to both memory and file)
    cache.set(source, result)

    # Create new cache instance (empty memory cache)
    new_cache = TRuby::ParseCache.new(file_cache: file_cache)

    # Should get from file cache and populate memory
    expect(new_cache.get(source)).to eq(result)
  end

  describe "#stats" do
    it "returns memory cache stats" do
      stats = cache.stats
      expect(stats).to have_key(:size)
      expect(stats).to have_key(:hits)
      expect(stats).to have_key(:misses)
    end
  end
end

RSpec.describe TRuby::TypeResolutionCache do
  let(:cache) { TRuby::TypeResolutionCache.new }

  describe "#clear" do
    it "clears all entries" do
      cache.set("Type1", :resolved1)
      cache.set("Type2", :resolved2)
      cache.clear
      expect(cache.get("Type1")).to be_nil
      expect(cache.get("Type2")).to be_nil
    end
  end

  describe "#stats" do
    it "returns cache statistics" do
      cache.set("Type", :resolved)
      cache.get("Type")
      cache.get("Missing")

      stats = cache.stats
      expect(stats[:hits]).to eq(1)
      expect(stats[:misses]).to eq(1)
    end
  end
end

RSpec.describe TRuby::DeclarationCache do
  let(:cache_dir) { "/tmp/t-ruby-decl-cache-#{Process.pid}" }
  let(:cache) { TRuby::DeclarationCache.new(cache_dir: cache_dir) }

  after do
    FileUtils.rm_rf(cache_dir)
  end

  it "caches declarations by file path and mtime" do
    Dir.mktmpdir do |tmpdir|
      file_path = File.join(tmpdir, "test.trb")
      File.write(file_path, "def hello: String\\nend")

      declarations = { functions: ["hello"] }
      cache.set(file_path, declarations)

      expect(cache.get(file_path)).to eq(declarations)
    end
  end

  it "returns nil for non-existent files" do
    expect(cache.get("/nonexistent/file.trb")).to be_nil
  end

  it "invalidates when file is modified" do
    Dir.mktmpdir do |tmpdir|
      file_path = File.join(tmpdir, "test.trb")
      File.write(file_path, "original")

      cache.set(file_path, { version: 1 })

      # Modify file with different mtime
      sleep(1.1) # File mtime has 1-second resolution on some systems
      File.write(file_path, "modified")

      # Cache should miss due to different mtime
      expect(cache.get(file_path)).to be_nil
    end
  end

  describe "#clear" do
    it "clears both memory and file caches" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "content")
        cache.set(file_path, { data: 1 })

        cache.clear

        expect(cache.get(file_path)).to be_nil
      end
    end
  end
end

RSpec.describe TRuby::IncrementalCompiler, "additional tests" do
  let(:mock_compiler) do
    double("Compiler").tap do |c|
      allow(c).to receive(:compile) { |path| "result:#{path}" }
    end
  end

  let(:incremental) { TRuby::IncrementalCompiler.new(mock_compiler) }

  describe "#compile" do
    it "compiles and caches result" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "content")

        result = incremental.compile(file_path)
        expect(result).to eq("result:#{file_path}")

        # Second call should not recompile
        expect(incremental.compile(file_path)).to eq(result)
        expect(mock_compiler).to have_received(:compile).once
      end
    end
  end

  describe "#compile_all" do
    it "compiles only changed files" do
      Dir.mktmpdir do |tmpdir|
        file1 = File.join(tmpdir, "a.trb")
        file2 = File.join(tmpdir, "b.trb")
        File.write(file1, "content1")
        File.write(file2, "content2")

        # First compile
        results = incremental.compile_all([file1, file2])
        expect(results.keys).to contain_exactly(file1, file2)

        # Second compile - nothing changed
        results2 = incremental.compile_all([file1, file2])
        expect(results2).to be_empty
      end
    end
  end

  describe "#update_file_hash" do
    it "updates hash for externally compiled file" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "original")

        incremental.update_file_hash(file_path)

        # Should not need compile now
        expect(incremental.needs_compile?(file_path)).to be false
      end
    end
  end

  describe "#needs_compile? with dependencies" do
    it "recompiles when dependency changes" do
      Dir.mktmpdir do |tmpdir|
        main = File.join(tmpdir, "main.trb")
        dep = File.join(tmpdir, "dep.trb")
        File.write(main, "main content")
        File.write(dep, "dep content")

        incremental.compile(main)
        incremental.compile(dep)
        incremental.add_dependency(main, dep)

        # Change dependency
        File.write(dep, "new dep content")

        expect(incremental.needs_compile?(main)).to be true
      end
    end
  end
end

RSpec.describe TRuby::CrossFileTypeChecker do
  let(:checker) { TRuby::CrossFileTypeChecker.new }

  describe "#register_file" do
    it "registers types from IR program" do
      ir_program = double("IR::Program")
      type_alias = TRuby::IR::TypeAlias.new(name: "MyType", definition: TRuby::IR::SimpleType.new(name: "String"))
      allow(ir_program).to receive(:declarations).and_return([type_alias])

      checker.register_file("test.trb", ir_program)

      expect(checker.all_types).to include("MyType")
    end

    it "registers interfaces" do
      ir_program = double("IR::Program")
      interface = TRuby::IR::Interface.new(name: "Printable", members: [])
      allow(ir_program).to receive(:declarations).and_return([interface])

      checker.register_file("test.trb", ir_program)

      expect(checker.all_types).to include("Printable")
    end

    it "registers functions" do
      ir_program = double("IR::Program")
      method_def = TRuby::IR::MethodDef.new(
        name: "greet",
        params: [],
        return_type: TRuby::IR::SimpleType.new(name: "String"),
        body: []
      )
      allow(ir_program).to receive(:declarations).and_return([method_def])

      checker.register_file("test.trb", ir_program)

      expect(checker.all_types).to include("greet")
    end
  end

  describe "#find_definition" do
    it "finds where a type is defined" do
      ir_program = double("IR::Program")
      type_alias = TRuby::IR::TypeAlias.new(name: "UserId", definition: TRuby::IR::SimpleType.new(name: "Integer"))
      allow(ir_program).to receive(:declarations).and_return([type_alias])

      checker.register_file("types.trb", ir_program)

      definition = checker.find_definition("UserId")
      expect(definition[:file]).to eq("types.trb")
      expect(definition[:kind]).to eq(:type)
    end
  end

  describe "#check_all" do
    it "returns success when no errors" do
      result = checker.check_all
      expect(result[:success]).to be true
      expect(result[:errors]).to be_empty
    end
  end

  describe "#check_file" do
    it "checks file against global types" do
      ir_program = double("IR::Program")
      param = TRuby::IR::Parameter.new(name: "x", type_annotation: TRuby::IR::SimpleType.new(name: "UnknownType"))
      method_def = TRuby::IR::MethodDef.new(
        name: "test",
        params: [param],
        return_type: nil,
        body: []
      )
      allow(ir_program).to receive(:declarations).and_return([method_def])

      errors = checker.check_file("test.trb", ir_program)
      expect(errors).not_to be_empty
      expect(errors.first[:message]).to include("UnknownType")
    end

    it "accepts known types" do
      ir_program = double("IR::Program")
      param = TRuby::IR::Parameter.new(name: "x", type_annotation: TRuby::IR::SimpleType.new(name: "String"))
      method_def = TRuby::IR::MethodDef.new(
        name: "test",
        params: [param],
        return_type: TRuby::IR::SimpleType.new(name: "Integer"),
        body: []
      )
      allow(ir_program).to receive(:declarations).and_return([method_def])

      errors = checker.check_file("test.trb", ir_program)
      expect(errors).to be_empty
    end
  end

  describe "#clear" do
    it "clears all registrations" do
      ir_program = double("IR::Program")
      type_alias = TRuby::IR::TypeAlias.new(name: "Test", definition: TRuby::IR::SimpleType.new(name: "String"))
      allow(ir_program).to receive(:declarations).and_return([type_alias])

      checker.register_file("test.trb", ir_program)
      checker.clear

      expect(checker.all_types).to be_empty
      expect(checker.file_types).to be_empty
    end
  end
end

RSpec.describe TRuby::EnhancedIncrementalCompiler do
  let(:mock_compiler) do
    double("Compiler").tap do |c|
      allow(c).to receive(:compile) { |path| "result:#{path}" }
      allow(c).to receive(:compile_to_ir) do |_path|
        program = double("IR::Program")
        allow(program).to receive(:declarations).and_return([])
        program
      end
    end
  end

  let(:enhanced) { TRuby::EnhancedIncrementalCompiler.new(mock_compiler) }

  describe "#compile_with_ir" do
    it "caches IR and compiles" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "content")

        result = enhanced.compile_with_ir(file_path)
        expect(result).to eq("result:#{file_path}")
        expect(enhanced.get_ir(file_path)).not_to be_nil
      end
    end
  end

  describe "#clear" do
    it "clears all caches including IR" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "content")

        enhanced.compile_with_ir(file_path)
        enhanced.clear

        expect(enhanced.ir_cache).to be_empty
        expect(enhanced.file_hashes).to be_empty
      end
    end
  end
end

RSpec.describe TRuby::CompilationProfiler, "additional tests" do
  let(:profiler) { TRuby::CompilationProfiler.new }

  describe "#report" do
    it "outputs profiling information" do
      profiler.profile("operation") { 1 + 1 }

      output = capture_stdout { profiler.report }
      expect(output).to include("Compilation Profile")
      expect(output).to include("operation")
    end
  end

  describe "#to_h" do
    it "returns structured profiling data" do
      profiler.profile("scan") { nil }
      profiler.profile("parse") { nil }

      data = profiler.to_h
      expect(data.map { |d| d[:name] }).to contain_exactly("scan", "parse")
      expect(data.first).to have_key(:total_time)
      expect(data.first).to have_key(:avg_time)
    end
  end

  def capture_stdout
    original = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = original
  end
end
`,
  "spec/t_ruby/cli_init_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"

describe TRuby::CLI do
  describe "--init option" do
    let(:tmpdir) { Dir.mktmpdir("trb_cli_init") }

    after do
      FileUtils.rm_rf(tmpdir)
    end

    it "creates trbconfig.yml file with new schema" do
      Dir.chdir(tmpdir) do
        expect { TRuby::CLI.run(["--init"]) }.to output(/Created:.*trbconfig\\.yml/).to_stdout

        expect(File.exist?("trbconfig.yml")).to be true

        config = YAML.safe_load_file("trbconfig.yml")

        # New schema structure
        expect(config["source"]).to be_a(Hash)
        expect(config["source"]["include"]).to eq(["src"])
        expect(config["source"]["exclude"]).to eq([])
        expect(config["source"]["extensions"]).to eq([".trb", ".rb"])

        expect(config["output"]).to be_a(Hash)
        expect(config["output"]["ruby_dir"]).to eq("build")

        expect(config["compiler"]).to be_a(Hash)
        expect(config["compiler"]["generate_rbs"]).to eq(true)
        expect(config["compiler"]["strictness"]).to eq("standard")
        expected_ruby = "#{RUBY_VERSION.split(".")[0]}.#{RUBY_VERSION.split(".")[1]}"
        expect(config["compiler"]["target_ruby"]).to eq(expected_ruby)

        expect(config["watch"]).to be_a(Hash)
        expect(config["watch"]["debounce"]).to eq(100)
      end
    end

    it "creates src/ directory" do
      Dir.chdir(tmpdir) do
        expect { TRuby::CLI.run(["--init"]) }.to output(%r{Created:.*src/}).to_stdout

        expect(Dir.exist?("src")).to be true
      end
    end

    it "creates build/ directory" do
      Dir.chdir(tmpdir) do
        expect { TRuby::CLI.run(["--init"]) }.to output(%r{Created:.*build/}).to_stdout

        expect(Dir.exist?("build")).to be true
      end
    end

    it "does not overwrite existing trbconfig.yml" do
      Dir.chdir(tmpdir) do
        File.write("trbconfig.yml", "custom: config\\n")

        expect { TRuby::CLI.run(["--init"]) }.to output(/Skipped.*trbconfig\\.yml/).to_stdout

        content = File.read("trbconfig.yml")
        expect(content).to eq("custom: config\\n")
      end
    end

    it "does not fail if directories already exist" do
      Dir.chdir(tmpdir) do
        Dir.mkdir("src")
        Dir.mkdir("build")

        expect { TRuby::CLI.run(["--init"]) }.to output(%r{Skipped.*src/}).to_stdout
        expect { TRuby::CLI.run(["--init"]) }.to output(%r{Skipped.*build/}).to_stdout
      end
    end

    it "reports project already initialized when everything exists" do
      Dir.chdir(tmpdir) do
        File.write("trbconfig.yml", "emit:\\n  rb: true\\n")
        Dir.mkdir("src")
        Dir.mkdir("build")

        expect { TRuby::CLI.run(["--init"]) }.to output(/Project already initialized/).to_stdout
      end
    end

    it "shows success message when project is initialized" do
      Dir.chdir(tmpdir) do
        expect { TRuby::CLI.run(["--init"]) }.to output(/t-ruby project initialized successfully/).to_stdout
      end
    end
  end

  describe "--config option" do
    let(:tmpdir) { Dir.mktmpdir("trb_cli_config") }

    after do
      FileUtils.rm_rf(tmpdir)
    end

    it "accepts --config flag with a custom config path" do
      Dir.chdir(tmpdir) do
        # Create custom config file
        FileUtils.mkdir_p("configs")
        File.write("configs/custom.yml", <<~YAML)
          source:
            include:
              - lib
          output:
            ruby_dir: out
        YAML

        # Create source directory and file
        FileUtils.mkdir_p("lib")
        File.write("lib/test.trb", "puts 'hello'")

        # Compile with custom config
        expect do
          TRuby::CLI.run(["--config", "configs/custom.yml", "lib/test.trb"])
        rescue SystemExit => e
          raise "CLI exited with status #{e.status}" if e.status != 0
        end.to output(/Compiled:/).to_stdout

        # Should output to 'out' directory from custom config
        expect(File.exist?("out/test.rb")).to be true
      end
    end

    it "accepts -c shorthand for --config" do
      Dir.chdir(tmpdir) do
        # Create custom config file
        FileUtils.mkdir_p("configs")
        File.write("configs/custom.yml", <<~YAML)
          source:
            include:
              - lib
          output:
            ruby_dir: dist
        YAML

        # Create source directory and file
        FileUtils.mkdir_p("lib")
        File.write("lib/test.trb", "puts 'hello'")

        # Compile with custom config using shorthand
        expect do
          TRuby::CLI.run(["-c", "configs/custom.yml", "lib/test.trb"])
        rescue SystemExit => e
          raise "CLI exited with status #{e.status}" if e.status != 0
        end.to output(/Compiled:/).to_stdout

        # Should output to 'dist' directory from custom config
        expect(File.exist?("dist/test.rb")).to be true
      end
    end
  end
end
`,
  "spec/t_ruby/cli_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::CLI do
  describe ".run" do
    it "is a class method that creates an instance and runs it" do
      expect_any_instance_of(TRuby::CLI).to receive(:run)
      TRuby::CLI.run([])
    end
  end

  describe "#initialize" do
    it "initializes with command line arguments" do
      args = ["hello.trb"]
      cli = TRuby::CLI.new(args)
      expect(cli).to be_a(TRuby::CLI)
    end

    it "accepts empty arguments" do
      cli = TRuby::CLI.new([])
      expect(cli).to be_a(TRuby::CLI)
    end
  end

  describe "#run" do
    context "with no arguments" do
      it "displays help text" do
        cli = TRuby::CLI.new([])
        output = capture_stdout { cli.run }

        expect(output).to include("t-ruby compiler")
        expect(output).to include("Usage:")
        expect(output).to include("trc")
      end

      it "includes version in help text" do
        cli = TRuby::CLI.new([])
        output = capture_stdout { cli.run }

        expect(output).to include(TRuby::VERSION)
      end
    end

    context "with --help flag" do
      it "displays help text" do
        cli = TRuby::CLI.new(["--help"])
        output = capture_stdout { cli.run }

        expect(output).to include("Usage:")
        expect(output).to include("trc")
      end

      it "includes examples in help text" do
        cli = TRuby::CLI.new(["--help"])
        output = capture_stdout { cli.run }

        expect(output).to include("Examples:")
      end
    end

    context "with -h flag" do
      it "displays help text" do
        cli = TRuby::CLI.new(["-h"])
        output = capture_stdout { cli.run }

        expect(output).to include("Usage:")
      end
    end

    context "with --version flag" do
      it "displays version number" do
        cli = TRuby::CLI.new(["--version"])
        output = capture_stdout { cli.run }

        expect(output).to include("trc")
        expect(output).to include(TRuby::VERSION)
      end

      it "displays only version without help text" do
        cli = TRuby::CLI.new(["--version"])
        output = capture_stdout { cli.run }

        expect(output).not_to include("Usage:")
      end
    end

    context "with -v flag" do
      it "displays version number" do
        cli = TRuby::CLI.new(["-v"])
        output = capture_stdout { cli.run }

        expect(output).to include(TRuby::VERSION)
      end
    end

    context "with a valid .trb file" do
      it "compiles the file and displays success message" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.trb")
          File.write(input_file, "puts 'hello'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          cli = TRuby::CLI.new([input_file])
          output = capture_stdout { cli.run }

          expect(output).to include("Compiled:")
          expect(output).to include(input_file)
          expect(output).to include(".rb")
        end
      end

      it "creates output file in build directory" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "script.trb")
          File.write(input_file, "def hello; end")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

          cli = TRuby::CLI.new([input_file])
          capture_stdout { cli.run }

          expected_output = File.join(tmpdir, "script.rb")
          expect(File.exist?(expected_output)).to be true
        end
      end
    end

    context "with a non-existent file" do
      it "displays error message" do
        cli = TRuby::CLI.new(["/nonexistent/file.trb"])

        expect do
          cli.run
        end.to output(/error TR\\d+:/).to_stdout.and raise_error(SystemExit)
      end

      it "exits with status 1" do
        cli = TRuby::CLI.new(["/nonexistent/file.trb"])

        expect do
          cli.run
        end.to raise_error(SystemExit) do |exit_error|
          expect(exit_error.status).to eq(1)
        end
      end
    end

    context "with wrong file extension" do
      it "compiles .rb file successfully (copies to build and generates rbs)" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.rb")
          File.write(input_file, "puts 'hello'")

          cli = TRuby::CLI.new([input_file])

          expect do
            cli.run
          end.to output(/Compiled: .* -> /).to_stdout
        end
      end

      it "exits with status 1 for wrong extension" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.txt")
          File.write(input_file, "puts 'hello'")

          cli = TRuby::CLI.new([input_file])

          expect do
            cli.run
          end.to raise_error(SystemExit) do |exit_error|
            expect(exit_error.status).to eq(1)
          end
        end
      end
    end

    context "with multiple arguments" do
      it "compiles the first argument" do
        Dir.mktmpdir do |tmpdir|
          file1 = File.join(tmpdir, "file1.trb")
          file2 = File.join(tmpdir, "file2.trb")
          File.write(file1, "puts 'first'")
          File.write(file2, "puts 'second'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          cli = TRuby::CLI.new([file1, file2])
          output = capture_stdout { cli.run }

          expect(output).to include(file1)
          expect(output).not_to include(file2)
        end
      end
    end

    context "with flags and file arguments combined" do
      it "handles version flag even when file is present" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.trb")
          File.write(input_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          cli = TRuby::CLI.new([input_file, "--version"])
          output = capture_stdout { cli.run }

          # CLI checks for --version first, so it displays version instead of compiling
          expect(output).to include(TRuby::VERSION)
        end
      end
    end

    context "error handling" do
      it "catches ArgumentError from compiler" do
        cli = TRuby::CLI.new(["/nonexistent.trb"])

        expect do
          cli.run
        end.to raise_error(SystemExit) do |exit_error|
          expect(exit_error.status).to eq(1)
        end
      end

      it "prints error message to output" do
        cli = TRuby::CLI.new(["/nonexistent.trb"])

        output = capture_stdout do
          cli.run
        rescue SystemExit
          # Suppress exit
        end

        # Uses tsc-style error format
        expect(output).to match(/error TR\\d+:/)
        expect(output).to include("Found 1 error")
      end
    end

    context "tsc-style error formatting" do
      it "formats TypeCheckError with file:line:col format" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "type_error.trb")
          File.write(input_file, "def greet(name: String): String\\n  name\\nend")

          error = TRuby::TypeCheckError.new(
            message: "Type mismatch",
            location: "#{input_file}:3:5",
            expected: "String",
            actual: "Integer"
          )
          allow_any_instance_of(TRuby::Compiler).to receive(:compile).and_raise(error)

          cli = TRuby::CLI.new([input_file])
          output = capture_stdout do
            cli.run
          rescue SystemExit
            # Suppress exit
          end

          # Should include tsc-style format
          expect(output).to include("type_error.trb:3:5")
          expect(output).to match(/error\\s+TR2001/)
          expect(output).to include("Type mismatch")
          expect(output).to include("Found 1 error")
        end
      end

      it "formats ParseError with source code snippet" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "parse_error.trb")
          # Use code that will trigger a ParseError - unterminated string
          File.write(input_file, "def foo\\n  \\"hello\\nend")

          cli = TRuby::CLI.new([input_file])
          output = capture_stdout do
            cli.run
          rescue SystemExit
            # Suppress exit
          end

          # Should include file path and error code
          expect(output).to include("parse_error.trb")
          expect(output).to match(/error\\s+TR\\d+/)
        end
      end

      it "formats ScanError with error marker" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "scan_error.trb")
          File.write(input_file, "puts unterminated_var")

          error = TRuby::Scanner::ScanError.new("Unterminated string", line: 1, column: 6, position: 5)
          allow_any_instance_of(TRuby::Compiler).to receive(:compile).and_raise(error)

          cli = TRuby::CLI.new([input_file])
          output = capture_stdout do
            cli.run
          rescue SystemExit
            # Suppress exit
          end

          expect(output).to include("scan_error.trb:1:6")
          expect(output).to include("Unterminated string")
          # Marker should cover "unterminated_var" (16 chars)
          expect(output).to include("~")
        end
      end

      it "includes Expected/Actual context for type errors" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "context.trb")
          File.write(input_file, "greet(123)")

          error = TRuby::TypeCheckError.new(
            message: "Argument type mismatch",
            location: "#{input_file}:1:7",
            expected: "String",
            actual: "Integer",
            suggestion: "Use .to_s to convert"
          )
          allow_any_instance_of(TRuby::Compiler).to receive(:compile).and_raise(error)

          cli = TRuby::CLI.new([input_file])
          output = capture_stdout do
            cli.run
          rescue SystemExit
            # Suppress exit
          end

          expect(output).to include("Expected:")
          expect(output).to include("String")
          expect(output).to include("Actual:")
          expect(output).to include("Integer")
          expect(output).to include("Suggestion:")
          expect(output).to include("Use .to_s to convert")
        end
      end
    end
  end

  describe "#run with --init flag" do
    it "creates trbconfig.yml, src/, and build/ directories" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          cli = TRuby::CLI.new(["--init"])
          output = capture_stdout { cli.run }

          expect(File.exist?("trbconfig.yml")).to be true
          expect(Dir.exist?("src")).to be true
          expect(Dir.exist?("build")).to be true
          expect(output).to include("Created:")
          expect(output).to include("initialized successfully")
        end
      end
    end

    it "skips existing files and directories" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          # Pre-create the files/dirs
          File.write("trbconfig.yml", "existing: true")
          Dir.mkdir("src")
          Dir.mkdir("build")

          cli = TRuby::CLI.new(["--init"])
          output = capture_stdout { cli.run }

          expect(output).to include("Skipped")
          expect(output).to include("already exists")
          expect(output).to include("Project already initialized")
          # Original content should be preserved
          expect(File.read("trbconfig.yml")).to eq("existing: true")
        end
      end
    end

    it "creates only missing items" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          # Pre-create only src/
          Dir.mkdir("src")

          cli = TRuby::CLI.new(["--init"])
          output = capture_stdout { cli.run }

          expect(output).to include("Created:")
          expect(output).to include("trbconfig.yml")
          expect(output).to include("Skipped")
          expect(output).to include("src/")
        end
      end
    end

    it "creates config file with correct structure" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          cli = TRuby::CLI.new(["--init"])
          capture_stdout { cli.run }

          content = File.read("trbconfig.yml")
          expect(content).to include("source:")
          expect(content).to include("include:")
          expect(content).to include("output:")
          expect(content).to include("ruby_dir:")
          expect(content).to include("compiler:")
          expect(content).to include("strictness:")
          expect(content).to include("watch:")
        end
      end
    end
  end

  describe "#run with update command" do
    it "attempts to update the gem when successful" do
      allow(TRuby::VersionChecker).to receive(:update).and_return(true)

      cli = TRuby::CLI.new(["update"])
      output = capture_stdout { cli.run }

      expect(output).to include("Updating t-ruby")
      expect(output).to include("Successfully updated")
    end

    it "shows error message when update fails" do
      allow(TRuby::VersionChecker).to receive(:update).and_return(false)

      cli = TRuby::CLI.new(["update"])
      output = capture_stdout { cli.run }

      expect(output).to include("Updating t-ruby")
      expect(output).to include("Update failed")
      expect(output).to include("gem install t-ruby")
    end
  end

  describe "#run version check" do
    it "shows new version available message" do
      allow(TRuby::VersionChecker).to receive(:check).and_return({
                                                                   current: "1.0.0",
                                                                   latest: "2.0.0",
                                                                 })

      cli = TRuby::CLI.new(["--version"])
      output = capture_stdout { cli.run }

      expect(output).to include("New version available: 2.0.0")
      expect(output).to include("current: 1.0.0")
      expect(output).to include("Run 'trc update' to update")
    end

    it "shows nothing extra when no update available" do
      allow(TRuby::VersionChecker).to receive(:check).and_return(nil)

      cli = TRuby::CLI.new(["--version"])
      output = capture_stdout { cli.run }

      expect(output).to include("trc #{TRuby::VERSION}")
      expect(output).not_to include("New version available")
    end
  end

  describe "#run with --lsp flag" do
    it "starts the LSP server" do
      lsp_server = instance_double(TRuby::LSPServer)
      allow(TRuby::LSPServer).to receive(:new).and_return(lsp_server)
      allow(lsp_server).to receive(:run)

      cli = TRuby::CLI.new(["--lsp"])
      cli.run

      expect(TRuby::LSPServer).to have_received(:new)
      expect(lsp_server).to have_received(:run)
    end
  end

  describe "#run with run command" do
    it "delegates to t-ruby executable via exec" do
      cli = TRuby::CLI.new(["run", "test.trb"])

      # exec replaces the process, so we need to mock it
      allow(cli).to receive(:exec)

      cli.run

      expect(cli).to have_received(:exec).with(
        a_string_ending_with("bin/t-ruby"),
        "test.trb"
      )
    end

    it "passes additional arguments to t-ruby" do
      cli = TRuby::CLI.new(["run", "script.trb", "arg1", "arg2"])

      allow(cli).to receive(:exec)

      cli.run

      expect(cli).to have_received(:exec).with(
        a_string_ending_with("bin/t-ruby"),
        "script.trb",
        "arg1",
        "arg2"
      )
    end
  end

  describe "#run with --watch flag" do
    it "starts watch mode with default path" do
      watcher = instance_double(TRuby::Watcher)
      allow(TRuby::Watcher).to receive(:new).and_return(watcher)
      allow(watcher).to receive(:watch)

      cli = TRuby::CLI.new(["--watch"])
      cli.run

      expect(TRuby::Watcher).to have_received(:new).with(hash_including(paths: ["."]))
      expect(watcher).to have_received(:watch)
    end

    it "starts watch mode with specified paths" do
      watcher = instance_double(TRuby::Watcher)
      allow(TRuby::Watcher).to receive(:new).and_return(watcher)
      allow(watcher).to receive(:watch)

      cli = TRuby::CLI.new(["--watch", "src/", "lib/"])
      cli.run

      expect(TRuby::Watcher).to have_received(:new).with(hash_including(paths: ["src/", "lib/"]))
    end

    it "works with -w shorthand" do
      watcher = instance_double(TRuby::Watcher)
      allow(TRuby::Watcher).to receive(:new).and_return(watcher)
      allow(watcher).to receive(:watch)

      cli = TRuby::CLI.new(["-w", "app/"])
      cli.run

      expect(TRuby::Watcher).to have_received(:new).with(hash_including(paths: ["app/"]))
    end
  end

  describe "#run with --decl flag" do
    it "generates declaration file" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        File.write(input_file, "def hello: String\\n  'world'\\nend")

        generator = instance_double(TRuby::DeclarationGenerator)
        allow(TRuby::DeclarationGenerator).to receive(:new).and_return(generator)
        allow(generator).to receive(:generate_file).and_return("#{tmpdir}/test.d.trb")

        cli = TRuby::CLI.new(["--decl", input_file])
        output = capture_stdout { cli.run }

        expect(output).to include("Generated:")
        expect(output).to include(input_file)
        expect(output).to include(".d.trb")
      end
    end

    it "handles errors gracefully" do
      generator = instance_double(TRuby::DeclarationGenerator)
      allow(TRuby::DeclarationGenerator).to receive(:new).and_return(generator)
      allow(generator).to receive(:generate_file).and_raise(ArgumentError, "Invalid file")

      cli = TRuby::CLI.new(["--decl", "/nonexistent.trb"])
      output = capture_stdout do
        cli.run
      rescue SystemExit
        # Expected
      end

      expect(output).to include("Error:")
      expect(output).to include("Invalid file")
    end
  end

  describe "#run with --config flag" do
    it "uses custom config file" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        config_file = File.join(tmpdir, "custom.yml")
        File.write(input_file, "puts 'hello'")
        File.write(config_file, "output:\\n  ruby_dir: #{tmpdir}")

        cli = TRuby::CLI.new(["--config", config_file, input_file])
        output = capture_stdout { cli.run }

        expect(output).to include("Compiled:")
      end
    end

    it "uses -c shorthand" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        config_file = File.join(tmpdir, "my.yml")
        File.write(input_file, "puts 'hello'")
        File.write(config_file, "output:\\n  ruby_dir: #{tmpdir}")

        cli = TRuby::CLI.new(["-c", config_file, input_file])
        output = capture_stdout { cli.run }

        expect(output).to include("Compiled:")
      end
    end
  end

  describe "private #find_input_file" do
    it "finds file after flags with arguments" do
      cli = TRuby::CLI.new(["--config", "custom.yml", "input.trb"])
      input_file = cli.send(:find_input_file)
      expect(input_file).to eq("input.trb")
    end

    it "finds file after multiple flags" do
      cli = TRuby::CLI.new(["--decl", "decl.trb", "--config", "c.yml", "main.trb"])
      input_file = cli.send(:find_input_file)
      expect(input_file).to eq("main.trb")
    end

    it "skips flags without arguments" do
      cli = TRuby::CLI.new(["--verbose", "file.trb"])
      input_file = cli.send(:find_input_file)
      expect(input_file).to eq("file.trb")
    end

    it "returns nil when no input file found" do
      cli = TRuby::CLI.new(["--config", "custom.yml"])
      input_file = cli.send(:find_input_file)
      expect(input_file).to be_nil
    end
  end

  describe "private #extract_config_path" do
    it "extracts config path from --config flag" do
      cli = TRuby::CLI.new(["--config", "my_config.yml", "file.trb"])
      config_path = cli.send(:extract_config_path)
      expect(config_path).to eq("my_config.yml")
    end

    it "extracts config path from -c flag" do
      cli = TRuby::CLI.new(["-c", "short.yml", "file.trb"])
      config_path = cli.send(:extract_config_path)
      expect(config_path).to eq("short.yml")
    end

    it "returns nil when no config flag present" do
      cli = TRuby::CLI.new(["file.trb"])
      config_path = cli.send(:extract_config_path)
      expect(config_path).to be_nil
    end
  end

  # Helper to capture stdout
  def capture_stdout
    old_stdout = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = old_stdout
  end

  # Helper to capture stderr
  def capture_stderr
    old_stderr = $stderr
    $stderr = StringIO.new
    yield
    $stderr.string
  ensure
    $stderr = old_stderr
  end
end
`,
  "spec/t_ruby/code_emitter_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::CodeEmitter do
  describe ".for_version" do
    it "returns Ruby30 emitter for version 3.0" do
      emitter = described_class.for_version("3.0")
      expect(emitter).to be_a(TRuby::CodeEmitter::Ruby30)
      expect(emitter.version).to eq(TRuby::RubyVersion.parse("3.0"))
    end

    it "returns Ruby31 emitter for version 3.1" do
      emitter = described_class.for_version("3.1")
      expect(emitter).to be_a(TRuby::CodeEmitter::Ruby31)
    end

    it "returns Ruby34 emitter for version 3.4" do
      emitter = described_class.for_version("3.4")
      expect(emitter).to be_a(TRuby::CodeEmitter::Ruby34)
    end

    it "returns Ruby40 emitter for version 4.0" do
      emitter = described_class.for_version("4.0")
      expect(emitter).to be_a(TRuby::CodeEmitter::Ruby40)
    end

    it "returns appropriate emitter for intermediate versions" do
      # 3.2 should use Ruby31 (supports anonymous block forwarding)
      expect(described_class.for_version("3.2")).to be_a(TRuby::CodeEmitter::Ruby31)
      expect(described_class.for_version("3.3")).to be_a(TRuby::CodeEmitter::Ruby31)

      # 3.5 should use Ruby34 (supports it parameter)
      expect(described_class.for_version("3.5")).to be_a(TRuby::CodeEmitter::Ruby34)

      # 4.1 should use Ruby40
      expect(described_class.for_version("4.1")).to be_a(TRuby::CodeEmitter::Ruby40)
    end
  end

  describe TRuby::CodeEmitter::Ruby30 do
    let(:emitter) { described_class.new(TRuby::RubyVersion.parse("3.0")) }

    describe "#transform_numbered_params" do
      it "preserves _1, _2 syntax" do
        source = "items.map { _1 * 2 }"
        expect(emitter.transform_numbered_params(source)).to eq("items.map { _1 * 2 }")
      end

      it "preserves multiple numbered params" do
        source = "hash.map { [_1, _2] }"
        expect(emitter.transform_numbered_params(source)).to eq("hash.map { [_1, _2] }")
      end
    end

    describe "#transform_block_forwarding" do
      it "preserves named block forwarding" do
        source = "def foo(&block)\\n  bar(&block)\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq("def foo(&block)\\n  bar(&block)\\nend")
      end
    end
  end

  describe TRuby::CodeEmitter::Ruby31 do
    let(:emitter) { described_class.new(TRuby::RubyVersion.parse("3.1")) }

    describe "#transform_numbered_params" do
      it "preserves _1, _2 syntax" do
        source = "items.map { _1 * 2 }"
        expect(emitter.transform_numbered_params(source)).to eq("items.map { _1 * 2 }")
      end
    end

    describe "#transform_block_forwarding" do
      it "converts named block to anonymous forwarding" do
        source = "def foo(&block)\\n  bar(&block)\\nend"
        expected = "def foo(&)\\n  bar(&)\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq(expected)
      end

      it "handles multiple block forwards in same method" do
        source = "def foo(&block)\\n  bar(&block)\\n  baz(&block)\\nend"
        expected = "def foo(&)\\n  bar(&)\\n  baz(&)\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq(expected)
      end

      it "does not transform when block is used for other purposes" do
        # If block is called directly, we can't use anonymous forwarding
        source = "def foo(&block)\\n  block.call\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq("def foo(&block)\\n  block.call\\nend")
      end
    end
  end

  describe TRuby::CodeEmitter::Ruby34 do
    let(:emitter) { described_class.new(TRuby::RubyVersion.parse("3.4")) }

    describe "#transform_numbered_params" do
      it "preserves _1, _2 syntax (still valid in 3.4)" do
        source = "items.map { _1 * 2 }"
        expect(emitter.transform_numbered_params(source)).to eq("items.map { _1 * 2 }")
      end
    end

    describe "#transform_block_forwarding" do
      it "converts named block to anonymous forwarding" do
        source = "def foo(&block)\\n  bar(&block)\\nend"
        expected = "def foo(&)\\n  bar(&)\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq(expected)
      end
    end

    describe "#supports_it?" do
      it "returns true" do
        expect(emitter.supports_it?).to be true
      end
    end
  end

  describe TRuby::CodeEmitter::Ruby40 do
    let(:emitter) { described_class.new(TRuby::RubyVersion.parse("4.0")) }

    describe "#transform_numbered_params" do
      it "converts single _1 to it" do
        source = "items.map { _1 * 2 }"
        expect(emitter.transform_numbered_params(source)).to eq("items.map { it * 2 }")
      end

      it "preserves explicit block params when multiple numbered params used" do
        # When _2 or higher is used, can't convert to it
        source = "hash.map { [_1, _2] }"
        expect(emitter.transform_numbered_params(source)).to eq("hash.map { |k, v| [k, v] }")
      end

      it "handles nested blocks correctly" do
        source = "outer.map { _1.inner.map { _1 * 2 } }"
        expected = "outer.map { it.inner.map { it * 2 } }"
        expect(emitter.transform_numbered_params(source)).to eq(expected)
      end
    end

    describe "#transform_block_forwarding" do
      it "converts named block to anonymous forwarding" do
        source = "def foo(&block)\\n  bar(&block)\\nend"
        expected = "def foo(&)\\n  bar(&)\\nend"
        expect(emitter.transform_block_forwarding(source)).to eq(expected)
      end
    end

    describe "#supports_it?" do
      it "returns true" do
        expect(emitter.supports_it?).to be true
      end
    end

    describe "#numbered_params_error?" do
      it "returns true" do
        expect(emitter.numbered_params_error?).to be true
      end
    end
  end

  describe "transform pipeline" do
    it "applies all transformations for Ruby 4.0" do
      emitter = TRuby::CodeEmitter.for_version("4.0")

      source = <<~RUBY
        def process(&block)
          items.map { _1 * 2 }
          forward(&block)
        end
      RUBY

      result = emitter.transform(source)

      expect(result).to include("{ it * 2 }")
      expect(result).to include("def process(&)")
      expect(result).to include("forward(&)")
    end

    it "preserves Ruby 3.0 syntax for 3.0 target" do
      emitter = TRuby::CodeEmitter.for_version("3.0")

      source = <<~RUBY
        def process(&block)
          items.map { _1 * 2 }
          forward(&block)
        end
      RUBY

      result = emitter.transform(source)

      expect(result).to include("{ _1 * 2 }")
      expect(result).to include("def process(&block)")
      expect(result).to include("forward(&block)")
    end
  end
end
`,
  "spec/t_ruby/compiler_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"
require "tmpdir"

describe TRuby::Compiler do
  let(:config) { TRuby::Config.new }

  describe "initialization" do
    it "initializes with a config object" do
      compiler = TRuby::Compiler.new(config)
      expect(compiler).to be_a(TRuby::Compiler)
    end
  end

  describe "#compile" do
    context "with valid .trb file" do
      it "successfully compiles a .trb file" do
        Dir.mktmpdir do |tmpdir|
          # Create a temporary .trb file
          input_file = File.join(tmpdir, "test.trb")
          File.write(input_file, "puts 'Hello, world!'")

          # Create a custom config with output in tmpdir
          {
            "emit" => { "rb" => true, "rbs" => false, "dtrb" => false },
            "paths" => { "src" => "./src", "out" => tmpdir },
            "strict" => { "rbs_compat" => true, "null_safety" => false, "inference" => "basic" },
          }
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:src_dir).and_return("./src")

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(output_path).to end_with(".rb")
          expect(File.exist?(output_path)).to be true
        end
      end

      it "returns the correct output path" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "hello.trb")
          File.write(input_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.basename(output_path)).to eq("hello.rb")
          expect(output_path).to include(tmpdir)
        end
      end

      it "creates output directory if it doesn't exist" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.trb")
          File.write(input_file, "puts 'test'")

          output_dir = File.join(tmpdir, "nested", "build")
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(output_dir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(output_dir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

          compiler = TRuby::Compiler.new(config)
          compiler.compile(input_file)

          expect(File.directory?(output_dir)).to be true
        end
      end

      it "preserves file content during compilation (Milestone 0)" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "script.trb")
          # Write content with string interpolation
          File.write(input_file, "def greet(person)" + "\\n  " \\
                                                       'puts "Hello, #{person}!"' + "\\n" \\
                                                                                    "end" + "\\n" \\
                                                                                            "\\n" \\
                                                                                            'greet("world")' + "\\n")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expected_content = File.read(input_file)
          output_content = File.read(output_path)
          expect(output_content).to eq(expected_content)
        end
      end

      it "handles multiple files in sequence" do
        Dir.mktmpdir do |tmpdir|
          files = ["file1.trb", "file2.trb", "file3.trb"]
          files.each do |filename|
            File.write(File.join(tmpdir, filename), "# content of #{filename}")
          end

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)

          files.each do |filename|
            input_path = File.join(tmpdir, filename)
            output_path = compiler.compile(input_path)

            expect(File.exist?(output_path)).to be true
            expect(File.basename(output_path)).to eq(filename.sub(".trb", ".rb"))
          end
        end
      end
    end

    context "with invalid input" do
      it "raises ArgumentError when file doesn't exist" do
        compiler = TRuby::Compiler.new(config)

        expect do
          compiler.compile("/nonexistent/path/file.trb")
        end.to raise_error(ArgumentError, /File not found/)
      end

      it "raises ArgumentError with descriptive message for missing file" do
        missing_file = "/path/to/missing.trb"
        compiler = TRuby::Compiler.new(config)

        expect do
          compiler.compile(missing_file)
        end.to raise_error(ArgumentError, /#{Regexp.escape(missing_file)}/)
      end

      it "compiles .rb files (copies and generates rbs)" do
        Dir.mktmpdir do |tmpdir|
          src_dir = File.join(tmpdir, "src")
          out_dir = File.join(tmpdir, "build")
          FileUtils.mkdir_p(src_dir)

          rb_file = File.join(src_dir, "test.rb")
          File.write(rb_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(rb_file)

          expect(output_path).to end_with(".rb")
          expect(File.exist?(output_path)).to be true
        end
      end

      it "raises ArgumentError for .txt extension" do
        Dir.mktmpdir do |tmpdir|
          txt_file = File.join(tmpdir, "test.txt")
          File.write(txt_file, "puts 'test'")

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(txt_file)
          end.to raise_error(ArgumentError, /Expected .trb or .rb file/)
        end
      end

      it "raises ArgumentError for .rbs extension" do
        Dir.mktmpdir do |tmpdir|
          rbs_file = File.join(tmpdir, "test.rbs")
          File.write(rbs_file, "def foo: () -> void")

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(rbs_file)
          end.to raise_error(ArgumentError, /Expected .trb or .rb file/)
        end
      end
    end

    context "with special characters in filenames" do
      it "handles filenames with underscores" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "my_script.trb")
          File.write(input_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.basename(output_path)).to eq("my_script.rb")
        end
      end

      it "handles filenames with hyphens" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "my-script.trb")
          File.write(input_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.basename(output_path)).to eq("my-script.rb")
        end
      end

      it "handles filenames with numbers" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "script123.trb")
          File.write(input_file, "puts 'test'")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.basename(output_path)).to eq("script123.rb")
        end
      end
    end

    context "with empty files" do
      it "handles empty .trb files" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "empty.trb")
          File.write(input_file, "")

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.read(output_path)).to eq("")
        end
      end
    end

    context "with large files" do
      it "handles larger .trb files" do
        Dir.mktmpdir do |tmpdir|
          large_content = "puts 'line'\\n" * 10_000
          input_file = File.join(tmpdir, "large.trb")
          File.write(input_file, large_content)

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          expect(File.read(output_path)).to eq(large_content)
        end
      end
    end

    context "with return type validation" do
      it "raises TypeCheckError when return type mismatches declaration" do
        Dir.mktmpdir do |tmpdir|
          # Method declares Boolean but returns nil
          input_file = File.join(tmpdir, "type_mismatch.trb")
          File.write(input_file, <<~RUBY)
            def test(name: String): Boolean
              return
            end
          RUBY

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(true)

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(input_file)
          end.to raise_error(TRuby::TypeCheckError)
        end
      end

      it "raises TypeCheckError when inferred type doesn't match declared type" do
        Dir.mktmpdir do |tmpdir|
          # Method declares Integer but returns String
          input_file = File.join(tmpdir, "type_mismatch2.trb")
          File.write(input_file, <<~RUBY)
            def get_value(): Integer
              "hello"
            end
          RUBY

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(true)

          compiler = TRuby::Compiler.new(config)

          error = nil
          begin
            compiler.compile(input_file)
          rescue TRuby::TypeCheckError => e
            error = e
          end

          expect(error).to be_a(TRuby::TypeCheckError)
          expect(error.message).to include("Integer")
          expect(error.message).to include("String")
        end
      end

      it "passes when return type matches declaration" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "type_match.trb")
          File.write(input_file, <<~RUBY)
            def greet(name: String): String
              "Hello, " + name
            end
          RUBY

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(true)

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(input_file)
          end.not_to raise_error
        end
      end

      it "skips type check when type_check config is false" do
        Dir.mktmpdir do |tmpdir|
          # Type mismatch but type_check is disabled in config
          input_file = File.join(tmpdir, "skip_check.trb")
          File.write(input_file, <<~RUBY)
            def test(): Boolean
              return
            end
          RUBY

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(false)

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(input_file)
          end.not_to raise_error
        end
      end

      it "validates class methods" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "class_method.trb")
          File.write(input_file, <<~RUBY)
            class Calculator
              def add(a: Integer, b: Integer): Integer
                "not a number"
              end
            end
          RUBY

          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(true)

          compiler = TRuby::Compiler.new(config)

          expect do
            compiler.compile(input_file)
          end.to raise_error(TRuby::TypeCheckError)
        end
      end
    end

    context "with directory structure preservation" do
      it "preserves directory structure with single source_include" do
        Dir.mktmpdir do |tmpdir|
          # Create nested source directory
          src_dir = File.join(tmpdir, "src")
          nested_dir = File.join(src_dir, "models", "user")
          FileUtils.mkdir_p(nested_dir)

          input_file = File.join(nested_dir, "account.trb")
          File.write(input_file, "puts 'account'")

          out_dir = File.join(tmpdir, "build")

          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src_dir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          # Single source_include: exclude source dir name
          # src/models/user/account.trb → build/models/user/account.rb
          expected_path = File.join(out_dir, "models", "user", "account.rb")
          expect(output_path).to eq(expected_path)
          expect(File.exist?(output_path)).to be true
        end
      end

      it "preserves relative path for files outside source directories" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            # Create source directory and a file outside it
            src_dir = File.join(tmpdir, "src")
            FileUtils.mkdir_p(src_dir)

            external_dir = File.join(tmpdir, "external")
            FileUtils.mkdir_p(external_dir)

            input_file = File.join(external_dir, "external.trb")
            File.write(input_file, "puts 'external'")

            out_dir = File.join(tmpdir, "build")

            allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src_dir])
            allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })

            compiler = TRuby::Compiler.new(config)
            output_path = compiler.compile(input_file)

            # File outside source directories: preserve relative path from cwd
            # external/external.trb → build/external/external.rb
            expected_path = File.join(out_dir, "external", "external.rb")
            expect(output_path).to eq(expected_path)
            expect(File.exist?(output_path)).to be true
          end
        end
      end

      it "preserves structure for .rb files when copying" do
        Dir.mktmpdir do |tmpdir|
          # Create nested source directory
          src_dir = File.join(tmpdir, "src")
          nested_dir = File.join(src_dir, "lib", "utils")
          FileUtils.mkdir_p(nested_dir)

          input_file = File.join(nested_dir, "helper.rb")
          File.write(input_file, "puts 'helper'")

          out_dir = File.join(tmpdir, "build")

          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src_dir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })

          compiler = TRuby::Compiler.new(config)
          output_path = compiler.compile(input_file)

          # Should preserve the nested structure
          expected_path = File.join(out_dir, "lib", "utils", "helper.rb")
          expect(output_path).to eq(expected_path)
          expect(File.exist?(output_path)).to be true
        end
      end

      it "generates RBS files with preserved structure" do
        Dir.mktmpdir do |tmpdir|
          # Create nested source directory
          src_dir = File.join(tmpdir, "src")
          nested_dir = File.join(src_dir, "services")
          FileUtils.mkdir_p(nested_dir)

          input_file = File.join(nested_dir, "auth.trb")
          File.write(input_file, "def login(user: String): Boolean\\n  true\\nend")

          out_dir = File.join(tmpdir, "build")
          rbs_dir = File.join(tmpdir, "sig")

          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(rbs_dir)
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src_dir])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => true })
          allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(false)

          compiler = TRuby::Compiler.new(config)
          compiler.compile(input_file)

          # Check RBS file is in the right place
          expected_rbs_path = File.join(rbs_dir, "services", "auth.rbs")
          expect(File.exist?(expected_rbs_path)).to be true
        end
      end

      it "includes source dir name with multiple source_include directories" do
        Dir.mktmpdir do |tmpdir|
          # Create two source directories
          src1 = File.join(tmpdir, "app")
          src2 = File.join(tmpdir, "lib")
          FileUtils.mkdir_p(File.join(src1, "models"))
          FileUtils.mkdir_p(File.join(src2, "utils"))

          input_file1 = File.join(src1, "models", "user.trb")
          input_file2 = File.join(src2, "utils", "helper.trb")
          File.write(input_file1, "puts 'user'")
          File.write(input_file2, "puts 'helper'")

          out_dir = File.join(tmpdir, "build")

          allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
          allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src1, src2])
          allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })

          compiler = TRuby::Compiler.new(config)

          output1 = compiler.compile(input_file1)
          output2 = compiler.compile(input_file2)

          # Multiple source_include: include source dir name
          # app/models/user.trb → build/app/models/user.rb
          # lib/utils/helper.trb → build/lib/utils/helper.rb
          expect(output1).to eq(File.join(out_dir, "app", "models", "user.rb"))
          expect(output2).to eq(File.join(out_dir, "lib", "utils", "helper.rb"))
        end
      end

      it "handles file in current directory" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            input_file = File.join(tmpdir, "hello.trb")
            File.write(input_file, "puts 'hello'")

            out_dir = File.join(tmpdir, "build")
            src_dir = File.join(tmpdir, "src")

            allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(out_dir)
            allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([src_dir])
            allow_any_instance_of(TRuby::Config).to receive(:compiler).and_return({ "generate_rbs" => false })

            compiler = TRuby::Compiler.new(config)
            output_path = compiler.compile(input_file)

            # File in cwd: hello.trb → build/hello.rb
            expected_path = File.join(out_dir, "hello.rb")
            expect(output_path).to eq(expected_path)
            expect(File.exist?(output_path)).to be true
          end
        end
      end
    end
  end

  describe "#compile_with_diagnostics" do
    it "returns success result for valid code" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "valid.trb")
        File.write(input_file, <<~TRB)
          def greet(name: String): String
            "Hello, \\#{name}!"
          end
        TRB

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(input_file)

        expect(result[:success]).to be true
        expect(result[:diagnostics]).to be_empty
      end
    end

    it "returns diagnostics for colon spacing errors" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "invalid.trb")
        # Space before colon is invalid
        File.write(input_file, <<~TRB)
          def broken() : String
            "test"
          end
        TRB

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(input_file)

        expect(result[:success]).to be false
        expect(result[:diagnostics]).not_to be_empty
        expect(result[:diagnostics].first).to be_a(TRuby::Diagnostic)
        expect(result[:diagnostics].first.code).to eq("TR1003")
      end
    end

    it "returns diagnostics for file not found" do
      Dir.mktmpdir do |tmpdir|
        nonexistent_file = File.join(tmpdir, "does_not_exist.trb")

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(nonexistent_file)

        expect(result[:success]).to be false
        expect(result[:diagnostics]).not_to be_empty
        expect(result[:diagnostics].first.message).to include("not found")
      end
    end

    it "returns diagnostics for invalid extension" do
      Dir.mktmpdir do |tmpdir|
        invalid_file = File.join(tmpdir, "test.txt")
        File.write(invalid_file, "puts 'hello'")

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(invalid_file)

        expect(result[:success]).to be false
        expect(result[:diagnostics]).not_to be_empty
        expect(result[:diagnostics].first.message).to include("Expected .trb or .rb")
      end
    end

    it "returns diagnostics for type check errors" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "type_error.trb")
        File.write(input_file, <<~TRB)
          def get_number(): Integer
            "not a number"
          end
        TRB

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])
        allow_any_instance_of(TRuby::Config).to receive(:type_check?).and_return(true)

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(input_file)

        expect(result[:success]).to be false
        expect(result[:diagnostics]).not_to be_empty
      end
    end

    it "returns multiple diagnostics when there are multiple errors" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "multi_error.trb")
        File.write(input_file, <<~TRB)
          def error1() : String
            "test"
          end

          def error2():String
            "test"
          end
        TRB

        allow_any_instance_of(TRuby::Config).to receive(:out_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:ruby_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:rbs_dir).and_return(tmpdir)
        allow_any_instance_of(TRuby::Config).to receive(:source_include).and_return([tmpdir])

        compiler = TRuby::Compiler.new(config)
        result = compiler.compile_with_diagnostics(input_file)

        expect(result[:success]).to be false
        expect(result[:diagnostics].length).to be >= 2
      end
    end
  end
end
`,
  "spec/t_ruby/config_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"
require "tempfile"

describe TRuby::Config do
  # Helper method to create a config with custom YAML
  def create_config(yaml_content)
    Dir.mktmpdir do |tmpdir|
      config_path = File.join(tmpdir, "trbconfig.yml")
      File.write(config_path, yaml_content)
      yield TRuby::Config.new(config_path)
    end
  end

  describe "compiler.strictness" do
    it "returns 'standard' by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.strictness).to eq("standard")
        end
      end
    end

    it "returns 'strict' when set" do
      yaml = <<~YAML
        compiler:
          strictness: strict
      YAML

      create_config(yaml) do |config|
        expect(config.strictness).to eq("strict")
      end
    end

    it "returns 'permissive' when set" do
      yaml = <<~YAML
        compiler:
          strictness: permissive
      YAML

      create_config(yaml) do |config|
        expect(config.strictness).to eq("permissive")
      end
    end

    it "validates strictness value" do
      yaml = <<~YAML
        compiler:
          strictness: invalid
      YAML

      expect do
        create_config(yaml, &:validate!)
      end.to raise_error(TRuby::ConfigError)
    end
  end

  describe "compiler.generate_rbs" do
    it "returns true by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.generate_rbs?).to be true
        end
      end
    end

    it "returns false when set to false" do
      yaml = <<~YAML
        compiler:
          generate_rbs: false
      YAML

      create_config(yaml) do |config|
        expect(config.generate_rbs?).to be false
      end
    end

    it "returns true when set to true" do
      yaml = <<~YAML
        compiler:
          generate_rbs: true
      YAML

      create_config(yaml) do |config|
        expect(config.generate_rbs?).to be true
      end
    end
  end

  describe "compiler.target_ruby" do
    it "auto-detects current Ruby version by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expected = "#{RUBY_VERSION.split(".")[0]}.#{RUBY_VERSION.split(".")[1]}"
          expect(config.target_ruby).to eq(expected)
        end
      end
    end

    it "returns custom version when set" do
      yaml = <<~YAML
        compiler:
          target_ruby: "3.2"
      YAML

      create_config(yaml) do |config|
        expect(config.target_ruby).to eq("3.2")
      end
    end

    it "supports version without quotes" do
      yaml = <<~YAML
        compiler:
          target_ruby: 3.3
      YAML

      create_config(yaml) do |config|
        expect(config.target_ruby).to eq("3.3")
      end
    end

    it "raises UnsupportedRubyVersionError for unsupported version" do
      yaml = <<~YAML
        compiler:
          target_ruby: "2.7"
      YAML

      create_config(yaml) do |config|
        expect { config.target_ruby }.to raise_error(TRuby::UnsupportedRubyVersionError)
      end
    end

    it "provides target_ruby_version as RubyVersion object" do
      yaml = <<~YAML
        compiler:
          target_ruby: "3.4"
      YAML

      create_config(yaml) do |config|
        version = config.target_ruby_version
        expect(version).to be_a(TRuby::RubyVersion)
        expect(version.major).to eq(3)
        expect(version.minor).to eq(4)
      end
    end
  end

  describe "compiler.experimental" do
    it "returns empty array by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.experimental_features).to eq([])
        end
      end
    end

    it "returns configured experimental features" do
      yaml = <<~YAML
        compiler:
          experimental:
            - decorators
            - pattern_matching
      YAML

      create_config(yaml) do |config|
        expect(config.experimental_features).to eq(%w[decorators pattern_matching])
      end
    end

    it "checks if a specific feature is enabled" do
      yaml = <<~YAML
        compiler:
          experimental:
            - decorators
      YAML

      create_config(yaml) do |config|
        expect(config.experimental_enabled?("decorators")).to be true
        expect(config.experimental_enabled?("pattern_matching")).to be false
      end
    end
  end

  describe "compiler.checks.no_implicit_any" do
    it "returns false by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.check_no_implicit_any?).to be false
        end
      end
    end

    it "returns true when enabled" do
      yaml = <<~YAML
        compiler:
          checks:
            no_implicit_any: true
      YAML

      create_config(yaml) do |config|
        expect(config.check_no_implicit_any?).to be true
      end
    end

    it "returns false when disabled" do
      yaml = <<~YAML
        compiler:
          checks:
            no_implicit_any: false
      YAML

      create_config(yaml) do |config|
        expect(config.check_no_implicit_any?).to be false
      end
    end
  end

  describe "compiler.checks.no_unused_vars" do
    it "returns false by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.check_no_unused_vars?).to be false
        end
      end
    end

    it "returns true when enabled" do
      yaml = <<~YAML
        compiler:
          checks:
            no_unused_vars: true
      YAML

      create_config(yaml) do |config|
        expect(config.check_no_unused_vars?).to be true
      end
    end

    it "returns false when disabled" do
      yaml = <<~YAML
        compiler:
          checks:
            no_unused_vars: false
      YAML

      create_config(yaml) do |config|
        expect(config.check_no_unused_vars?).to be false
      end
    end
  end

  describe "compiler.checks.strict_nil" do
    it "returns false by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.check_strict_nil?).to be false
        end
      end
    end

    it "returns true when enabled" do
      yaml = <<~YAML
        compiler:
          checks:
            strict_nil: true
      YAML

      create_config(yaml) do |config|
        expect(config.check_strict_nil?).to be true
      end
    end

    it "returns false when disabled" do
      yaml = <<~YAML
        compiler:
          checks:
            strict_nil: false
      YAML

      create_config(yaml) do |config|
        expect(config.check_strict_nil?).to be false
      end
    end
  end

  describe "watch.paths" do
    it "returns empty array by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.watch_paths).to eq([])
        end
      end
    end

    it "returns configured paths" do
      yaml = <<~YAML
        watch:
          paths:
            - config
            - types
      YAML

      create_config(yaml) do |config|
        expect(config.watch_paths).to eq(%w[config types])
      end
    end
  end

  describe "watch.debounce" do
    it "returns 100 by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.watch_debounce).to eq(100)
        end
      end
    end

    it "returns configured debounce value" do
      yaml = <<~YAML
        watch:
          debounce: 200
      YAML

      create_config(yaml) do |config|
        expect(config.watch_debounce).to eq(200)
      end
    end
  end

  describe "watch.clear_screen" do
    it "returns false by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.watch_clear_screen?).to be false
        end
      end
    end

    it "returns true when enabled" do
      yaml = <<~YAML
        watch:
          clear_screen: true
      YAML

      create_config(yaml) do |config|
        expect(config.watch_clear_screen?).to be true
      end
    end

    it "returns false when disabled" do
      yaml = <<~YAML
        watch:
          clear_screen: false
      YAML

      create_config(yaml) do |config|
        expect(config.watch_clear_screen?).to be false
      end
    end
  end

  describe "watch.on_success" do
    it "returns nil by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.watch_on_success).to be_nil
        end
      end
    end

    it "returns configured command" do
      yaml = <<~YAML
        watch:
          on_success: "bundle exec rspec"
      YAML

      create_config(yaml) do |config|
        expect(config.watch_on_success).to eq("bundle exec rspec")
      end
    end
  end

  describe "version requirement" do
    it "returns nil by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.version_requirement).to be_nil
        end
      end
    end

    it "returns configured version requirement" do
      yaml = <<~YAML
        version: ">=1.0.0"
      YAML

      create_config(yaml) do |config|
        expect(config.version_requirement).to eq(">=1.0.0")
      end
    end

    it "checks if current version satisfies requirement" do
      yaml = <<~YAML
        version: ">=0.0.1"
      YAML

      create_config(yaml) do |config|
        expect(config.version_satisfied?).to be true
      end
    end

    it "returns false when version requirement is not met" do
      yaml = <<~YAML
        version: ">=99.0.0"
      YAML

      create_config(yaml) do |config|
        expect(config.version_satisfied?).to be false
      end
    end

    it "returns true when no version requirement is specified" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.version_satisfied?).to be true
        end
      end
    end
  end

  describe "output.clean_before_build" do
    it "returns false by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.clean_before_build?).to be false
        end
      end
    end

    it "returns true when set to true" do
      yaml = <<~YAML
        output:
          clean_before_build: true
      YAML

      create_config(yaml) do |config|
        expect(config.clean_before_build?).to be true
      end
    end

    it "returns false when set to false" do
      yaml = <<~YAML
        output:
          clean_before_build: false
      YAML

      create_config(yaml) do |config|
        expect(config.clean_before_build?).to be false
      end
    end
  end

  # NOTE: preserve_structure option has been removed
  # Directory structure is now always preserved based on source_include configuration:
  # - Single source_include: excludes source dir name (src/models/user.trb → build/models/user.rb)
  # - Multiple source_include: includes source dir name (src/models/user.trb → build/src/models/user.rb)

  describe "output.rbs_dir" do
    it "returns nil by default (uses ruby_dir)" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.output["rbs_dir"]).to be_nil
          expect(config.rbs_dir).to eq("build") # Falls back to ruby_dir
        end
      end
    end

    it "returns custom rbs_dir from config" do
      yaml = <<~YAML
        output:
          ruby_dir: build
          rbs_dir: sig
      YAML

      create_config(yaml) do |config|
        expect(config.rbs_dir).to eq("sig")
      end
    end

    it "uses ruby_dir when rbs_dir is not specified" do
      yaml = <<~YAML
        output:
          ruby_dir: dist
      YAML

      create_config(yaml) do |config|
        expect(config.rbs_dir).to eq("dist")
      end
    end
  end

  describe "output.ruby_dir" do
    it "returns default ruby_dir 'build'" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.ruby_dir).to eq("build")
        end
      end
    end

    it "returns custom ruby_dir from config" do
      yaml = <<~YAML
        output:
          ruby_dir: dist
      YAML

      create_config(yaml) do |config|
        expect(config.ruby_dir).to eq("dist")
      end
    end

    it "ruby_dir is aliased to out_dir for backwards compatibility" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.out_dir).to eq(config.ruby_dir)
        end
      end
    end
  end

  describe "source.extensions" do
    it "returns default extension .trb" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.source_extensions).to eq([".trb"])
        end
      end
    end

    it "returns custom extensions from config" do
      yaml = <<~YAML
        source:
          extensions:
            - .trb
            - .truby
            - .rb
      YAML

      create_config(yaml) do |config|
        expect(config.source_extensions).to eq([".trb", ".truby", ".rb"])
      end
    end

    it "finds files with custom extensions" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          FileUtils.mkdir_p("src")
          File.write("src/main.trb", "# main")
          File.write("src/utils.truby", "# utils")
          File.write("src/helper.rb", "# helper")
          File.write("src/readme.md", "# readme")

          File.write("trbconfig.yml", <<~YAML)
            source:
              extensions:
                - .trb
                - .truby
          YAML

          config = TRuby::Config.new
          files = config.find_source_files

          expect(files.size).to eq(2)
          expect(files.map { |f| File.basename(f) }).to contain_exactly("main.trb", "utils.truby")
        end
      end
    end
  end

  describe "source.exclude" do
    it "returns empty array by default" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.source_exclude).to eq([])
        end
      end
    end

    it "returns custom exclude patterns from config" do
      yaml = <<~YAML
        source:
          exclude:
            - "**/*_test.trb"
            - "**/fixtures/**"
            - vendor
      YAML

      create_config(yaml) do |config|
        expect(config.source_exclude).to eq(["**/*_test.trb", "**/fixtures/**", "vendor"])
      end
    end

    it "excludes files matching patterns" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          FileUtils.mkdir_p("src/tests")
          FileUtils.mkdir_p("src/vendor")
          File.write("src/main.trb", "# main")
          File.write("src/tests/main_test.trb", "# test")
          File.write("src/vendor/lib.trb", "# vendor lib")

          File.write("trbconfig.yml", <<~YAML)
            source:
              exclude:
                - tests
                - vendor
          YAML

          config = TRuby::Config.new
          files = config.find_source_files

          expect(files.size).to eq(1)
          expect(files.first).to end_with("main.trb")
        end
      end
    end
  end

  describe "source.include" do
    it "returns source include directories" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.source_include).to eq(["src"])
        end
      end
    end

    it "returns custom include directories from config" do
      yaml = <<~YAML
        source:
          include:
            - src
            - lib
            - app/models
      YAML

      create_config(yaml) do |config|
        expect(config.source_include).to eq(["src", "lib", "app/models"])
      end
    end

    it "uses source_include in find_source_files" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          FileUtils.mkdir_p("src")
          FileUtils.mkdir_p("lib")
          File.write("src/main.trb", "# main")
          File.write("lib/utils.trb", "# utils")

          File.write("trbconfig.yml", <<~YAML)
            source:
              include:
                - src
                - lib
          YAML

          config = TRuby::Config.new
          files = config.find_source_files

          expect(files.size).to eq(2)
          expect(files.map { |f| File.basename(f) }).to contain_exactly("main.trb", "utils.trb")
        end
      end
    end
  end

  describe "new schema structure" do
    describe "DEFAULT_CONFIG" do
      it "has source section" do
        expect(TRuby::Config::DEFAULT_CONFIG).to have_key("source")
        expect(TRuby::Config::DEFAULT_CONFIG["source"]).to have_key("include")
        expect(TRuby::Config::DEFAULT_CONFIG["source"]).to have_key("exclude")
        expect(TRuby::Config::DEFAULT_CONFIG["source"]).to have_key("extensions")
      end

      it "has output section" do
        expect(TRuby::Config::DEFAULT_CONFIG).to have_key("output")
        expect(TRuby::Config::DEFAULT_CONFIG["output"]).to have_key("ruby_dir")
        expect(TRuby::Config::DEFAULT_CONFIG["output"]).to have_key("rbs_dir")
        expect(TRuby::Config::DEFAULT_CONFIG["output"]).to have_key("clean_before_build")
      end

      it "has compiler section" do
        expect(TRuby::Config::DEFAULT_CONFIG).to have_key("compiler")
        expect(TRuby::Config::DEFAULT_CONFIG["compiler"]).to have_key("strictness")
        expect(TRuby::Config::DEFAULT_CONFIG["compiler"]).to have_key("generate_rbs")
        expect(TRuby::Config::DEFAULT_CONFIG["compiler"]).to have_key("target_ruby")
        expect(TRuby::Config::DEFAULT_CONFIG["compiler"]).to have_key("experimental")
        expect(TRuby::Config::DEFAULT_CONFIG["compiler"]).to have_key("checks")
      end

      it "has watch section" do
        expect(TRuby::Config::DEFAULT_CONFIG).to have_key("watch")
        expect(TRuby::Config::DEFAULT_CONFIG["watch"]).to have_key("paths")
        expect(TRuby::Config::DEFAULT_CONFIG["watch"]).to have_key("debounce")
        expect(TRuby::Config::DEFAULT_CONFIG["watch"]).to have_key("clear_screen")
        expect(TRuby::Config::DEFAULT_CONFIG["watch"]).to have_key("on_success")
      end

      it "is frozen" do
        expect(TRuby::Config::DEFAULT_CONFIG).to be_frozen
      end
    end

    describe "initialization with new schema" do
      it "parses source section" do
        yaml = <<~YAML
          source:
            include:
              - src
              - lib
            exclude:
              - "**/*_test.trb"
            extensions:
              - .trb
              - .truby
        YAML

        create_config(yaml) do |config|
          expect(config.source["include"]).to eq(%w[src lib])
          expect(config.source["exclude"]).to eq(["**/*_test.trb"])
          expect(config.source["extensions"]).to eq([".trb", ".truby"])
        end
      end

      it "parses output section" do
        yaml = <<~YAML
          output:
            ruby_dir: dist
            rbs_dir: sig
            clean_before_build: true
        YAML

        create_config(yaml) do |config|
          expect(config.output["ruby_dir"]).to eq("dist")
          expect(config.output["rbs_dir"]).to eq("sig")
          expect(config.output["clean_before_build"]).to eq(true)
        end
      end

      it "parses compiler section" do
        yaml = <<~YAML
          compiler:
            strictness: strict
            generate_rbs: false
            target_ruby: "3.2"
            experimental:
              - pattern_matching_types
            checks:
              no_implicit_any: true
              no_unused_vars: true
              strict_nil: true
        YAML

        create_config(yaml) do |config|
          expect(config.compiler["strictness"]).to eq("strict")
          expect(config.compiler["generate_rbs"]).to eq(false)
          expect(config.compiler["target_ruby"]).to eq("3.2")
          expect(config.compiler["experimental"]).to eq(["pattern_matching_types"])
          expect(config.compiler["checks"]["no_implicit_any"]).to eq(true)
          expect(config.compiler["checks"]["no_unused_vars"]).to eq(true)
          expect(config.compiler["checks"]["strict_nil"]).to eq(true)
        end
      end

      it "parses watch section" do
        yaml = <<~YAML
          watch:
            paths:
              - config
            debounce: 200
            clear_screen: true
            on_success: "bundle exec rspec"
        YAML

        create_config(yaml) do |config|
          expect(config.watch["paths"]).to eq(["config"])
          expect(config.watch["debounce"]).to eq(200)
          expect(config.watch["clear_screen"]).to eq(true)
          expect(config.watch["on_success"]).to eq("bundle exec rspec")
        end
      end
    end

    describe "default values" do
      it "uses default source values when not specified" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            config = TRuby::Config.new
            expect(config.source["include"]).to eq(["src"])
            expect(config.source["exclude"]).to eq([])
            expect(config.source["extensions"]).to eq([".trb"])
          end
        end
      end

      it "uses default output values when not specified" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            config = TRuby::Config.new
            expect(config.output["ruby_dir"]).to eq("build")
            expect(config.output["rbs_dir"]).to be_nil
            expect(config.output["clean_before_build"]).to eq(false)
          end
        end
      end

      it "uses default compiler values when not specified" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            config = TRuby::Config.new
            expect(config.compiler["strictness"]).to eq("standard")
            expect(config.compiler["generate_rbs"]).to eq(true)
            # target_ruby defaults to nil (auto-detect), but target_ruby method returns current version
            expect(config.compiler["target_ruby"]).to be_nil
            expected_ruby = "#{RUBY_VERSION.split(".")[0]}.#{RUBY_VERSION.split(".")[1]}"
            expect(config.target_ruby).to eq(expected_ruby)
            expect(config.compiler["experimental"]).to eq([])
            expect(config.compiler["checks"]["no_implicit_any"]).to eq(false)
            expect(config.compiler["checks"]["no_unused_vars"]).to eq(false)
            expect(config.compiler["checks"]["strict_nil"]).to eq(false)
          end
        end
      end

      it "uses default watch values when not specified" do
        Dir.mktmpdir do |tmpdir|
          Dir.chdir(tmpdir) do
            config = TRuby::Config.new
            expect(config.watch["paths"]).to eq([])
            expect(config.watch["debounce"]).to eq(100)
            expect(config.watch["clear_screen"]).to eq(false)
            expect(config.watch["on_success"]).to be_nil
          end
        end
      end
    end
  end

  describe "legacy schema migration" do
    it "detects legacy emit key and migrates to compiler.generate_rbs" do
      yaml = <<~YAML
        emit:
          rb: true
          rbs: true
          dtrb: false
      YAML

      create_config(yaml) do |config|
        expect(config.compiler["generate_rbs"]).to eq(true)
      end
    end

    it "detects legacy paths key and migrates to output/source" do
      yaml = <<~YAML
        paths:
          src: ./source
          out: ./output
      YAML

      create_config(yaml) do |config|
        expect(config.source["include"]).to include("source")
        expect(config.output["ruby_dir"]).to eq("output")
      end
    end

    it "outputs deprecation warning for legacy config" do
      yaml = <<~YAML
        emit:
          rbs: true
      YAML

      expect do
        create_config(yaml) { |_| }
      end.to output(/DEPRECATED|deprecated|legacy/i).to_stderr
    end
  end

  # Keep backwards compatibility tests for now
  describe "initialization with default config" do
    it "initializes with default configuration when no config file exists" do
      # Use a temporary directory that doesn't have a trbconfig.yml
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new

          expect(config).to be_a(TRuby::Config)
          # New schema accessors
          expect(config.source).to be_a(Hash)
          expect(config.output).to be_a(Hash)
          expect(config.compiler).to be_a(Hash)
        end
      end
    end

    it "has correct default out_dir (backwards compatible)" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.out_dir).to eq("build")
        end
      end
    end

    it "has correct default src_dir (backwards compatible)" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.src_dir).to eq("src")
        end
      end
    end
  end

  describe "initialization with custom config file" do
    it "loads configuration from specified config path (new schema)" do
      Dir.mktmpdir do |tmpdir|
        config_file = File.join(tmpdir, "custom.yml")
        File.write(config_file, <<~YAML)
          source:
            include:
              - source
          output:
            ruby_dir: output
          compiler:
            strictness: strict
            generate_rbs: false
        YAML

        config = TRuby::Config.new(config_file)

        expect(config.source["include"]).to eq(["source"])
        expect(config.output["ruby_dir"]).to eq("output")
        expect(config.compiler["strictness"]).to eq("strict")
        expect(config.compiler["generate_rbs"]).to eq(false)
      end
    end

    it "falls back to default config if specified file doesn't exist" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new("/nonexistent/path/config.yml")

          expect(config.compiler["generate_rbs"]).to eq(true)
          expect(config.out_dir).to eq("build")
        end
      end
    end

    it "loads trbconfig.yml from current directory if it exists" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          File.write("trbconfig.yml", <<~YAML)
            source:
              include:
                - lib
            output:
              ruby_dir: dist
            compiler:
              strictness: strict
          YAML

          config = TRuby::Config.new

          expect(config.source["include"]).to eq(["lib"])
          expect(config.out_dir).to eq("dist")
          expect(config.src_dir).to eq("lib")
          expect(config.compiler["strictness"]).to eq("strict")
        end
      end
    end

    it "prefers explicitly passed config path over trbconfig.yml" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          # Create trbconfig.yml with one config
          File.write("trbconfig.yml", <<~YAML)
            output:
              ruby_dir: default_build
          YAML

          # Create explicit config with different path
          explicit_config = File.join(tmpdir, "explicit.yml")
          File.write(explicit_config, <<~YAML)
            output:
              ruby_dir: explicit_build
          YAML

          config = TRuby::Config.new(explicit_config)

          expect(config.out_dir).to eq("explicit_build")
        end
      end
    end
  end

  describe "attr_reader accessors" do
    it "provides read-only access to source" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect { config.source = {} }.to raise_error(NoMethodError)
        end
      end
    end

    it "provides read-only access to output" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect { config.output = {} }.to raise_error(NoMethodError)
        end
      end
    end

    it "provides read-only access to compiler" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect { config.compiler = {} }.to raise_error(NoMethodError)
        end
      end
    end

    it "provides read-only access to watch" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect { config.watch = {} }.to raise_error(NoMethodError)
        end
      end
    end
  end

  describe "#excluded?" do
    it "excludes .git directory (auto-exclude)" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.excluded?(".git/config")).to be true
          expect(config.excluded?(".git/objects/foo")).to be true
        end
      end
    end

    it "excludes output directory (auto-exclude)" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          File.write("trbconfig.yml", <<~YAML)
            output:
              ruby_dir: dist
          YAML

          config = TRuby::Config.new
          expect(config.excluded?("dist/compiled.rb")).to be true
        end
      end
    end

    it "does not exclude regular source files" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          expect(config.excluded?("app/models/user.trb")).to be false
          expect(config.excluded?("lib/utils.rb")).to be false
        end
      end
    end
  end

  describe "#find_source_files" do
    it "finds .trb files in src directory" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          FileUtils.mkdir_p("src/models")
          FileUtils.mkdir_p("src/lib")
          File.write("src/main.trb", "# main")
          File.write("src/models/user.trb", "# user")
          File.write("src/lib/utils.trb", "# utils")

          config = TRuby::Config.new
          files = config.find_source_files

          expect(files.size).to eq(3)
          expect(files).to include(File.expand_path("src/main.trb"))
          expect(files).to include(File.expand_path("src/models/user.trb"))
          expect(files).to include(File.expand_path("src/lib/utils.trb"))
        end
      end
    end

    it "excludes files matching exclude patterns" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          FileUtils.mkdir_p("src/node_modules/pkg")
          FileUtils.mkdir_p("src/vendor")
          File.write("src/main.trb", "# main")
          File.write("src/node_modules/pkg/index.trb", "# pkg")
          File.write("src/vendor/lib.trb", "# lib")

          File.write("trbconfig.yml", <<~YAML)
            source:
              exclude:
                - node_modules
                - vendor
          YAML

          config = TRuby::Config.new
          files = config.find_source_files

          expect(files.size).to eq(1)
          expect(files).to include(File.expand_path("src/main.trb"))
        end
      end
    end

    it "returns empty array if src directory does not exist" do
      Dir.mktmpdir do |tmpdir|
        Dir.chdir(tmpdir) do
          config = TRuby::Config.new
          files = config.find_source_files

          expect(files).to eq([])
        end
      end
    end
  end

  describe "AUTO_EXCLUDE constant" do
    it "contains .git" do
      expect(TRuby::Config::AUTO_EXCLUDE).to include(".git")
    end

    it "is frozen to prevent modifications" do
      expect(TRuby::Config::AUTO_EXCLUDE).to be_frozen
    end
  end

  describe "environment variable expansion" do
    it "expands \${VAR} syntax in string values" do
      yaml = <<~YAML
        output:
          ruby_dir: \${TRC_OUTPUT_DIR}
      YAML

      ENV["TRC_OUTPUT_DIR"] = "custom_build"
      begin
        create_config(yaml) do |config|
          expect(config.ruby_dir).to eq("custom_build")
        end
      ensure
        ENV.delete("TRC_OUTPUT_DIR")
      end
    end

    it "expands \${VAR:-default} syntax with default value" do
      yaml = <<~YAML
        output:
          ruby_dir: \${TRC_OUTPUT_DIR:-fallback}
      YAML

      ENV.delete("TRC_OUTPUT_DIR")
      create_config(yaml) do |config|
        expect(config.ruby_dir).to eq("fallback")
      end
    end

    it "uses env value when both env and default are available" do
      yaml = <<~YAML
        output:
          ruby_dir: \${TRC_OUTPUT_DIR:-fallback}
      YAML

      ENV["TRC_OUTPUT_DIR"] = "from_env"
      begin
        create_config(yaml) do |config|
          expect(config.ruby_dir).to eq("from_env")
        end
      ensure
        ENV.delete("TRC_OUTPUT_DIR")
      end
    end

    it "expands env vars in compiler.strictness" do
      yaml = <<~YAML
        compiler:
          strictness: \${TRC_STRICTNESS:-standard}
      YAML

      ENV["TRC_STRICTNESS"] = "strict"
      begin
        create_config(yaml) do |config|
          expect(config.strictness).to eq("strict")
        end
      ensure
        ENV.delete("TRC_STRICTNESS")
      end
    end

    it "expands env vars in nested values" do
      yaml = <<~YAML
        source:
          include:
            - \${TRC_SRC_DIR:-src}
      YAML

      ENV["TRC_SRC_DIR"] = "lib"
      begin
        create_config(yaml) do |config|
          expect(config.source_include).to eq(["lib"])
        end
      ensure
        ENV.delete("TRC_SRC_DIR")
      end
    end

    it "leaves value unchanged when env var is not set and no default" do
      yaml = <<~YAML
        output:
          ruby_dir: \${TRC_NONEXISTENT_VAR}
      YAML

      ENV.delete("TRC_NONEXISTENT_VAR")
      create_config(yaml) do |config|
        # Returns empty string when env var not set
        expect(config.ruby_dir).to eq("")
      end
    end
  end
end
`,
  "spec/t_ruby/constraint_checker_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ConstraintChecker do
  let(:checker) { TRuby::ConstraintChecker.new }

  describe "#parse_constraint" do
    context "with bounds constraint" do
      it "parses T <: BaseType syntax" do
        result = checker.parse_constraint("PositiveInt <: Integer")
        expect(result[:name]).to eq("PositiveInt")
        expect(result[:base_type]).to eq("Integer")
        expect(result[:constraints].first).to be_a(TRuby::BoundsConstraint)
      end
    end

    context "with numeric range constraint" do
      it "parses >= comparison" do
        result = checker.parse_constraint("PositiveInt = Integer where >= 1")
        expect(result[:name]).to eq("PositiveInt")
        expect(result[:base_type]).to eq("Integer")
        expect(result[:constraints].first).to be_a(TRuby::NumericRangeConstraint)
      end

      it "parses > comparison" do
        result = checker.parse_constraint("PositiveInt = Integer where > 0")
        expect(result).not_to be_nil
        expect(result[:constraints].first.min).to eq(1)
      end

      it "parses < comparison" do
        result = checker.parse_constraint("NegativeInt = Integer where < 0")
        expect(result).not_to be_nil
        expect(result[:constraints].first.max).to eq(-1)
      end

      it "parses <= comparison" do
        result = checker.parse_constraint("NonPositive = Integer where <= 0")
        expect(result).not_to be_nil
        expect(result[:constraints].first.max).to eq(0)
      end

      it "parses range syntax" do
        result = checker.parse_constraint("Percent = Integer where 0..100")
        expect(result).not_to be_nil
        constraint = result[:constraints].first
        expect(constraint.min).to eq(0)
        expect(constraint.max).to eq(100)
      end
    end

    context "with pattern constraint" do
      it "parses regex pattern" do
        result = checker.parse_constraint("Email = String where /^[a-z]+@[a-z]+\\\\.[a-z]+$/")
        expect(result[:name]).to eq("Email")
        expect(result[:base_type]).to eq("String")
        expect(result[:constraints].first).to be_a(TRuby::PatternConstraint)
      end
    end

    context "with length constraint" do
      it "parses length == N" do
        result = checker.parse_constraint("ZipCode = String where length == 5")
        expect(result).not_to be_nil
        expect(result[:constraints].first).to be_a(TRuby::LengthConstraint)
        expect(result[:constraints].first.exact_length).to eq(5)
      end

      it "parses length >= N" do
        result = checker.parse_constraint("NonEmpty = String where length >= 1")
        expect(result).not_to be_nil
        expect(result[:constraints].first.min_length).to eq(1)
      end
    end

    context "with predicate constraint" do
      it "parses predicate method" do
        result = checker.parse_constraint("NonEmpty = Array where empty?")
        expect(result).not_to be_nil
        expect(result[:constraints].first).to be_a(TRuby::PredicateConstraint)
      end
    end
  end

  describe "#validate" do
    before do
      checker.register("PositiveInt", base_type: "Integer", constraints: [
                         TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1),
                       ])

      checker.register("Percentage", base_type: "Integer", constraints: [
                         TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 0, max: 100),
                       ])

      checker.register("ShortString", base_type: "String", constraints: [
                         TRuby::LengthConstraint.new(base_type: "String", max_length: 10),
                       ])
    end

    it "validates positive integer" do
      expect(checker.validate("PositiveInt", 5)).to be true
      expect(checker.validate("PositiveInt", 1)).to be true
    end

    it "rejects zero for positive integer" do
      expect(checker.validate("PositiveInt", 0)).to be false
    end

    it "rejects negative for positive integer" do
      expect(checker.validate("PositiveInt", -1)).to be false
    end

    it "validates percentage in range" do
      expect(checker.validate("Percentage", 0)).to be true
      expect(checker.validate("Percentage", 50)).to be true
      expect(checker.validate("Percentage", 100)).to be true
    end

    it "rejects percentage out of range" do
      expect(checker.validate("Percentage", -1)).to be false
      expect(checker.validate("Percentage", 101)).to be false
    end

    it "validates short string" do
      expect(checker.validate("ShortString", "hello")).to be true
      expect(checker.validate("ShortString", "12345678")).to be true
    end

    it "rejects long string" do
      expect(checker.validate("ShortString", "this is way too long")).to be false
    end

    it "provides error messages" do
      checker.validate("PositiveInt", -5)
      expect(checker.errors).not_to be_empty
    end
  end

  describe "#generate_validation_code" do
    before do
      checker.register("PositiveInt", base_type: "Integer", constraints: [
                         TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1),
                       ])
    end

    it "generates validation code" do
      code = checker.generate_validation_code("PositiveInt", "value")
      expect(code).to include("value.is_a?(Integer)")
      expect(code).to include("value >= 1")
    end
  end
end

RSpec.describe TRuby::NumericRangeConstraint do
  describe "#satisfied?" do
    it "checks minimum" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 0)
      expect(constraint.satisfied?(0)).to be true
      expect(constraint.satisfied?(1)).to be true
      expect(constraint.satisfied?(-1)).to be false
    end

    it "checks maximum" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", max: 100)
      expect(constraint.satisfied?(100)).to be true
      expect(constraint.satisfied?(99)).to be true
      expect(constraint.satisfied?(101)).to be false
    end

    it "checks range" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1, max: 10)
      expect(constraint.satisfied?(1)).to be true
      expect(constraint.satisfied?(5)).to be true
      expect(constraint.satisfied?(10)).to be true
      expect(constraint.satisfied?(0)).to be false
      expect(constraint.satisfied?(11)).to be false
    end
  end
end

RSpec.describe TRuby::PatternConstraint do
  describe "#satisfied?" do
    it "matches pattern" do
      constraint = TRuby::PatternConstraint.new(base_type: "String", pattern: /^\\d+$/)
      expect(constraint.satisfied?("123")).to be true
      expect(constraint.satisfied?("abc")).to be false
    end

    it "accepts string pattern" do
      constraint = TRuby::PatternConstraint.new(base_type: "String", pattern: "^hello")
      expect(constraint.satisfied?("hello world")).to be true
      expect(constraint.satisfied?("world hello")).to be false
    end
  end
end

RSpec.describe TRuby::LengthConstraint do
  describe "#satisfied?" do
    it "checks exact length" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", exact_length: 5)
      expect(constraint.satisfied?("hello")).to be true
      expect(constraint.satisfied?("hi")).to be false
    end

    it "checks min length" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", min_length: 3)
      expect(constraint.satisfied?("abc")).to be true
      expect(constraint.satisfied?("ab")).to be false
    end

    it "checks max length" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", max_length: 5)
      expect(constraint.satisfied?("abc")).to be true
      expect(constraint.satisfied?("abcdef")).to be false
    end

    it "works with arrays" do
      constraint = TRuby::LengthConstraint.new(base_type: "Array", min_length: 1)
      expect(constraint.satisfied?([1])).to be true
      expect(constraint.satisfied?([])).to be false
    end
  end
end

RSpec.describe TRuby::PredicateConstraint do
  describe "#satisfied?" do
    it "checks predicate method" do
      constraint = TRuby::PredicateConstraint.new(base_type: "Integer", predicate: :positive?)
      expect(constraint.satisfied?(5)).to be true
      expect(constraint.satisfied?(-5)).to be false
    end

    it "checks empty? predicate" do
      constraint = TRuby::PredicateConstraint.new(base_type: "String", predicate: :empty?)
      expect(constraint.satisfied?("")).to be true
      expect(constraint.satisfied?("hello")).to be false
    end
  end
end

RSpec.describe TRuby::Constraint do
  describe "#to_s" do
    it "formats constraint as string" do
      constraint = TRuby::Constraint.new(type: :custom, condition: "value > 0")
      expect(constraint.to_s).to eq("custom where value > 0")
    end
  end
end

RSpec.describe TRuby::BoundsConstraint do
  describe "#satisfied?" do
    it "checks type hierarchy" do
      constraint = TRuby::BoundsConstraint.new(subtype: "PositiveInt", supertype: "Integer")
      hierarchy = double("TypeHierarchy")
      allow(hierarchy).to receive(:subtype_of?).with("PositiveInt", "Integer").and_return(true)

      expect(constraint.satisfied?(hierarchy)).to be true
    end

    it "returns false when not subtype" do
      constraint = TRuby::BoundsConstraint.new(subtype: "String", supertype: "Integer")
      hierarchy = double("TypeHierarchy")
      allow(hierarchy).to receive(:subtype_of?).with("String", "Integer").and_return(false)

      expect(constraint.satisfied?(hierarchy)).to be false
    end
  end

  describe "#to_s" do
    it "formats as subtype relationship" do
      constraint = TRuby::BoundsConstraint.new(subtype: "A", supertype: "B")
      expect(constraint.to_s).to include("A <: B")
    end
  end
end

RSpec.describe TRuby::EqualityConstraint do
  describe "#satisfied?" do
    it "returns true when value matches left type" do
      constraint = TRuby::EqualityConstraint.new(left_type: "String", right_type: "Integer")
      expect(constraint.satisfied?("String")).to be true
    end

    it "returns true when value matches right type" do
      constraint = TRuby::EqualityConstraint.new(left_type: "String", right_type: "Integer")
      expect(constraint.satisfied?("Integer")).to be true
    end

    it "returns false when no match" do
      constraint = TRuby::EqualityConstraint.new(left_type: "String", right_type: "Integer")
      expect(constraint.satisfied?("Float")).to be false
    end
  end
end

RSpec.describe TRuby::NumericRangeConstraint, "additional tests" do
  describe "#validation_code" do
    it "generates min condition" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 0)
      expect(constraint.validation_code("x")).to eq("x >= 0")
    end

    it "generates max condition" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", max: 100)
      expect(constraint.validation_code("x")).to eq("x <= 100")
    end

    it "generates both conditions" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 0, max: 100)
      code = constraint.validation_code("x")
      expect(code).to include("x >= 0")
      expect(code).to include("x <= 100")
    end

    it "returns empty string when no constraints" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer")
      expect(constraint.validation_code("x")).to eq("")
    end
  end

  describe "#satisfied?" do
    it "rejects non-numeric values" do
      constraint = TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 0)
      expect(constraint.satisfied?("string")).to be false
    end
  end
end

RSpec.describe TRuby::PatternConstraint, "additional tests" do
  describe "#validation_code" do
    it "generates regex match code" do
      constraint = TRuby::PatternConstraint.new(base_type: "String", pattern: /^\\d+$/)
      code = constraint.validation_code("s")
      expect(code).to include(".match?(s)")
    end
  end

  describe "#satisfied?" do
    it "rejects non-string values" do
      constraint = TRuby::PatternConstraint.new(base_type: "String", pattern: /test/)
      expect(constraint.satisfied?(123)).to be false
    end
  end
end

RSpec.describe TRuby::PredicateConstraint, "additional tests" do
  describe "#satisfied?" do
    it "handles Proc predicate" do
      constraint = TRuby::PredicateConstraint.new(
        base_type: "Integer",
        predicate: ->(x) { x > 0 }
      )
      expect(constraint.satisfied?(5)).to be true
      expect(constraint.satisfied?(-1)).to be false
    end

    it "handles missing method" do
      constraint = TRuby::PredicateConstraint.new(
        base_type: "Integer",
        predicate: :nonexistent_method?
      )
      expect(constraint.satisfied?(5)).to be false
    end

    it "returns false for unknown predicate type" do
      constraint = TRuby::PredicateConstraint.new(
        base_type: "Integer",
        predicate: "string_predicate"
      )
      expect(constraint.satisfied?(5)).to be false
    end
  end

  describe "#validation_code" do
    it "generates method call for symbol" do
      constraint = TRuby::PredicateConstraint.new(base_type: "Integer", predicate: :positive?)
      expect(constraint.validation_code("n")).to eq("n.positive?")
    end

    it "returns true for Proc predicates" do
      constraint = TRuby::PredicateConstraint.new(
        base_type: "Integer",
        predicate: ->(x) { x > 0 }
      )
      expect(constraint.validation_code("n")).to eq("true")
    end
  end
end

RSpec.describe TRuby::LengthConstraint, "additional tests" do
  describe "#validation_code" do
    it "generates exact length code" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", exact_length: 5)
      expect(constraint.validation_code("s")).to eq("s.length == 5")
    end

    it "generates min and max length code" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", min_length: 1, max_length: 10)
      code = constraint.validation_code("s")
      expect(code).to include("s.length >= 1")
      expect(code).to include("s.length <= 10")
    end
  end

  describe "#satisfied?" do
    it "rejects objects without length method" do
      constraint = TRuby::LengthConstraint.new(base_type: "String", min_length: 1)
      expect(constraint.satisfied?(123)).to be false
    end
  end
end

RSpec.describe TRuby::ConstraintChecker, "additional tests" do
  let(:checker) { TRuby::ConstraintChecker.new }

  describe "#validate" do
    it "returns false for unknown type" do
      expect(checker.validate("UnknownType", 5)).to be false
      expect(checker.errors.first).to include("Unknown constrained type")
    end

    it "rejects value with wrong base type" do
      checker.register("MyInt", base_type: "Integer", constraints: [])
      expect(checker.validate("MyInt", "string")).to be false
      expect(checker.errors.first).to include("does not match base type")
    end
  end

  describe "#generate_validation_code" do
    it "returns nil for unknown type" do
      expect(checker.generate_validation_code("UnknownType", "x")).to be_nil
    end

    it "generates code for Float base type" do
      checker.register("MyFloat", base_type: "Float", constraints: [])
      code = checker.generate_validation_code("MyFloat", "x")
      expect(code).to include("x.is_a?(Float)")
    end

    it "generates code for Numeric base type" do
      checker.register("MyNum", base_type: "Numeric", constraints: [])
      code = checker.generate_validation_code("MyNum", "x")
      expect(code).to include("x.is_a?(Numeric)")
    end

    it "generates code for Array base type" do
      checker.register("MyArray", base_type: "Array", constraints: [])
      code = checker.generate_validation_code("MyArray", "x")
      expect(code).to include("x.is_a?(Array)")
    end
  end

  describe "#parse_constraint" do
    it "returns nil for unparseable definition" do
      expect(checker.parse_constraint("invalid syntax")).to be_nil
    end

    it "parses with <: syntax and where clause" do
      result = checker.parse_constraint("PositiveInt <: Integer where >= 1")
      expect(result[:name]).to eq("PositiveInt")
      expect(result[:constraints]).not_to be_empty
    end

    it "parses length < N constraint" do
      result = checker.parse_constraint("ShortStr = String where length < 10")
      expect(result[:constraints].first.max_length).to eq(9)
    end

    it "parses length > N constraint" do
      result = checker.parse_constraint("LongStr = String where length > 5")
      expect(result[:constraints].first.min_length).to eq(6)
    end

    it "parses float comparison" do
      result = checker.parse_constraint("SmallFloat = Float where < 1.5")
      expect(result[:constraints].first).to be_a(TRuby::NumericRangeConstraint)
    end
  end

  describe "#validate with various base types" do
    it "validates Hash base type" do
      checker.register("MyHash", base_type: "Hash", constraints: [])
      expect(checker.validate("MyHash", { a: 1 })).to be true
      expect(checker.validate("MyHash", [1, 2])).to be false
    end

    it "validates Boolean base type" do
      checker.register("MyBool", base_type: "Boolean", constraints: [])
      expect(checker.validate("MyBool", true)).to be true
      expect(checker.validate("MyBool", false)).to be true
      expect(checker.validate("MyBool", "true")).to be false
    end

    it "validates Symbol base type" do
      checker.register("MySym", base_type: "Symbol", constraints: [])
      expect(checker.validate("MySym", :hello)).to be true
      expect(checker.validate("MySym", "hello")).to be false
    end

    it "passes unknown base types through" do
      checker.register("Custom", base_type: "UnknownType", constraints: [])
      expect(checker.validate("Custom", "anything")).to be true
    end
  end
end

RSpec.describe TRuby::ConstrainedTypeRegistry do
  let(:registry) { TRuby::ConstrainedTypeRegistry.new }

  describe "#register" do
    it "registers a constrained type" do
      registry.register("PositiveInt", base_type: "Integer", constraints: [])
      expect(registry.registered?("PositiveInt")).to be true
    end
  end

  describe "#get" do
    it "returns type info" do
      registry.register("MyType", base_type: "String", constraints: [])
      info = registry.get("MyType")
      expect(info[:base_type]).to eq("String")
    end

    it "returns nil for unregistered type" do
      expect(registry.get("Unknown")).to be_nil
    end
  end

  describe "#errors" do
    it "returns validation errors" do
      registry.register("PositiveInt", base_type: "Integer", constraints: [
                          TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1),
                        ])
      registry.validate("PositiveInt", 0)
      expect(registry.errors).not_to be_empty
    end
  end

  describe "#register_from_source" do
    it "parses and registers from source" do
      result = registry.register_from_source("PositiveInt = Integer where > 0")
      expect(result).to be true
      expect(registry.registered?("PositiveInt")).to be true
    end
  end

  describe "#validate" do
    before do
      registry.register("PositiveInt", base_type: "Integer", constraints: [
                          TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1),
                        ])
    end

    it "validates against registered type" do
      expect(registry.validate("PositiveInt", 5)).to be true
      expect(registry.validate("PositiveInt", 0)).to be false
    end
  end

  describe "#validation_code" do
    before do
      registry.register("PositiveInt", base_type: "Integer", constraints: [
                          TRuby::NumericRangeConstraint.new(base_type: "Integer", min: 1),
                        ])
    end

    it "generates validation code" do
      code = registry.validation_code("PositiveInt", "n")
      expect(code).to include("n.is_a?(Integer)")
      expect(code).to include("n >= 1")
    end
  end

  describe "#list" do
    it "lists all registered types" do
      registry.register("TypeA", base_type: "Integer", constraints: [])
      registry.register("TypeB", base_type: "String", constraints: [])
      expect(registry.list).to contain_exactly("TypeA", "TypeB")
    end
  end

  describe "#clear" do
    it "clears all registrations" do
      registry.register("TypeA", base_type: "Integer", constraints: [])
      registry.clear
      expect(registry.list).to be_empty
    end
  end
end
`,
  "spec/t_ruby/declaration_generator_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "tmpdir"
require "fileutils"

RSpec.describe TRuby::DeclarationGenerator do
  let(:generator) { described_class.new }

  describe "#generate" do
    it "generates declaration for type aliases" do
      source = "type UserId = String"
      result = generator.generate(source)

      expect(result).to include("type UserId = String")
    end

    it "generates declaration for multiple type aliases" do
      source = <<~TRB
        type UserId = String
        type Age = Integer
      TRB

      result = generator.generate(source)

      expect(result).to include("type UserId = String")
      expect(result).to include("type Age = Integer")
    end

    it "generates declaration for interfaces" do
      source = <<~TRB
        interface Printable
          to_string: String
          print: void
        end
      TRB

      result = generator.generate(source)

      expect(result).to include("interface Printable")
      expect(result).to include("to_string: String")
      expect(result).to include("print: void")
      expect(result).to include("end")
    end

    it "generates declaration for functions with typed parameters" do
      source = "def greet(name: String, age: Integer): String\\nend"
      result = generator.generate(source)

      expect(result).to include("def greet(name: String, age: Integer): String")
    end

    it "generates declaration for functions without return type" do
      source = "def process(data: String)\\nend"
      result = generator.generate(source)

      expect(result).to include("def process(data: String)")
    end

    it "generates declaration for functions with untyped parameters" do
      source = "def simple(a, b)\\nend"
      result = generator.generate(source)

      expect(result).to include("def simple(a, b)")
    end

    it "includes header comments" do
      source = "type Test = String"
      result = generator.generate(source)

      expect(result).to include("# Auto-generated type declaration file")
      expect(result).to include("# Do not edit manually")
    end

    it "handles complex source with all elements" do
      source = <<~TRB
        type UserId = String

        interface User
          id: UserId
          name: String
        end

        def get_user(id: UserId): User
        end

        def save_user(user: User): Boolean
        end
      TRB

      result = generator.generate(source)

      expect(result).to include("type UserId = String")
      expect(result).to include("interface User")
      expect(result).to include("def get_user(id: UserId): User")
      expect(result).to include("def save_user(user: User): Boolean")
    end
  end

  describe "#generate_file" do
    it "generates a .d.trb file from source file" do
      Dir.mktmpdir do |dir|
        source_path = File.join(dir, "test.trb")
        File.write(source_path, "type UserId = String")

        output_path = generator.generate_file(source_path, dir)

        expect(output_path).to eq(File.join(dir, "test.d.trb"))
        expect(File.exist?(output_path)).to be true
        expect(File.read(output_path)).to include("type UserId = String")
      end
    end

    it "raises error for non-existent file" do
      expect do
        generator.generate_file("/nonexistent.trb")
      end.to raise_error(ArgumentError, /File not found/)
    end

    it "raises error for non-.trb file" do
      Dir.mktmpdir do |dir|
        file_path = File.join(dir, "test.rb")
        File.write(file_path, "puts 'hello'")

        expect do
          generator.generate_file(file_path)
        end.to raise_error(ArgumentError, /Expected .trb file/)
      end
    end

    it "creates output directory if needed" do
      Dir.mktmpdir do |dir|
        source_path = File.join(dir, "test.trb")
        output_dir = File.join(dir, "types", "generated")
        File.write(source_path, "type Test = String")

        output_path = generator.generate_file(source_path, output_dir)

        expect(Dir.exist?(output_dir)).to be true
        expect(File.exist?(output_path)).to be true
      end
    end
  end
end

RSpec.describe TRuby::DeclarationParser do
  let(:parser) { described_class.new }

  describe "#parse" do
    it "parses type aliases" do
      content = "type UserId = String"
      parser.parse(content)

      expect(parser.type_aliases).to eq({ "UserId" => "String" })
    end

    it "parses multiple type aliases" do
      content = <<~TRB
        type UserId = String
        type Age = Integer
        type Name = String
      TRB

      parser.parse(content)

      expect(parser.type_aliases.keys).to contain_exactly("UserId", "Age", "Name")
    end

    it "parses interfaces" do
      content = <<~TRB
        interface Printable
          to_string: String
        end
      TRB

      parser.parse(content)

      expect(parser.interfaces).to have_key("Printable")
      expect(parser.interfaces["Printable"][:members].first[:name]).to eq("to_string")
    end

    it "parses functions" do
      content = "def greet(name: String): String"
      parser.parse(content)

      expect(parser.functions).to have_key("greet")
      expect(parser.functions["greet"][:return_type]).to eq("String")
    end
  end

  describe "#parse_file" do
    it "parses a .d.trb file" do
      Dir.mktmpdir do |dir|
        decl_path = File.join(dir, "types.d.trb")
        File.write(decl_path, "type UserId = String")

        parser.parse_file(decl_path)

        expect(parser.type_aliases).to eq({ "UserId" => "String" })
      end
    end

    it "raises error for non-existent file" do
      expect do
        parser.parse_file("/nonexistent.d.trb")
      end.to raise_error(ArgumentError, /Declaration file not found/)
    end

    it "raises error for wrong extension" do
      Dir.mktmpdir do |dir|
        file_path = File.join(dir, "types.trb")
        File.write(file_path, "type Test = String")

        expect do
          parser.parse_file(file_path)
        end.to raise_error(ArgumentError, /Expected .d.trb file/)
      end
    end
  end

  describe "#load_directory" do
    it "loads all declaration files from directory" do
      Dir.mktmpdir do |dir|
        File.write(File.join(dir, "types.d.trb"), "type UserId = String")
        File.write(File.join(dir, "models.d.trb"), "type Age = Integer")

        parser.load_directory(dir)

        expect(parser.type_aliases.keys).to contain_exactly("UserId", "Age")
      end
    end

    it "loads recursively when specified" do
      Dir.mktmpdir do |dir|
        sub_dir = File.join(dir, "sub")
        FileUtils.mkdir_p(sub_dir)

        File.write(File.join(dir, "types.d.trb"), "type UserId = String")
        File.write(File.join(sub_dir, "models.d.trb"), "type Age = Integer")

        parser.load_directory(dir, recursive: true)

        expect(parser.type_aliases.keys).to contain_exactly("UserId", "Age")
      end
    end

    it "raises error for non-existent directory" do
      expect do
        parser.load_directory("/nonexistent")
      end.to raise_error(ArgumentError, /Directory not found/)
    end
  end

  describe "#type_defined?" do
    it "returns true for defined type alias" do
      parser.parse("type UserId = String")
      expect(parser.type_defined?("UserId")).to be true
    end

    it "returns true for defined interface" do
      parser.parse("interface Printable\\nend")
      expect(parser.type_defined?("Printable")).to be true
    end

    it "returns false for undefined type" do
      expect(parser.type_defined?("Unknown")).to be false
    end
  end

  describe "#merge" do
    it "merges declarations from another parser" do
      parser1 = described_class.new
      parser2 = described_class.new

      parser1.parse("type UserId = String")
      parser2.parse("type Age = Integer")

      parser1.merge(parser2)

      expect(parser1.type_aliases.keys).to contain_exactly("UserId", "Age")
    end
  end

  describe "#to_h" do
    it "returns all declarations as a hash" do
      content = <<~TRB
        type UserId = String
        interface User
          id: UserId
        end
        def get_user(id: UserId): User
      TRB

      parser.parse(content)
      result = parser.to_h

      expect(result).to have_key(:type_aliases)
      expect(result).to have_key(:interfaces)
      expect(result).to have_key(:functions)
    end
  end
end

RSpec.describe TRuby::DeclarationLoader do
  let(:loader) { described_class.new }

  describe "#add_search_path" do
    it "adds a search path" do
      loader.add_search_path("/path/to/types")
      expect(loader.search_paths).to include("/path/to/types")
    end

    it "does not add duplicate paths" do
      loader.add_search_path("/path/to/types")
      loader.add_search_path("/path/to/types")

      expect(loader.search_paths.count("/path/to/types")).to eq(1)
    end
  end

  describe "#load" do
    it "loads declaration by name" do
      Dir.mktmpdir do |dir|
        File.write(File.join(dir, "user.d.trb"), "type UserId = String")
        loader.add_search_path(dir)

        result = loader.load("user")

        expect(result).to be true
        expect(loader.type_aliases).to eq({ "UserId" => "String" })
      end
    end

    it "returns false when file not found" do
      loader.add_search_path("/nonexistent")
      result = loader.load("unknown")

      expect(result).to be false
    end

    it "does not load same file twice" do
      Dir.mktmpdir do |dir|
        File.write(File.join(dir, "user.d.trb"), "type UserId = String")
        loader.add_search_path(dir)

        loader.load("user")
        loader.load("user")

        expect(loader.loaded_files.length).to eq(1)
      end
    end
  end

  describe "#load_all" do
    it "loads all declaration files from search paths" do
      Dir.mktmpdir do |dir|
        File.write(File.join(dir, "types.d.trb"), "type UserId = String")
        File.write(File.join(dir, "models.d.trb"), "type Age = Integer")
        loader.add_search_path(dir)

        loader.load_all

        expect(loader.type_aliases.keys).to contain_exactly("UserId", "Age")
      end
    end
  end

  describe "#type_defined?" do
    it "checks if type is defined in loaded declarations" do
      Dir.mktmpdir do |dir|
        File.write(File.join(dir, "types.d.trb"), "type UserId = String")
        loader.add_search_path(dir)
        loader.load_all

        expect(loader.type_defined?("UserId")).to be true
        expect(loader.type_defined?("Unknown")).to be false
      end
    end
  end
end
`,
  "spec/t_ruby/diagnostic_formatter_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::DiagnosticFormatter do
  let(:formatter) { described_class.new(use_colors: false) }
  let(:colored_formatter) { described_class.new(use_colors: true) }

  let(:simple_diagnostic) do
    TRuby::Diagnostic.new(
      code: "TR2001",
      message: "Type mismatch",
      file: "test.trb",
      line: 7,
      column: 5
    )
  end

  let(:full_diagnostic) do
    TRuby::Diagnostic.new(
      code: "TR2001",
      message: "Type mismatch in argument 'name'",
      file: "src/hello.trb",
      line: 7,
      column: 7,
      end_column: 10,
      severity: :error,
      expected: "String",
      actual: "Integer",
      suggestion: "Use .to_s to convert",
      source_line: "greet(123)"
    )
  end

  let(:warning_diagnostic) do
    TRuby::Diagnostic.new(
      code: "TR2010",
      message: "Unused variable",
      file: "test.trb",
      line: 5,
      column: 1,
      severity: :warning
    )
  end

  describe "#format" do
    context "with simple diagnostic" do
      it "formats header with file:line:col - error CODE: message" do
        result = formatter.format(simple_diagnostic)

        expect(result).to include("test.trb:7:5")
        expect(result).to include("error")
        expect(result).to include("TR2001")
        expect(result).to include("Type mismatch")
      end
    end

    context "with full diagnostic" do
      it "includes source code snippet" do
        result = formatter.format(full_diagnostic)

        expect(result).to include("7 |")
        expect(result).to include("greet(123)")
      end

      it "includes error marker (~~~)" do
        result = formatter.format(full_diagnostic)

        # Marker should be under the error position (column 7, width 3)
        expect(result).to include("~~~")
      end

      it "includes expected/actual context" do
        result = formatter.format(full_diagnostic)

        expect(result).to include("Expected:")
        expect(result).to include("String")
        expect(result).to include("Actual:")
        expect(result).to include("Integer")
      end

      it "includes suggestion" do
        result = formatter.format(full_diagnostic)

        expect(result).to include("Suggestion:")
        expect(result).to include("Use .to_s to convert")
      end
    end

    context "with warning severity" do
      it "shows 'warning' instead of 'error'" do
        result = formatter.format(warning_diagnostic)

        expect(result).to include("warning")
        expect(result).not_to include("error")
      end
    end

    context "without source line" do
      it "only shows header without code snippet" do
        diagnostic = TRuby::Diagnostic.new(
          code: "TR2001",
          message: "Type mismatch",
          file: "test.trb",
          line: 7,
          column: 5
        )

        result = formatter.format(diagnostic)

        expect(result).to include("test.trb:7:5")
        expect(result).not_to include(" | ")
      end
    end

    context "without file info" do
      it "shows <unknown> for file" do
        diagnostic = TRuby::Diagnostic.new(
          code: "TR2001",
          message: "Type mismatch"
        )

        result = formatter.format(diagnostic)

        expect(result).to include("<unknown>")
      end
    end
  end

  describe "#format_all" do
    it "formats multiple diagnostics with blank lines between" do
      diagnostics = [simple_diagnostic, full_diagnostic]

      result = formatter.format_all(diagnostics)

      expect(result).to include("test.trb:7:5")
      expect(result).to include("src/hello.trb:7:7")
    end

    it "includes summary line" do
      diagnostics = [simple_diagnostic, full_diagnostic]

      result = formatter.format_all(diagnostics)

      expect(result).to include("Found 2 errors.")
    end

    it "shows singular 'error' for one error" do
      diagnostics = [simple_diagnostic]

      result = formatter.format_all(diagnostics)

      expect(result).to include("Found 1 error.")
    end

    it "shows warnings and errors separately in summary" do
      diagnostics = [simple_diagnostic, warning_diagnostic]

      result = formatter.format_all(diagnostics)

      expect(result).to include("1 error")
      expect(result).to include("1 warning")
    end

    it "returns empty string for empty array" do
      result = formatter.format_all([])

      expect(result).to eq("")
    end
  end

  describe "color support" do
    it "adds ANSI color codes when use_colors is true" do
      result = colored_formatter.format(simple_diagnostic)

      # Should contain ANSI escape codes
      expect(result).to include("\\e[")
    end

    it "does not add color codes when use_colors is false" do
      result = formatter.format(simple_diagnostic)

      expect(result).not_to include("\\e[")
    end
  end

  describe "marker width calculation" do
    it "uses end_column - column for width when available" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR2001",
        message: "Error",
        file: "test.trb",
        line: 1,
        column: 5,
        end_column: 10,
        source_line: "hello world"
      )

      result = formatter.format(diagnostic)

      # Width should be 5 (10 - 5)
      expect(result).to include("~~~~~")
    end

    it "guesses width from identifier in source when end_column not available" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR2001",
        message: "Error",
        file: "test.trb",
        line: 1,
        column: 1,
        source_line: "hello world"
      )

      result = formatter.format(diagnostic)

      # Should guess width from "hello" (5 chars)
      expect(result).to include("~~~~~")
    end
  end
end
`,
  "spec/t_ruby/diagnostic_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::Diagnostic do
  describe "#initialize" do
    it "creates a diagnostic with required attributes" do
      diagnostic = described_class.new(
        code: "TR2001",
        message: "Type mismatch"
      )

      expect(diagnostic.code).to eq("TR2001")
      expect(diagnostic.message).to eq("Type mismatch")
      expect(diagnostic.severity).to eq(:error)
    end

    it "creates a diagnostic with all attributes" do
      diagnostic = described_class.new(
        code: "TR2001",
        message: "Type mismatch",
        file: "test.trb",
        line: 7,
        column: 5,
        end_column: 8,
        severity: :error,
        expected: "String",
        actual: "Integer",
        suggestion: "Use .to_s",
        source_line: "greet(123)"
      )

      expect(diagnostic.code).to eq("TR2001")
      expect(diagnostic.message).to eq("Type mismatch")
      expect(diagnostic.file).to eq("test.trb")
      expect(diagnostic.line).to eq(7)
      expect(diagnostic.column).to eq(5)
      expect(diagnostic.end_column).to eq(8)
      expect(diagnostic.severity).to eq(:error)
      expect(diagnostic.expected).to eq("String")
      expect(diagnostic.actual).to eq("Integer")
      expect(diagnostic.suggestion).to eq("Use .to_s")
      expect(diagnostic.source_line).to eq("greet(123)")
    end

    it "defaults column to 1 when not specified" do
      diagnostic = described_class.new(code: "TR2001", message: "error", line: 5)
      expect(diagnostic.column).to eq(1)
    end

    it "defaults end_column to column + 1 when not specified" do
      diagnostic = described_class.new(code: "TR2001", message: "error", line: 5, column: 3)
      expect(diagnostic.end_column).to eq(4)
    end
  end

  describe ".from_type_check_error" do
    it "converts TypeCheckError to Diagnostic" do
      error = TRuby::TypeCheckError.new(
        message: "Type mismatch",
        location: "test.trb:7:5",
        expected: "String",
        actual: "Integer",
        suggestion: "Use .to_s"
      )
      source = "line1\\nline2\\nline3\\nline4\\nline5\\nline6\\ngreet(123)\\nline8"

      diagnostic = described_class.from_type_check_error(error, file: "test.trb", source: source)

      expect(diagnostic.code).to eq("TR2001")
      expect(diagnostic.message).to eq("Type mismatch")
      expect(diagnostic.file).to eq("test.trb")
      expect(diagnostic.line).to eq(7)
      expect(diagnostic.column).to eq(5)
      expect(diagnostic.expected).to eq("String")
      expect(diagnostic.actual).to eq("Integer")
      expect(diagnostic.suggestion).to eq("Use .to_s")
      expect(diagnostic.source_line).to eq("greet(123)")
    end

    it "handles location with only line number" do
      error = TRuby::TypeCheckError.new(
        message: "Type mismatch",
        location: "line 7"
      )

      diagnostic = described_class.from_type_check_error(error, file: "test.trb")

      expect(diagnostic.line).to eq(7)
      expect(diagnostic.column).to eq(1)
    end

    it "handles location with file:line format" do
      error = TRuby::TypeCheckError.new(
        message: "Type mismatch",
        location: "test.trb:10"
      )

      diagnostic = described_class.from_type_check_error(error, file: "test.trb")

      expect(diagnostic.line).to eq(10)
      expect(diagnostic.column).to eq(1)
    end

    it "handles nil location" do
      error = TRuby::TypeCheckError.new(message: "Type mismatch")

      diagnostic = described_class.from_type_check_error(error, file: "test.trb")

      expect(diagnostic.line).to be_nil
      expect(diagnostic.column).to eq(1)
    end
  end

  describe ".from_parse_error" do
    it "converts ParseError to Diagnostic" do
      error = TRuby::ParseError.new(
        "Unexpected token",
        line: 5,
        column: 10,
        source: "def foo(: String)"
      )

      diagnostic = described_class.from_parse_error(error, file: "test.trb")

      expect(diagnostic.code).to eq("TR1001")
      expect(diagnostic.message).to eq("Unexpected token")
      expect(diagnostic.file).to eq("test.trb")
      expect(diagnostic.line).to eq(5)
      expect(diagnostic.column).to eq(10)
    end

    it "extracts source_line from source parameter" do
      source = "line1\\nline2\\nline3\\nline4\\ndef foo(: String)\\nline6"
      error = TRuby::ParseError.new("Unexpected token", line: 5, column: 10)

      diagnostic = described_class.from_parse_error(error, file: "test.trb", source: source)

      expect(diagnostic.source_line).to eq("def foo(: String)")
    end
  end

  describe ".from_scan_error" do
    it "converts ScanError to Diagnostic" do
      error = TRuby::Scanner::ScanError.new("Unterminated string", line: 3, column: 15, position: 50)

      diagnostic = described_class.from_scan_error(error, file: "test.trb")

      expect(diagnostic.code).to eq("TR1001")
      expect(diagnostic.message).to eq("Unterminated string")
      expect(diagnostic.file).to eq("test.trb")
      expect(diagnostic.line).to eq(3)
      expect(diagnostic.column).to eq(15)
    end

    it "strips location info from message (added by ScanError constructor)" do
      # ScanError constructor automatically appends " at line X, column Y" to message
      # So "Unterminated string" becomes "Unterminated string at line 3, column 15"
      error = TRuby::Scanner::ScanError.new(
        "Unterminated string",
        line: 3,
        column: 15,
        position: 50
      )

      diagnostic = described_class.from_scan_error(error, file: "test.trb")

      # from_scan_error should strip the auto-added location suffix
      expect(diagnostic.message).to eq("Unterminated string")
    end
  end

  describe "#error?" do
    it "returns true for error severity" do
      diagnostic = described_class.new(code: "TR2001", message: "error", severity: :error)
      expect(diagnostic.error?).to be true
    end

    it "returns false for warning severity" do
      diagnostic = described_class.new(code: "TR2001", message: "warning", severity: :warning)
      expect(diagnostic.error?).to be false
    end
  end
end
`,
  "spec/t_ruby/doc_generator_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"
require "tempfile"

describe TRuby::DocGenerator do
  let(:config) { instance_double(TRuby::Config) }
  let(:generator) { described_class.new(config) }

  describe "#initialize" do
    it "initializes with default config when none provided" do
      allow(TRuby::Config).to receive(:new).and_return(config)
      gen = described_class.new
      expect(gen.config).to eq(config)
    end

    it "initializes with provided config" do
      expect(generator.config).to eq(config)
    end

    it "initializes docs with empty structures" do
      expect(generator.docs).to eq(
        { types: {}, interfaces: {}, functions: {}, modules: {} }
      )
    end
  end

  describe "#generate" do
    let(:trb_content) do
      <<~TRB
        type UserId = Integer

        interface User
          id: Integer
          name: String
        end

        def greet(name: String): String
          "Hello, \\#{name}"
        end
      TRB
    end

    it "generates documentation files" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_dir = File.join(tmpdir, "docs")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate([input_file], output_dir: output_dir)

        expect(File.exist?(File.join(output_dir, "index.html"))).to be true
        expect(Dir.exist?(File.join(output_dir, "types"))).to be true
        expect(Dir.exist?(File.join(output_dir, "interfaces"))).to be true
        expect(Dir.exist?(File.join(output_dir, "functions"))).to be true
      end
    end

    it "parses type aliases" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_dir = File.join(tmpdir, "docs")
        File.write(input_file, "type MyType = String | Integer")

        allow(generator).to receive(:puts)
        generator.generate([input_file], output_dir: output_dir)

        expect(generator.docs[:types]).to have_key("MyType")
        expect(generator.docs[:types]["MyType"][:definition]).to eq("String | Integer")
      end
    end

    it "parses generic types" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_dir = File.join(tmpdir, "docs")
        File.write(input_file, "type Container<T> = Array<T> | nil")

        allow(generator).to receive(:puts)
        generator.generate([input_file], output_dir: output_dir)

        expect(generator.docs[:types]["Container"][:type_params]).to eq(["T"])
      end
    end

    it "generates search index" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_dir = File.join(tmpdir, "docs")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate([input_file], output_dir: output_dir)

        search_index_path = File.join(output_dir, "search-index.json")
        expect(File.exist?(search_index_path)).to be true

        search_data = JSON.parse(File.read(search_index_path))
        expect(search_data).to be_an(Array)
      end
    end
  end

  describe "#generate_markdown" do
    let(:trb_content) do
      <<~TRB
        type Status = "active" | "inactive"

        interface Product
          id: Integer
          name: String
        end

        def calculate(a: Integer, b: Integer): Integer
          a + b
        end
      TRB
    end

    it "generates markdown file" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "API.md")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_markdown([input_file], output_path: output_path)

        expect(File.exist?(output_path)).to be true
        content = File.read(output_path)
        expect(content).to include("# T-Ruby API Documentation")
      end
    end

    it "includes types section" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "API.md")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_markdown([input_file], output_path: output_path)

        content = File.read(output_path)
        expect(content).to include("## Types")
        expect(content).to include("Status")
      end
    end

    it "includes interfaces section" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "API.md")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_markdown([input_file], output_path: output_path)

        content = File.read(output_path)
        expect(content).to include("## Interfaces")
        expect(content).to include("Product")
      end
    end

    it "includes functions section" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "API.md")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_markdown([input_file], output_path: output_path)

        content = File.read(output_path)
        expect(content).to include("## Functions")
        expect(content).to include("calculate")
      end
    end

    it "includes table of contents" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "API.md")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_markdown([input_file], output_path: output_path)

        content = File.read(output_path)
        expect(content).to include("## Table of Contents")
        expect(content).to include("[Types](#types)")
        expect(content).to include("[Interfaces](#interfaces)")
        expect(content).to include("[Functions](#functions)")
      end
    end
  end

  describe "#generate_json" do
    let(:trb_content) do
      <<~TRB
        type Id = Integer
        interface Entity
          id: Id
        end
      TRB
    end

    it "generates JSON file" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "api.json")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_json([input_file], output_path: output_path)

        expect(File.exist?(output_path)).to be true
        json = JSON.parse(File.read(output_path))
        expect(json).to have_key("generated_at")
        expect(json).to have_key("version")
        expect(json).to have_key("types")
        expect(json).to have_key("interfaces")
      end
    end

    it "includes type information" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        output_path = File.join(tmpdir, "api.json")
        File.write(input_file, trb_content)

        allow(generator).to receive(:puts)
        generator.generate_json([input_file], output_path: output_path)

        json = JSON.parse(File.read(output_path))
        expect(json["types"]).to have_key("Id")
      end
    end
  end

  describe "private methods" do
    describe "#collect_files" do
      it "collects .trb files from directory" do
        Dir.mktmpdir do |tmpdir|
          FileUtils.touch(File.join(tmpdir, "test.trb"))
          FileUtils.touch(File.join(tmpdir, "other.rb"))

          files = generator.send(:collect_files, [tmpdir])

          expect(files.length).to eq(1)
          expect(files.first).to end_with("test.trb")
        end
      end

      it "collects .d.trb files from directory" do
        Dir.mktmpdir do |tmpdir|
          FileUtils.touch(File.join(tmpdir, "types.d.trb"))

          files = generator.send(:collect_files, [tmpdir])

          expect(files.length).to eq(1)
          expect(files.first).to end_with("types.d.trb")
        end
      end

      it "collects single file" do
        Dir.mktmpdir do |tmpdir|
          file_path = File.join(tmpdir, "test.trb")
          FileUtils.touch(file_path)

          files = generator.send(:collect_files, [file_path])

          expect(files).to eq([file_path])
        end
      end

      it "returns unique files" do
        Dir.mktmpdir do |tmpdir|
          file_path = File.join(tmpdir, "test.trb")
          FileUtils.touch(file_path)

          files = generator.send(:collect_files, [tmpdir, file_path])

          expect(files.uniq).to eq(files)
        end
      end
    end

    describe "#extract_doc_comments" do
      it "extracts @doc comments" do
        content = <<~TRB
          # @doc type:MyType
          # This is a description
          type MyType = String
        TRB

        comments = generator.send(:extract_doc_comments, content)
        expect(comments).to have_key("type:MyType")
      end

      it "extracts inline comments before definitions" do
        content = <<~TRB
          # This is a type alias
          type MyType = String
        TRB

        comments = generator.send(:extract_doc_comments, content)
        expect(comments).to have_key("type:MyType")
        expect(comments["type:MyType"]).to include("type alias")
      end
    end

    describe "#parse_interfaces" do
      it "parses interface with members" do
        content = <<~TRB
          interface User
            id: Integer
            name: String
          end
        TRB

        generator.send(:parse_interfaces, content, "test.trb", {})

        expect(generator.docs[:interfaces]).to have_key("User")
        expect(generator.docs[:interfaces]["User"][:members].length).to eq(2)
      end

      it "parses generic interface" do
        content = <<~TRB
          interface Container<T>
            value: T
          end
        TRB

        generator.send(:parse_interfaces, content, "test.trb", {})

        expect(generator.docs[:interfaces]["Container"][:type_params]).to eq(["T"])
      end
    end

    describe "#parse_functions" do
      it "parses function with parameters" do
        content = "def add(a: Integer, b: Integer): Integer\\n  a + b\\nend"

        generator.send(:parse_functions, content, "test.trb", {})

        expect(generator.docs[:functions]).to have_key("add")
        expect(generator.docs[:functions]["add"][:params].length).to eq(2)
        expect(generator.docs[:functions]["add"][:return_type]).to eq("Integer")
      end

      it "parses generic function" do
        content = "def first<T>(items: Array<T>): T\\n  items.first\\nend"

        generator.send(:parse_functions, content, "test.trb", {})

        expect(generator.docs[:functions]["first"][:type_params]).to eq(["T"])
      end

      it "parses function with special characters in name" do
        content = "def valid?(value: Boolean): Boolean\\n  value\\nend"

        generator.send(:parse_functions, content, "test.trb", {})

        expect(generator.docs[:functions]).to have_key("valid?")
      end
    end

    describe "#generate_type_html" do
      it "generates HTML for type" do
        info = {
          definition: "String | Integer",
          description: "A test type",
          source: "test.trb",
          type_params: nil,
        }

        html = generator.send(:generate_type_html, "MyType", info)

        expect(html).to include("<title>MyType - T-Ruby API</title>")
        expect(html).to include("type MyType")
        expect(html).to include("String | Integer")
      end

      it "includes type parameters" do
        info = {
          definition: "Array<T>",
          type_params: ["T"],
          source: "test.trb",
        }

        html = generator.send(:generate_type_html, "Container", info)

        expect(html).to include("<T>")
      end
    end

    describe "#generate_interface_html" do
      it "generates HTML for interface" do
        info = {
          members: [
            { name: "id", type: "Integer", description: "The ID" },
          ],
          source: "test.trb",
          type_params: nil,
        }

        html = generator.send(:generate_interface_html, "User", info)

        expect(html).to include("<title>User - T-Ruby API</title>")
        expect(html).to include("interface User")
        expect(html).to include("id")
        expect(html).to include("Integer")
      end
    end

    describe "#generate_function_html" do
      it "generates HTML for function" do
        info = {
          params: [
            { name: "a", type: "Integer" },
            { name: "b", type: "Integer" },
          ],
          return_type: "Integer",
          source: "test.trb",
          type_params: nil,
        }

        html = generator.send(:generate_function_html, "add", info)

        expect(html).to include("<title>add - T-Ruby API</title>")
        expect(html).to include("def add")
        expect(html).to include("a: Integer")
        expect(html).to include("Returns")
      end
    end

    describe "#generate_search_index" do
      it "generates search index with all items" do
        generator.docs[:types]["MyType"] = { name: "MyType" }
        generator.docs[:interfaces]["MyInterface"] = { name: "MyInterface" }
        generator.docs[:functions]["myFunc"] = { name: "myFunc" }

        Dir.mktmpdir do |tmpdir|
          generator.send(:generate_search_index, tmpdir)

          index_path = File.join(tmpdir, "search-index.json")
          expect(File.exist?(index_path)).to be true

          data = JSON.parse(File.read(index_path))
          types = data.select { |d| d["type"] == "type" }
          interfaces = data.select { |d| d["type"] == "interface" }
          functions = data.select { |d| d["type"] == "function" }

          expect(types.length).to eq(1)
          expect(interfaces.length).to eq(1)
          expect(functions.length).to eq(1)
        end
      end
    end
  end
end
`,
  "spec/t_ruby/docs_badge_generator_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"

describe TRuby::DocsBadgeGenerator do
  let(:generator) { described_class.new }

  let(:example) do
    TRuby::DocsExampleExtractor::CodeExample.new(
      code: "test",
      language: "trb",
      file_path: "docs/test.md",
      line_number: 10,
      metadata: nil
    )
  end

  let(:pass_result) do
    TRuby::DocsExampleVerifier::VerificationResult.new(
      example: example,
      status: :pass,
      errors: []
    )
  end

  let(:fail_result) do
    TRuby::DocsExampleVerifier::VerificationResult.new(
      example: example,
      status: :fail,
      errors: ["Test error"]
    )
  end

  let(:skip_result) do
    TRuby::DocsExampleVerifier::VerificationResult.new(
      example: example,
      status: :skip,
      errors: ["Skipped"]
    )
  end

  describe "COLORS" do
    it "defines color constants" do
      expect(described_class::COLORS).to be_a(Hash)
      expect(described_class::COLORS[:excellent]).to eq("brightgreen")
      expect(described_class::COLORS[:good]).to eq("green")
      expect(described_class::COLORS[:fair]).to eq("yellow")
      expect(described_class::COLORS[:poor]).to eq("orange")
      expect(described_class::COLORS[:critical]).to eq("red")
    end
  end

  describe "#initialize" do
    it "creates an instance" do
      expect(generator).to be_a(described_class)
    end
  end

  describe "#generate_all" do
    it "generates all output files" do
      results = [pass_result, pass_result, fail_result]

      Dir.mktmpdir do |tmpdir|
        generator.generate_all(results, tmpdir)

        expect(File.exist?(File.join(tmpdir, "docs_badge.json"))).to be true
        expect(File.exist?(File.join(tmpdir, "docs_badge.svg"))).to be true
        expect(File.exist?(File.join(tmpdir, "docs_report.json"))).to be true
        expect(File.exist?(File.join(tmpdir, "docs_report.md"))).to be true
      end
    end

    it "creates output directory if not exists" do
      results = [pass_result]

      Dir.mktmpdir do |tmpdir|
        output_dir = File.join(tmpdir, "nested", "output")
        generator.generate_all(results, output_dir)

        expect(Dir.exist?(output_dir)).to be true
      end
    end
  end

  describe "#generate_badge_json" do
    it "generates Shields.io compatible JSON" do
      results = [pass_result, pass_result, fail_result, skip_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "badge.json")
        generator.generate_badge_json(results, path)

        badge = JSON.parse(File.read(path))
        expect(badge["schemaVersion"]).to eq(1)
        expect(badge["label"]).to eq("docs examples")
        expect(badge["message"]).to include("%")
        expect(badge["color"]).to be_a(String)
      end
    end

    it "shows correct pass rate" do
      results = [pass_result, pass_result, pass_result, fail_result] # 75%

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "badge.json")
        generator.generate_badge_json(results, path)

        badge = JSON.parse(File.read(path))
        expect(badge["message"]).to eq("75.0%")
      end
    end

    it "uses correct color based on rate" do
      # Test excellent (100%)
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "badge.json")
        generator.generate_badge_json([pass_result], path)

        badge = JSON.parse(File.read(path))
        expect(badge["color"]).to eq("brightgreen")
      end
    end
  end

  describe "#generate_badge_svg" do
    it "generates valid SVG" do
      results = [pass_result, fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "badge.svg")
        generator.generate_badge_svg(results, path)

        svg = File.read(path)
        expect(svg).to include("<svg")
        expect(svg).to include("xmlns")
        expect(svg).to include("docs examples")
        expect(svg).to include("%")
      end
    end

    it "uses correct color in SVG" do
      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "badge.svg")
        generator.generate_badge_svg([pass_result], path)

        svg = File.read(path)
        expect(svg).to include("#4c1") # bright green for 100%
      end
    end
  end

  describe "#generate_report_json" do
    it "generates JSON report with summary" do
      results = [pass_result, fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.json")
        generator.generate_report_json(results, path)

        report = JSON.parse(File.read(path))
        expect(report).to have_key("generated_at")
        expect(report).to have_key("summary")
        expect(report).to have_key("files")
      end
    end

    it "includes summary statistics" do
      results = [pass_result, pass_result, fail_result, skip_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.json")
        generator.generate_report_json(results, path)

        report = JSON.parse(File.read(path))
        summary = report["summary"]
        expect(summary["total"]).to eq(4)
        expect(summary["passed"]).to eq(2)
        expect(summary["failed"]).to eq(1)
        expect(summary["skipped"]).to eq(1)
      end
    end

    it "groups results by file" do
      ex1 = TRuby::DocsExampleExtractor::CodeExample.new(
        code: "test", language: "trb", file_path: "a.md", line_number: 1, metadata: nil
      )
      ex2 = TRuby::DocsExampleExtractor::CodeExample.new(
        code: "test", language: "trb", file_path: "b.md", line_number: 1, metadata: nil
      )

      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(example: ex1, status: :pass, errors: []),
        TRuby::DocsExampleVerifier::VerificationResult.new(example: ex2, status: :pass, errors: []),
      ]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.json")
        generator.generate_report_json(results, path)

        report = JSON.parse(File.read(path))
        expect(report["files"].keys).to include("a.md", "b.md")
      end
    end
  end

  describe "#generate_report_markdown" do
    it "generates Markdown report" do
      results = [pass_result, fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.md")
        generator.generate_report_markdown(results, path)

        markdown = File.read(path)
        expect(markdown).to include("# Documentation Examples Verification Report")
        expect(markdown).to include("## Summary")
        expect(markdown).to include("## Results by File")
      end
    end

    it "includes summary table" do
      results = [pass_result, fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.md")
        generator.generate_report_markdown(results, path)

        markdown = File.read(path)
        expect(markdown).to include("| Total Examples |")
        expect(markdown).to include("| Passed |")
        expect(markdown).to include("| Failed |")
        expect(markdown).to include("| **Pass Rate** |")
      end
    end

    it "shows failed examples with details" do
      results = [fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.md")
        generator.generate_report_markdown(results, path)

        markdown = File.read(path)
        expect(markdown).to include("**Failed examples:**")
        expect(markdown).to include("Line 10")
        expect(markdown).to include("Test error")
      end
    end

    it "uses checkmark for files with no failures" do
      results = [pass_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.md")
        generator.generate_report_markdown(results, path)

        markdown = File.read(path)
        expect(markdown).to include("✅")
      end
    end

    it "uses X for files with failures" do
      results = [fail_result]

      Dir.mktmpdir do |tmpdir|
        path = File.join(tmpdir, "report.md")
        generator.generate_report_markdown(results, path)

        markdown = File.read(path)
        expect(markdown).to include("❌")
      end
    end
  end

  describe "private methods" do
    describe "#color_for_rate" do
      it "returns brightgreen for excellent rate (95-100)" do
        expect(generator.send(:color_for_rate, 100)).to eq("brightgreen")
        expect(generator.send(:color_for_rate, 95)).to eq("brightgreen")
      end

      it "returns green for good rate (80-94)" do
        expect(generator.send(:color_for_rate, 94)).to eq("green")
        expect(generator.send(:color_for_rate, 80)).to eq("green")
      end

      it "returns yellow for fair rate (60-79)" do
        expect(generator.send(:color_for_rate, 79)).to eq("yellow")
        expect(generator.send(:color_for_rate, 60)).to eq("yellow")
      end

      it "returns orange for poor rate (40-59)" do
        expect(generator.send(:color_for_rate, 59)).to eq("orange")
        expect(generator.send(:color_for_rate, 40)).to eq("orange")
      end

      it "returns red for critical rate (0-39)" do
        expect(generator.send(:color_for_rate, 39)).to eq("red")
        expect(generator.send(:color_for_rate, 0)).to eq("red")
      end
    end

    describe "#svg_color_for_rate" do
      it "returns hex color codes" do
        expect(generator.send(:svg_color_for_rate, 100)).to eq("#4c1")
        expect(generator.send(:svg_color_for_rate, 85)).to eq("#97ca00")
        expect(generator.send(:svg_color_for_rate, 70)).to eq("#dfb317")
        expect(generator.send(:svg_color_for_rate, 50)).to eq("#fe7d37")
        expect(generator.send(:svg_color_for_rate, 20)).to eq("#e05d44")
      end
    end

    describe "#group_results_by_file" do
      it "groups results by file_path" do
        ex1 = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "test", language: "trb", file_path: "a.md", line_number: 1, metadata: nil
        )
        ex2 = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "test", language: "trb", file_path: "a.md", line_number: 5, metadata: nil
        )
        ex3 = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "test", language: "trb", file_path: "b.md", line_number: 1, metadata: nil
        )

        results = [
          TRuby::DocsExampleVerifier::VerificationResult.new(example: ex1, status: :pass, errors: []),
          TRuby::DocsExampleVerifier::VerificationResult.new(example: ex2, status: :pass, errors: []),
          TRuby::DocsExampleVerifier::VerificationResult.new(example: ex3, status: :pass, errors: []),
        ]

        grouped = generator.send(:group_results_by_file, results)
        expect(grouped.keys).to eq(["a.md", "b.md"])
        expect(grouped["a.md"].length).to eq(2)
        expect(grouped["b.md"].length).to eq(1)
      end
    end
  end
end
`,
  "spec/t_ruby/docs_example_extractor_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"

describe TRuby::DocsExampleExtractor do
  let(:extractor) { described_class.new }

  describe TRuby::DocsExampleExtractor::CodeExample do
    let(:example) do
      described_class.new(
        code: "def test: void; end",
        language: "trb",
        file_path: "docs/test.md",
        line_number: 10,
        metadata: nil
      )
    end

    describe "#trb?" do
      it "returns true for trb language" do
        expect(example.trb?).to be true
      end

      it "returns true for t-ruby language" do
        ex = described_class.new(code: "", language: "t-ruby", file_path: "", line_number: 1, metadata: nil)
        expect(ex.trb?).to be true
      end

      it "returns false for other languages" do
        ex = described_class.new(code: "", language: "ruby", file_path: "", line_number: 1, metadata: nil)
        expect(ex.trb?).to be false
      end
    end

    describe "#ruby?" do
      it "returns true for ruby language" do
        ex = described_class.new(code: "", language: "ruby", file_path: "", line_number: 1, metadata: nil)
        expect(ex.ruby?).to be true
      end

      it "returns false for other languages" do
        expect(example.ruby?).to be false
      end
    end

    describe "#rbs?" do
      it "returns true for rbs language" do
        ex = described_class.new(code: "", language: "rbs", file_path: "", line_number: 1, metadata: nil)
        expect(ex.rbs?).to be true
      end

      it "returns false for other languages" do
        expect(example.rbs?).to be false
      end
    end

    describe "#should_verify?" do
      it "returns true by default" do
        expect(example.should_verify?).to be true
      end

      it "returns false with skip-verify metadata" do
        ex = described_class.new(code: "", language: "trb", file_path: "", line_number: 1, metadata: "skip-verify")
        expect(ex.should_verify?).to be false
      end
    end

    describe "#should_compile?" do
      it "returns true by default" do
        expect(example.should_compile?).to be true
      end

      it "returns false with no-compile metadata" do
        ex = described_class.new(code: "", language: "trb", file_path: "", line_number: 1, metadata: "no-compile")
        expect(ex.should_compile?).to be false
      end
    end

    describe "#should_typecheck?" do
      it "returns true by default" do
        expect(example.should_typecheck?).to be true
      end

      it "returns false with no-typecheck metadata" do
        ex = described_class.new(code: "", language: "trb", file_path: "", line_number: 1, metadata: "no-typecheck")
        expect(ex.should_typecheck?).to be false
      end
    end
  end

  describe "#extract_from_file" do
    it "extracts trb code blocks" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          # Test

          \`\`\`trb
          def hello: void
          end
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.length).to eq(1)
        expect(examples.first.language).to eq("trb")
        expect(examples.first.code).to include("def hello")
      end
    end

    it "extracts ruby code blocks" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          \`\`\`ruby
          def hello
            puts "hello"
          end
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.length).to eq(1)
        expect(examples.first.language).to eq("ruby")
      end
    end

    it "extracts rbs code blocks" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          \`\`\`rbs
          def hello: (String) -> void
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.length).to eq(1)
        expect(examples.first.language).to eq("rbs")
      end
    end

    it "ignores non-relevant languages" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          \`\`\`python
          print("hello")
          \`\`\`

          \`\`\`javascript
          console.log("hello");
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples).to be_empty
      end
    end

    it "captures line numbers correctly" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          # Header

          Some text

          \`\`\`trb
          def test: void
          end
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.first.line_number).to eq(5)
      end
    end

    it "captures metadata from code fence" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          \`\`\`trb {skip-verify}
          def test: void
          end
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.first.metadata).to eq("skip-verify")
      end
    end

    it "handles Docusaurus title attribute" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          \`\`\`ruby title="example.trb"
          def test: void
          end
          \`\`\`
        MD

        examples = extractor.extract_from_file(md_file)
        expect(examples.first.language).to eq("trb")
      end
    end
  end

  describe "#extract_from_content" do
    it "extracts from content string" do
      content = <<~MD
        \`\`\`trb
        def test: void; end
        \`\`\`
      MD

      examples = extractor.extract_from_content(content)
      expect(examples.length).to eq(1)
    end

    it "uses default file_path" do
      content = "\`\`\`trb\\ntest\\n\`\`\`"
      examples = extractor.extract_from_content(content)
      expect(examples.first.file_path).to eq("<string>")
    end

    it "uses provided file_path" do
      content = "\`\`\`trb\\ntest\\n\`\`\`"
      examples = extractor.extract_from_content(content, "custom.md")
      expect(examples.first.file_path).to eq("custom.md")
    end
  end

  describe "#extract_from_glob" do
    it "extracts from multiple files" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "a.md"), "\`\`\`trb\\ndef a: void; end\\n\`\`\`")
        File.write(File.join(tmpdir, "b.md"), "\`\`\`trb\\ndef b: void; end\\n\`\`\`")

        examples = extractor.extract_from_glob(File.join(tmpdir, "*.md"))
        expect(examples.length).to eq(2)
      end
    end
  end

  describe "#statistics" do
    it "calculates statistics correctly" do
      examples = [
        TRuby::DocsExampleExtractor::CodeExample.new(
          code: "", language: "trb", file_path: "a.md", line_number: 1, metadata: nil
        ),
        TRuby::DocsExampleExtractor::CodeExample.new(
          code: "", language: "ruby", file_path: "a.md", line_number: 5, metadata: nil
        ),
        TRuby::DocsExampleExtractor::CodeExample.new(
          code: "", language: "rbs", file_path: "b.md", line_number: 1, metadata: nil
        ),
        TRuby::DocsExampleExtractor::CodeExample.new(
          code: "", language: "trb", file_path: "b.md", line_number: 5, metadata: "skip-verify"
        ),
      ]

      stats = extractor.statistics(examples)

      expect(stats[:total]).to eq(4)
      expect(stats[:trb]).to eq(2)
      expect(stats[:ruby]).to eq(1)
      expect(stats[:rbs]).to eq(1)
      expect(stats[:verifiable]).to eq(3)
      expect(stats[:files]).to eq(2)
    end
  end

  describe "CODE_FENCE_PATTERN" do
    it "matches basic code fence" do
      expect("\`\`\`trb").to match(described_class::CODE_FENCE_PATTERN)
    end

    it "matches code fence with title" do
      match = '\`\`\`ruby title="example.trb"'.match(described_class::CODE_FENCE_PATTERN)
      expect(match[1]).to eq("ruby")
      expect(match[2]).to eq("example.trb")
    end

    it "matches code fence with metadata" do
      match = "\`\`\`trb {skip-verify}".match(described_class::CODE_FENCE_PATTERN)
      expect(match[1]).to eq("trb")
      expect(match[3]).to eq("skip-verify")
    end
  end
end
`,
  "spec/t_ruby/docs_example_verifier_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "fileutils"

describe TRuby::DocsExampleVerifier do
  let(:verifier) { described_class.new }

  describe TRuby::DocsExampleVerifier::VerificationResult do
    let(:example) do
      TRuby::DocsExampleExtractor::CodeExample.new(
        code: "def test: void; end",
        language: "trb",
        file_path: "test.md",
        line_number: 10,
        metadata: nil
      )
    end

    describe "#pass?" do
      it "returns true when status is :pass" do
        result = described_class.new(example: example, status: :pass, errors: [])
        expect(result.pass?).to be true
      end

      it "returns false when status is not :pass" do
        result = described_class.new(example: example, status: :fail, errors: [])
        expect(result.pass?).to be false
      end
    end

    describe "#fail?" do
      it "returns true when status is :fail" do
        result = described_class.new(example: example, status: :fail, errors: ["error"])
        expect(result.fail?).to be true
      end

      it "returns false when status is not :fail" do
        result = described_class.new(example: example, status: :pass, errors: [])
        expect(result.fail?).to be false
      end
    end

    describe "#skip?" do
      it "returns true when status is :skip" do
        result = described_class.new(example: example, status: :skip, errors: ["skipped"])
        expect(result.skip?).to be true
      end

      it "returns false when status is not :skip" do
        result = described_class.new(example: example, status: :pass, errors: [])
        expect(result.skip?).to be false
      end
    end

    describe "#file_path" do
      it "delegates to example" do
        result = described_class.new(example: example, status: :pass, errors: [])
        expect(result.file_path).to eq("test.md")
      end
    end

    describe "#line_number" do
      it "delegates to example" do
        result = described_class.new(example: example, status: :pass, errors: [])
        expect(result.line_number).to eq(10)
      end
    end
  end

  describe "#initialize" do
    it "creates an instance" do
      expect(verifier).to be_a(described_class)
    end
  end

  describe "#verify_file" do
    it "verifies all examples in a file" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "test.md")
        File.write(md_file, <<~MD)
          # Test

          \`\`\`trb
          def hello: void
          end
          \`\`\`
        MD

        results = verifier.verify_file(md_file)
        expect(results).to be_an(Array)
        expect(results.length).to eq(1)
      end
    end

    it "returns empty array for file with no examples" do
      Dir.mktmpdir do |tmpdir|
        md_file = File.join(tmpdir, "empty.md")
        File.write(md_file, "# No examples here")

        results = verifier.verify_file(md_file)
        expect(results).to eq([])
      end
    end
  end

  describe "#verify_glob" do
    it "verifies examples from multiple files" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "a.md"), <<~MD)
          \`\`\`trb
          def a: void; end
          \`\`\`
        MD
        File.write(File.join(tmpdir, "b.md"), <<~MD)
          \`\`\`trb
          def b: void; end
          \`\`\`
        MD

        results = verifier.verify_glob(File.join(tmpdir, "*.md"))
        expect(results.length).to eq(2)
      end
    end
  end

  describe "#verify_example" do
    describe "skip behavior" do
      it "skips examples marked with skip-verify" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "invalid code!",
          language: "trb",
          file_path: "test.md",
          line_number: 1,
          metadata: "skip-verify"
        )

        result = verifier.verify_example(example)
        expect(result.skip?).to be true
        expect(result.errors).to include("Marked as skip-verify")
      end

      it "skips unknown languages" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "some code",
          language: "python",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.skip?).to be true
        expect(result.errors.first).to include("Unknown language")
      end
    end

    describe "trb examples" do
      it "passes for valid trb code" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def hello(name: String): String\\n  name\\nend",
          language: "trb",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.pass?).to be true
      end

      it "fails for invalid trb syntax" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def @@@invalid syntax!!!",
          language: "trb",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        # Parser may pass some syntax through, but should catch obvious errors
        expect(%i[fail pass]).to include(result.status)
      end
    end

    describe "ruby examples" do
      it "passes for valid ruby code" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def hello(name)\\n  name\\nend",
          language: "ruby",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.pass?).to be true
      end

      it "fails for invalid ruby syntax" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def hello(\\nend",
          language: "ruby",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.fail?).to be true
        expect(result.errors.first).to include("Ruby syntax error")
      end
    end

    describe "rbs examples" do
      it "passes for valid rbs-like content" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def hello: (String) -> String",
          language: "rbs",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.pass?).to be true
      end

      it "skips rbs without recognizable content" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "# just a comment",
          language: "rbs",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        result = verifier.verify_example(example)
        expect(result.skip?).to be true
      end
    end

    describe "error handling" do
      it "catches exceptions and returns fail result" do
        example = TRuby::DocsExampleExtractor::CodeExample.new(
          code: "def test: void; end",
          language: "trb",
          file_path: "test.md",
          line_number: 1,
          metadata: nil
        )

        allow(TRuby::Parser).to receive(:new).and_raise(StandardError, "Unexpected error")

        result = verifier.verify_example(example)
        expect(result.fail?).to be true
        expect(result.errors.first).to include("Exception")
      end
    end
  end

  describe "#summary" do
    it "returns correct statistics" do
      example = TRuby::DocsExampleExtractor::CodeExample.new(
        code: "test",
        language: "trb",
        file_path: "test.md",
        line_number: 1,
        metadata: nil
      )

      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(example: example, status: :pass, errors: []),
        TRuby::DocsExampleVerifier::VerificationResult.new(example: example, status: :pass, errors: []),
        TRuby::DocsExampleVerifier::VerificationResult.new(example: example, status: :fail, errors: ["error"]),
        TRuby::DocsExampleVerifier::VerificationResult.new(example: example, status: :skip, errors: ["skip"]),
      ]

      summary = verifier.summary(results)

      expect(summary[:total]).to eq(4)
      expect(summary[:passed]).to eq(2)
      expect(summary[:failed]).to eq(1)
      expect(summary[:skipped]).to eq(1)
      expect(summary[:pass_rate]).to eq(50.0)
    end

    it "handles empty results" do
      summary = verifier.summary([])

      expect(summary[:total]).to eq(0)
      expect(summary[:pass_rate]).to eq(0)
    end
  end

  describe "#print_results" do
    let(:example) do
      TRuby::DocsExampleExtractor::CodeExample.new(
        code: "test",
        language: "trb",
        file_path: "test.md",
        line_number: 1,
        metadata: nil
      )
    end

    it "prints failed results" do
      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(
          example: example,
          status: :fail,
          errors: ["Test error"]
        ),
      ]

      expect { verifier.print_results(results) }.to output(/test\\.md:1/).to_stdout
    end

    it "prints skipped results" do
      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(
          example: example,
          status: :skip,
          errors: ["Skipped"]
        ),
      ]

      expect { verifier.print_results(results) }.to output(/test\\.md:1/).to_stdout
    end

    it "hides passed results by default" do
      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(
          example: example,
          status: :pass,
          errors: []
        ),
      ]

      output = capture_stdout { verifier.print_results(results) }
      expect(output).not_to include("test.md:1")
    end

    it "shows passed results in verbose mode" do
      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(
          example: example,
          status: :pass,
          errors: []
        ),
      ]

      expect { verifier.print_results(results, verbose: true) }.to output(/test\\.md:1/).to_stdout
    end

    it "prints summary at the end" do
      results = [
        TRuby::DocsExampleVerifier::VerificationResult.new(example: example, status: :pass, errors: []),
      ]

      expect { verifier.print_results(results) }.to output(/Results:.*passed/).to_stdout
    end
  end

  private

  def capture_stdout
    original = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = original
  end
end
`,
  "spec/t_ruby/error_handler_extended_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::ErrorHandler do
  describe "type alias error detection" do
    context "duplicate type alias definitions" do
      it "detects duplicate type alias definitions" do
        source = "type UserId = String\\ntype UserId = Integer"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors.length).to be > 0
      end

      it "reports error for duplicate alias with different definition" do
        source = "type Result = Boolean\\ntype Result = String"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors.any? { |e| e.include?("duplicate") || e.include?("Result") }).to be true
      end
    end

    context "undefined type references" do
      it "detects reference to undefined custom type" do
        source = "def test(x: UndefinedCustomType): String\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        # May flag as undefined type
        expect(errors).to be_a(Array)
      end
    end

    context "type alias with valid references" do
      it "accepts type alias with built-in types" do
        source = "type UserId = String\\ndef get(id: UserId): Boolean\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors).to be_empty
      end
    end
  end
end
`,
  "spec/t_ruby/error_handler_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::ErrorHandler do
  describe "syntax error detection" do
    context "invalid type names" do
      it "detects unrecognized type names" do
        source = "def test(x: UnknownType)\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors).to be_a(Array)
        # May or may not flag as error depending on strictness
      end

      it "accepts valid type names" do
        source = "def test(x: String, y: Integer): Boolean\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors).to be_empty
      end
    end

    context "malformed function signatures" do
      it "detects missing closing parenthesis" do
        source = "def test(x: String\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        # May flag as potential error
        expect(errors).to be_a(Array)
      end

      it "detects invalid parameter syntax" do
        source = "def test(: String)\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors).to be_a(Array)
      end
    end

    context "duplicate definitions" do
      it "detects duplicate function definitions with same name" do
        source = <<~RUBY
          def greet(name: String): String
            "Hello, " + name
          end

          def greet(age: Integer): Integer
            age + 1
          end
        RUBY
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        # May flag as warning/error
        expect(errors).to be_a(Array)
      end
    end
  end

  describe "type validation" do
    context "parameter type checking" do
      it "validates parameter types are recognized" do
        source = "def process(value: ValidType)\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        # Handler should validate type names
        expect(errors).to be_a(Array)
      end
    end

    context "return type checking" do
      it "validates return type is recognized" do
        source = "def get_value(): ValidReturnType\\nend"
        handler = TRuby::ErrorHandler.new(source)

        errors = handler.check
        expect(errors).to be_a(Array)
      end
    end
  end

  describe "error reporting" do
    it "provides helpful error messages" do
      source = "def test(x: BadType)\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)

      if errors.any?
        errors.each do |error|
          expect(error).to be_a(String)
        end
      end
    end

    it "reports line numbers if detected" do
      source = "def test(x: String)" + "\\n" \\
                                       "def test(x: Integer)" + "\\n"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end
  end

  describe "namespaced interface definitions" do
    it "does not flag namespaced interfaces as duplicates of parent" do
      source = <<~RUBY
        interface Rails
          application: Rails::Application
        end

        interface Rails::Application
          config: Rails::Application::Configuration
        end

        interface Rails::Application::Configuration
          root: Pathname
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "detects actual duplicate namespaced interfaces" do
      source = <<~RUBY
        interface Foo::Bar
          name: String
        end

        interface Foo::Bar
          age: Integer
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.length).to eq(1)
      expect(errors[0]).to include("Foo::Bar")
      expect(errors[0]).to include("already defined")
    end

    it "allows same name in different namespaces" do
      source = <<~RUBY
        interface A::Config
          value: String
        end

        interface B::Config
          value: Integer
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "allows namespaced interface without parent interface" do
      source = <<~RUBY
        interface Foo::Bar::Baz
          value: String
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles deeply nested namespaces (4+ levels)" do
      source = <<~RUBY
        interface A::B::C::D::E
          value: String
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles reverse order definition (child before parent)" do
      source = <<~RUBY
        interface Rails::Application
          config: String
        end

        interface Rails
          app: Rails::Application
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "distinguishes partially overlapping namespaces" do
      source = <<~RUBY
        interface Foo::Bar
          a: String
        end

        interface Foo::Baz
          b: String
        end

        interface Bar::Foo
          c: String
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles empty namespaced interface" do
      source = <<~RUBY
        interface Empty::Interface
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "allows namespaced types in member definitions" do
      source = <<~RUBY
        interface Container
          config: Rails::Application::Configuration
          logger: ActiveSupport::Logger
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles extra whitespace around namespace" do
      source = <<~RUBY
        interface  Rails::Application
          config: String
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles tab indentation" do
      source = "\\tinterface Rails::Application\\n\\t\\tconfig: String\\n\\tend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "allows underscores in namespace names" do
      source = <<~RUBY
        interface Active_Record::Base_Class
          id: Integer
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end
  end

  describe "Float type validation" do
    it "accepts Float as a valid type" do
      source = "def calculate(x: Float): Float\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "accepts Float in union types" do
      source = "def parse(value: Integer | Float): Float\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end
  end

  describe "unicode identifier support" do
    it "handles Korean function names" do
      source = <<~RUBY
        def 인사하기(이름: String): String
          "안녕, " + 이름
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "detects duplicate Korean function definitions" do
      source = <<~RUBY
        def 인사하기(이름: String): String
          "안녕"
        end

        def 인사하기(나이: Integer): Integer
          나이
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.length).to eq(1)
      expect(errors[0]).to include("인사하기")
      expect(errors[0]).to include("already defined")
    end
  end

  describe "duplicate functions in different classes" do
    it "allows same method name in different classes" do
      source = <<~RUBY
        class Dog
          def speak(): String
            "Woof"
          end
        end

        class Cat
          def speak(): String
            "Meow"
          end
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "detects duplicate methods within the same class" do
      source = <<~RUBY
        class Animal
          def speak(): String
            "Hello"
          end

          def speak(): String
            "World"
          end
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.length).to eq(1)
      expect(errors[0]).to include("speak")
      expect(errors[0]).to include("already defined")
    end
  end

  describe "type alias validation" do
    it "detects duplicate type aliases" do
      source = <<~RUBY
        type UserId = Integer
        type UserId = String
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.length).to eq(1)
      expect(errors[0]).to include("UserId")
      expect(errors[0]).to include("already defined")
    end

    it "allows different type alias names" do
      source = <<~RUBY
        type UserId = Integer
        type PostId = Integer
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end
  end

  describe "parameter type colon validation" do
    it "detects parameter with colon but no type" do
      source = "def test(x:)\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
      # Should detect missing type after colon
    end
  end

  describe "complex parameter types" do
    it "handles Hash type with braces in parameters" do
      source = "def process(config: Hash{String => Integer}): Integer\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end

    it "handles multiple complex parameters" do
      source = "def complex(arr: Array<String>, hash: Hash{Symbol => Integer}, block: Proc<String>): void\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end

    it "handles nested generic types" do
      source = "def nested(data: Array<Hash<String, Array<Integer>>>): void\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end
  end

  describe "return type validation" do
    it "detects unknown simple return type" do
      source = "def test(): UnknownReturnType\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.any? { |e| e.include?("Unknown return type") }).to be true
    end

    it "allows type alias as return type" do
      source = <<~RUBY
        type UserId = Integer
        def get_user_id(): UserId
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "allows interface as return type" do
      source = <<~RUBY
        interface Printable
          to_string: String
        end
        def get_printable(): Printable
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end
  end

  describe "end of class detection" do
    it "handles end statement closing class" do
      source = <<~RUBY
        class MyClass
          def method1(): String
            "test"
          end
        end
      RUBY
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "handles top-level end closing class scope" do
      source = "class A\\n  def x: String\\n    \\"y\\"\\n  end\\nend\\ndef z: Integer\\n  1\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end
  end

  describe "angle bracket counting" do
    it "handles arrow operators in type definitions" do
      source = "def transform(f: (Integer) -> String): (String) -> Boolean\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end

    it "handles comparison operators with <>" do
      source = "def compare(a: Array<Integer>): Array<String>\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_a(Array)
    end
  end
end
`,
  "spec/t_ruby/error_reporter_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ErrorReporter do
  let(:reporter) { described_class.new }

  describe "#add" do
    it "adds a diagnostic to the collection" do
      diagnostic = TRuby::Diagnostic.new(code: "TR2001", message: "Error")

      reporter.add(diagnostic)

      expect(reporter.diagnostics).to include(diagnostic)
    end
  end

  describe "#add_type_check_error" do
    it "converts and adds TypeCheckError" do
      error = TRuby::TypeCheckError.new(
        message: "Type mismatch",
        location: "test.trb:5:10",
        expected: "String",
        actual: "Integer"
      )
      source = "line1\\nline2\\nline3\\nline4\\ngreet(123)\\nline6"

      reporter.add_type_check_error(error, file: "test.trb", source: source)

      expect(reporter.diagnostics.size).to eq(1)
      diagnostic = reporter.diagnostics.first
      expect(diagnostic.code).to eq("TR2001")
      expect(diagnostic.message).to eq("Type mismatch")
      expect(diagnostic.line).to eq(5)
      expect(diagnostic.source_line).to eq("greet(123)")
    end
  end

  describe "#add_parse_error" do
    it "converts and adds ParseError" do
      error = TRuby::ParseError.new("Unexpected token", line: 3, column: 5)
      source = "line1\\nline2\\ndef foo(: String)\\nline4"

      reporter.add_parse_error(error, file: "test.trb", source: source)

      expect(reporter.diagnostics.size).to eq(1)
      diagnostic = reporter.diagnostics.first
      expect(diagnostic.code).to eq("TR1001")
      expect(diagnostic.message).to eq("Unexpected token")
      expect(diagnostic.line).to eq(3)
      expect(diagnostic.source_line).to eq("def foo(: String)")
    end
  end

  describe "#add_scan_error" do
    it "converts and adds ScanError" do
      error = TRuby::Scanner::ScanError.new("Unterminated string", line: 2, column: 10, position: 20)
      source = "line1\\n\\"unclosed string\\nline3"

      reporter.add_scan_error(error, file: "test.trb", source: source)

      expect(reporter.diagnostics.size).to eq(1)
      diagnostic = reporter.diagnostics.first
      expect(diagnostic.code).to eq("TR1001")
      expect(diagnostic.message).to eq("Unterminated string")
    end
  end

  describe "#has_errors?" do
    it "returns false when no diagnostics" do
      expect(reporter.has_errors?).to be false
    end

    it "returns true when there are error-severity diagnostics" do
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Error", severity: :error))

      expect(reporter.has_errors?).to be true
    end

    it "returns false when only warnings exist" do
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Warning", severity: :warning))

      expect(reporter.has_errors?).to be false
    end
  end

  describe "#error_count" do
    it "returns 0 when no diagnostics" do
      expect(reporter.error_count).to eq(0)
    end

    it "counts only error-severity diagnostics" do
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Error 1", severity: :error))
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Warning", severity: :warning))
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Error 2", severity: :error))

      expect(reporter.error_count).to eq(2)
    end
  end

  describe "#report" do
    it "returns formatted output using DiagnosticFormatter" do
      reporter.add(
        TRuby::Diagnostic.new(
          code: "TR2001",
          message: "Type mismatch",
          file: "test.trb",
          line: 7,
          column: 5
        )
      )

      result = reporter.report

      expect(result).to include("test.trb:7:5")
      expect(result).to include("TR2001")
      expect(result).to include("Type mismatch")
      expect(result).to include("Found 1 error")
    end

    it "returns empty string when no diagnostics" do
      expect(reporter.report).to eq("")
    end
  end

  describe "#clear" do
    it "removes all diagnostics" do
      reporter.add(TRuby::Diagnostic.new(code: "TR2001", message: "Error"))
      reporter.add(TRuby::Diagnostic.new(code: "TR2002", message: "Error 2"))

      reporter.clear

      expect(reporter.diagnostics).to be_empty
    end
  end

  describe "file source loading" do
    it "loads source from file when not provided" do
      # Create a temp file for testing
      require "tempfile"
      tempfile = Tempfile.new(["test", ".trb"])
      tempfile.write("line1\\nline2\\nerror_line\\nline4")
      tempfile.close

      begin
        error = TRuby::TypeCheckError.new(message: "Error", location: "#{tempfile.path}:3")

        reporter.add_type_check_error(error, file: tempfile.path)

        diagnostic = reporter.diagnostics.first
        expect(diagnostic.source_line).to eq("error_line")
      ensure
        tempfile.unlink
      end
    end
  end
end
`,
  "spec/t_ruby/expression_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator::ExpressionParser do
  include TRuby::ParserCombinator::TokenDSL

  let(:parser) { described_class.new }
  let(:scanner) { TRuby::Scanner.new(source) }
  let(:tokens) { scanner.scan_all }

  describe "literals" do
    describe "integer literals" do
      let(:source) { "42" }

      it "parses integer literals" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:integer)
        expect(result.value.value).to eq(42)
      end
    end

    describe "float literals" do
      let(:source) { "3.14" }

      it "parses float literals" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:float)
        expect(result.value.value).to eq(3.14)
      end
    end

    describe "string literals" do
      let(:source) { '"hello world"' }

      it "parses string literals" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:string)
        expect(result.value.value).to eq("hello world")
      end
    end

    describe "symbol literals" do
      let(:source) { ":foo" }

      it "parses symbol literals" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:symbol)
        expect(result.value.value).to eq(:foo)
      end
    end

    describe "boolean literals" do
      it "parses true" do
        scanner = TRuby::Scanner.new("true")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:boolean)
        expect(result.value.value).to be true
      end

      it "parses false" do
        scanner = TRuby::Scanner.new("false")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.literal_type).to eq(:boolean)
        expect(result.value.value).to be false
      end
    end

    describe "nil literal" do
      let(:source) { "nil" }

      it "parses nil" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.literal_type).to eq(:nil)
        expect(result.value.value).to be_nil
      end
    end
  end

  describe "variable references" do
    describe "local variables" do
      let(:source) { "foo" }

      it "parses local variable reference" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::VariableRef)
        expect(result.value.name).to eq("foo")
        expect(result.value.scope).to eq(:local)
      end
    end

    describe "instance variables" do
      let(:source) { "@name" }

      it "parses instance variable reference" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::VariableRef)
        expect(result.value.name).to eq("@name")
        expect(result.value.scope).to eq(:instance)
      end
    end

    describe "class variables" do
      let(:source) { "@@count" }

      it "parses class variable reference" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::VariableRef)
        expect(result.value.name).to eq("@@count")
        expect(result.value.scope).to eq(:class)
      end
    end

    describe "global variables" do
      let(:source) { "$stdout" }

      it "parses global variable reference" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::VariableRef)
        expect(result.value.name).to eq("$stdout")
        expect(result.value.scope).to eq(:global)
      end
    end

    describe "constants" do
      let(:source) { "MyClass" }

      it "parses constant reference" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::VariableRef)
        expect(result.value.name).to eq("MyClass")
        expect(result.value.scope).to eq(:constant)
      end
    end
  end

  describe "binary operations" do
    describe "arithmetic" do
      it "parses addition" do
        scanner = TRuby::Scanner.new("1 + 2")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::BinaryOp)
        expect(result.value.operator).to eq(:+)
        expect(result.value.left).to be_a(TRuby::IR::Literal)
        expect(result.value.right).to be_a(TRuby::IR::Literal)
      end

      it "parses subtraction" do
        scanner = TRuby::Scanner.new("5 - 3")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::BinaryOp)
        expect(result.value.operator).to eq(:-)
      end

      it "parses multiplication" do
        scanner = TRuby::Scanner.new("4 * 3")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:*)
      end

      it "parses division" do
        scanner = TRuby::Scanner.new("10 / 2")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:/)
      end

      it "parses modulo" do
        scanner = TRuby::Scanner.new("7 % 3")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:%)
      end

      it "parses exponentiation" do
        scanner = TRuby::Scanner.new("2 ** 3")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:**)
      end
    end

    describe "comparison" do
      it "parses equality" do
        scanner = TRuby::Scanner.new("a == b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:==)
      end

      it "parses inequality" do
        scanner = TRuby::Scanner.new("a != b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:!=)
      end

      it "parses less than" do
        scanner = TRuby::Scanner.new("a < b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:<)
      end

      it "parses greater than" do
        scanner = TRuby::Scanner.new("a > b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:>)
      end

      it "parses less than or equal" do
        scanner = TRuby::Scanner.new("a <= b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:<=)
      end

      it "parses greater than or equal" do
        scanner = TRuby::Scanner.new("a >= b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:>=)
      end

      it "parses spaceship operator" do
        scanner = TRuby::Scanner.new("a <=> b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:<=>)
      end
    end

    describe "logical" do
      it "parses logical and" do
        scanner = TRuby::Scanner.new("a && b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:"&&")
      end

      it "parses logical or" do
        scanner = TRuby::Scanner.new("a || b")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.operator).to eq(:"||")
      end
    end

    describe "operator precedence" do
      it "respects multiplication over addition" do
        scanner = TRuby::Scanner.new("1 + 2 * 3")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        # Should be parsed as 1 + (2 * 3)
        expect(result.value).to be_a(TRuby::IR::BinaryOp)
        expect(result.value.operator).to eq(:+)
        expect(result.value.right).to be_a(TRuby::IR::BinaryOp)
        expect(result.value.right.operator).to eq(:*)
      end

      it "respects exponentiation over multiplication" do
        scanner = TRuby::Scanner.new("2 * 3 ** 2")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        # Should be parsed as 2 * (3 ** 2)
        expect(result.value.operator).to eq(:*)
        expect(result.value.right.operator).to eq(:**)
      end

      it "respects comparison over logical" do
        scanner = TRuby::Scanner.new("a > b && c < d")
        result = parser.parse_expression(scanner.scan_all, 0)

        expect(result.success?).to be true
        # Should be parsed as (a > b) && (c < d)
        expect(result.value.operator).to eq(:"&&")
        expect(result.value.left.operator).to eq(:>)
        expect(result.value.right.operator).to eq(:<)
      end
    end
  end

  describe "unary operations" do
    it "parses logical not" do
      scanner = TRuby::Scanner.new("!foo")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::UnaryOp)
      expect(result.value.operator).to eq(:!)
      expect(result.value.operand).to be_a(TRuby::IR::VariableRef)
    end

    it "parses negative numbers as unary minus" do
      scanner = TRuby::Scanner.new("-42")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      # Could be parsed as UnaryOp or negative Literal
      if result.value.is_a?(TRuby::IR::UnaryOp)
        expect(result.value.operator).to eq(:-)
      else
        expect(result.value).to be_a(TRuby::IR::Literal)
        expect(result.value.value).to eq(-42)
      end
    end
  end

  describe "method calls" do
    describe "simple method call" do
      let(:source) { "foo()" }

      it "parses method call without arguments" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodCall)
        expect(result.value.method_name).to eq("foo")
        expect(result.value.arguments).to be_empty
      end
    end

    describe "method call with arguments" do
      let(:source) { "foo(1, 2, 3)" }

      it "parses method call with arguments" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodCall)
        expect(result.value.method_name).to eq("foo")
        expect(result.value.arguments.length).to eq(3)
      end
    end

    describe "method call on receiver" do
      let(:source) { "obj.method(arg)" }

      it "parses method call with receiver" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodCall)
        expect(result.value.method_name).to eq("method")
        expect(result.value.receiver).to be_a(TRuby::IR::VariableRef)
        expect(result.value.receiver.name).to eq("obj")
      end
    end

    describe "chained method calls" do
      let(:source) { "a.b.c" }

      it "parses chained method calls" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodCall)
        expect(result.value.method_name).to eq("c")
        expect(result.value.receiver).to be_a(TRuby::IR::MethodCall)
        expect(result.value.receiver.method_name).to eq("b")
      end
    end
  end

  describe "array literals" do
    describe "empty array" do
      let(:source) { "[]" }

      it "parses empty array" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::ArrayLiteral)
        expect(result.value.elements).to be_empty
      end
    end

    describe "array with elements" do
      let(:source) { "[1, 2, 3]" }

      it "parses array with elements" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::ArrayLiteral)
        expect(result.value.elements.length).to eq(3)
      end
    end
  end

  describe "hash literals" do
    describe "empty hash" do
      let(:source) { "{}" }

      it "parses empty hash" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::HashLiteral)
        expect(result.value.pairs).to be_empty
      end
    end

    describe "hash with pairs" do
      let(:source) { "{ a: 1, b: 2 }" }

      it "parses hash with symbol keys" do
        result = parser.parse_expression(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::HashLiteral)
        expect(result.value.pairs.length).to eq(2)
      end
    end
  end

  describe "parenthesized expressions" do
    let(:source) { "(1 + 2)" }

    it "parses parenthesized expression" do
      result = parser.parse_expression(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::BinaryOp)
      expect(result.value.operator).to eq(:+)
    end

    it "respects parentheses for precedence override" do
      scanner = TRuby::Scanner.new("(1 + 2) * 3")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      # Should be parsed as (1 + 2) * 3
      expect(result.value.operator).to eq(:*)
      expect(result.value.left).to be_a(TRuby::IR::BinaryOp)
      expect(result.value.left.operator).to eq(:+)
    end
  end

  describe "complex expressions" do
    it "parses method call with binary operation" do
      scanner = TRuby::Scanner.new("foo(1 + 2)")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::MethodCall)
      expect(result.value.arguments[0]).to be_a(TRuby::IR::BinaryOp)
    end

    it "parses nested method calls" do
      scanner = TRuby::Scanner.new("foo(bar(1))")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::MethodCall)
      expect(result.value.arguments[0]).to be_a(TRuby::IR::MethodCall)
    end

    it "parses array access" do
      scanner = TRuby::Scanner.new("arr[0]")
      result = parser.parse_expression(scanner.scan_all, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::MethodCall)
      expect(result.value.method_name).to eq("[]")
    end
  end
end
`,
  "spec/t_ruby/generic_type_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::GenericTypeParser do
  describe "#parse" do
    it "parses simple type" do
      parser = described_class.new("String")
      result = parser.parse
      expect(result[:type]).to eq(:simple)
      expect(result[:value]).to eq("String")
    end

    it "parses generic type with single parameter" do
      parser = described_class.new("Array<String>")
      result = parser.parse
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Array")
      expect(result[:params]).to eq(["String"])
    end

    it "parses generic type with multiple parameters" do
      parser = described_class.new("Hash<String, Integer>")
      result = parser.parse
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Hash")
      expect(result[:params]).to eq(%w[String Integer])
    end

    it "parses nested generic types" do
      parser = described_class.new("Array<Array<String>>")
      result = parser.parse
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Array")
      expect(result[:params]).to eq(["Array<String>"])
    end

    it "parses deeply nested generic types" do
      parser = described_class.new("Hash<String, Array<Hash<Symbol, Integer>>>")
      result = parser.parse
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Hash")
      expect(result[:params]).to eq(["String", "Array<Hash<Symbol, Integer>>"])
    end

    it "handles whitespace" do
      parser = described_class.new("  Array< String >  ")
      result = parser.parse
      # NOTE: internal whitespace handling may vary
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Array")
    end

    it "treats malformed generic as simple type" do
      parser = described_class.new("Array<String")
      result = parser.parse
      expect(result[:type]).to eq(:simple)
    end

    it "parses generic with complex nested parameters" do
      parser = described_class.new("Result<Success<Data>, Error<String>>")
      result = parser.parse
      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Result")
      expect(result[:params]).to eq(["Success<Data>", "Error<String>"])
    end
  end
end
`,
  "spec/t_ruby/generics_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::GenericTypeParser do
  describe "parsing generic types" do
    it "parses simple generic type" do
      parser = TRuby::GenericTypeParser.new("Array<String>")
      result = parser.parse

      expect(result[:type]).to eq(:generic)
      expect(result[:base]).to eq("Array")
      expect(result[:params]).to eq(["String"])
    end

    it "parses generic with multiple type parameters" do
      parser = TRuby::GenericTypeParser.new("Map<String, Integer>")
      result = parser.parse

      expect(result[:base]).to eq("Map")
      expect(result[:params].length).to eq(2)
      expect(result[:params]).to include("String", "Integer")
    end

    it "parses nested generics" do
      parser = TRuby::GenericTypeParser.new("Array<Array<String>>")
      result = parser.parse

      expect(result[:base]).to eq("Array")
      expect(result[:params][0]).to eq("Array<String>")
    end

    it "identifies non-generic types" do
      parser = TRuby::GenericTypeParser.new("String")
      result = parser.parse

      expect(result[:type]).to eq(:simple)
    end
  end
end

describe TRuby::Parser do
  describe "parsing functions with generic types" do
    it "parses function with generic parameter" do
      source = "def process(items: Array<String>): String\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:params][0][:type]).to eq("Array<String>")
    end

    it "parses function with generic return type" do
      source = "def get_map(): Map<String, Integer>\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:return_type]).to eq("Map<String, Integer>")
    end
  end
end
`,
  "spec/t_ruby/grammar_error_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe "T-Ruby Grammar Error Detection" do
  # Valid type expressions that should be accepted
  VALID_TYPE_EXPRESSIONS = [
    "String",
    "Integer",
    "Boolean",
    "Array",
    "Hash",
    "Symbol",
    "void",
    "nil",
    "Array<String>",
    "Hash<String, Integer>",
    "String | Integer",
    "String | nil",
    "String?",
    "(String) -> Integer",
    "[String, Integer]",
    "Readable & Writable",
  ].freeze

  # Invalid type expressions categorized by error type
  INVALID_TYPE_EXPRESSIONS = {
    whitespace_in_type: [
      ["Str ing", "whitespace in type name"],
      ["Int eger", "whitespace in type name"],
      ["Array <String>", "space before generic bracket"],
      ["Array< String>", "space after generic bracket"],
      ["String | ", "trailing union operator"],
      ["| String", "leading union operator"],
      ["String &", "trailing intersection operator"],
    ],
    incomplete_type: [
      ["", "empty type"],
      ["Array<", "unclosed generic bracket"],
      ["Array<String", "missing closing bracket"],
      ["(String) ->", "missing return type in function type"],
      ["(String,) -> Integer", "trailing comma in params"],
      ["[String,]", "trailing comma in tuple"],
    ],
    invalid_syntax: [
      ["123String", "type starting with number"],
      ["String!", "exclamation mark in type"],
      ["String#Integer", "hash symbol in type"],
    ],
  }.freeze

  describe TRuby::ErrorHandler do
    describe "method return type validation" do
      context "valid return types" do
        %w[String Integer Boolean void nil].each do |type_expr|
          it "accepts valid return type: #{type_expr}" do
            source = "def test(): #{type_expr}\\nend"
            handler = TRuby::ErrorHandler.new(source)
            errors = handler.check

            # Filter out "Unknown return type" errors for complex types
            # since ErrorHandler only recognizes simple VALID_TYPES
            syntax_errors = errors.reject { |e| e.include?("Unknown") }
            expect(syntax_errors).to be_empty, "Expected no syntax errors for '#{type_expr}', got: #{syntax_errors}"
          end
        end
      end

      context "invalid return type syntax" do
        # Type with internal whitespace
        it "detects whitespace in type name: 'Str ing'" do
          source = "def test(): Str ing\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
          expect(errors.any? do |e|
            e.include?("whitespace") || e.include?("invalid") || e.include?("syntax") || e.include?("Unexpected")
          end).to be true
        end

        # Empty return type after colon
        it "detects missing type after colon" do
          source = "def test():\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
          expect(errors.any? do |e|
            e.include?("missing") || e.include?("empty") || e.include?("type") || e.include?("Expected")
          end).to be true
        end

        # Token after closing paren without colon
        it "detects invalid token after parameters without colon" do
          source = "def test() ndkdk\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
          expect(errors.any? do |e|
            e.include?("syntax") || e.include?("invalid") || e.include?("unexpected") || e.include?("Unexpected")
          end).to be true
        end

        # Incomplete generic type
        it "detects unclosed generic bracket" do
          source = "def test(): Array<String\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
        end

        # Trailing operator
        it "detects trailing union operator" do
          source = "def test(): String |\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
        end
      end
    end

    describe "parameter type validation" do
      context "valid parameter types" do
        [
          "def test(x: String)\\nend",
          "def test(x: Integer, y: Boolean)\\nend",
        ].each do |source|
          it "accepts: #{source.split("\\n").first}" do
            handler = TRuby::ErrorHandler.new(source)
            errors = handler.check
            syntax_errors = errors.reject { |e| e.include?("Unknown") }
            expect(syntax_errors).to be_empty
          end
        end
      end

      context "invalid parameter type syntax" do
        it "detects whitespace in parameter type" do
          source = "def test(x: Str ing)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
        end

        it "detects missing type after parameter colon" do
          source = "def test(x:)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).not_to be_empty
        end

        it "allows multiple spaces between param name and type" do
          # This should be valid, just has extra spacing
          source = "def test(x:    String)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check
          syntax_errors = errors.reject { |e| e.include?("Unknown") }
          expect(syntax_errors).to be_empty
        end
      end
    end

    describe "Ruby standard syntax compliance" do
      context "when no type annotation is provided" do
        it "accepts valid Ruby method without type annotations" do
          source = "def test(x, y)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).to be_empty
        end

        it "accepts method with no parameters" do
          source = "def test\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).to be_empty
        end

        it "accepts method with empty parentheses" do
          source = "def test()\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check

          expect(errors).to be_empty
        end
      end

      context "hybrid T-Ruby and Ruby syntax" do
        it "accepts mixed typed and untyped parameters" do
          source = "def test(x: String, y)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check
          syntax_errors = errors.reject { |e| e.include?("Unknown") }
          expect(syntax_errors).to be_empty
        end

        it "accepts typed parameters with untyped return" do
          source = "def test(x: String)\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check
          syntax_errors = errors.reject { |e| e.include?("Unknown") }
          expect(syntax_errors).to be_empty
        end
      end
    end

    describe "comprehensive syntax error categories" do
      # Category 1: Structural errors
      describe "structural errors" do
        [
          ["def test(x: String", "unclosed parenthesis"],
          ["def test x: String)", "missing opening parenthesis"],
          ["def (x: String)", "missing method name"],
        ].each do |(source, description)|
          it "detects #{description}" do
            handler = TRuby::ErrorHandler.new("#{source}\\nend")
            errors = handler.check
            # At minimum, parser should not accept this as valid
            expect(errors).to be_a(Array)
          end
        end
      end

      # Category 2: Type expression errors
      describe "type expression errors" do
        [
          ["def test(): Array<>\\nend", "empty generic arguments"],
          ["def test(): <String>\\nend", "missing base type for generic"],
          ["def test(): String | | Integer\\nend", "double union operator"],
          ["def test(): String & & Integer\\nend", "double intersection operator"],
        ].each do |(source, description)|
          it "detects #{description}" do
            handler = TRuby::ErrorHandler.new(source)
            errors = handler.check
            expect(errors).not_to be_empty, "Expected errors for: #{description}"
          end
        end
      end

      # Category 3: Position errors (type in wrong place)
      describe "position errors" do
        it "detects type-like token without colon separator" do
          source = "def test() String\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check
          expect(errors).not_to be_empty
        end

        it "detects random identifier after method signature" do
          source = "def test(): String something_else\\nend"
          handler = TRuby::ErrorHandler.new(source)
          errors = handler.check
          expect(errors).not_to be_empty
        end
      end
    end
  end

  describe TRuby::Parser do
    describe "parsing with grammar validation" do
      context "valid method definitions" do
        [
          "def greet(name: String): String\\n  'hello'\\nend",
          "def add(a: Integer, b: Integer): Integer\\n  a + b\\nend",
          "def process(items: Array<String>): void\\nend",
          "def maybe(value: String?): String | nil\\nend",
        ].each do |source|
          it "parses: #{source.split("\\n").first}" do
            parser = TRuby::Parser.new(source)
            result = parser.parse

            expect(result[:type]).to eq(:success)
            expect(result[:functions]).not_to be_empty
          end
        end
      end

      context "should reject invalid syntax" do
        it "rejects type with whitespace" do
          source = "def test(): Str ing\\nend"
          parser = TRuby::Parser.new(source)
          result = parser.parse

          # Parser should either:
          # 1. Return failure
          # 2. Return success but with parse errors noted
          # 3. Not include this as a valid function
          if result[:type] == :success && result[:functions].any?
            func = result[:functions].first
            # If parsed, the return type should indicate an error or be nil
            expect(func[:return_type]).to be_nil.or(eq("Str"))
          end
        end

        it "handles missing return type after colon gracefully" do
          source = "def test():\\nend"
          parser = TRuby::Parser.new(source)
          result = parser.parse

          # Should not crash, may or may not parse as valid
          expect(result).to be_a(Hash)
        end
      end
    end
  end

  describe "Integration: Parser + ErrorHandler" do
    # Test that parser output fed to error handler produces correct errors
    describe "combined validation" do
      it "detects all errors in malformed code" do
        source = <<~RUBY
          def good(x: String): Integer
            x.to_i
          end

          def bad_return(): Str ing
            "test"
          end

          def bad_param(x: Int eger): String
            x.to_s
          end

          def missing_type():
            nil
          end
        RUBY

        handler = TRuby::ErrorHandler.new(source)
        errors = handler.check

        # Should detect multiple errors
        expect(errors.length).to be >= 1
      end
    end
  end
end
`,
  "spec/t_ruby/heredoc_detector_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::HeredocDetector do
  describe ".detect" do
    it "detects simple heredoc" do
      lines = [
        "text = <<EOT",
        "Hello world",
        "EOT",
        "other_code",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([1..2])
    end

    it "detects heredoc with dash" do
      lines = [
        "text = <<-SQL",
        "  SELECT * FROM users",
        "SQL",
        "puts text",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([1..2])
    end

    it "detects squiggly heredoc" do
      lines = [
        "html = <<~HTML",
        "  <div>",
        "    <p>Hello</p>",
        "  </div>",
        "HTML",
        "render html",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([1..4])
    end

    it "detects multiple heredocs" do
      lines = [
        "a = <<A",
        "content a",
        "A",
        "b = <<B",
        "content b",
        "B",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([1..2, 4..5])
    end

    it "handles quoted delimiters" do
      lines = [
        "text = <<'EOF'",
        "literal content",
        "EOF",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([1..2])
    end

    it "detects =begin/=end block comments" do
      lines = [
        "=begin",
        "This is a comment",
        "def fake(x: String): Integer",
        "=end",
        "def real(): String",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([0..3])
    end

    it "detects multiple block comments" do
      lines = [
        "=begin",
        "first comment",
        "=end",
        "code_here",
        "=begin",
        "second comment",
        "=end",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([0..2, 4..6])
    end

    it "handles mixed heredocs and block comments" do
      lines = [
        "=begin",
        "comment",
        "=end",
        "text = <<EOT",
        "heredoc content",
        "EOT",
      ]
      ranges = described_class.detect(lines)

      expect(ranges).to eq([0..2, 4..5])
    end
  end

  describe ".inside_heredoc?" do
    let(:ranges) { [1..3, 5..7] }

    it "returns false for heredoc start line" do
      expect(described_class.inside_heredoc?(0, ranges)).to be false
    end

    it "returns true for lines inside heredoc" do
      expect(described_class.inside_heredoc?(1, ranges)).to be true
      expect(described_class.inside_heredoc?(2, ranges)).to be true
      expect(described_class.inside_heredoc?(3, ranges)).to be true
    end

    it "returns false for lines between heredocs" do
      expect(described_class.inside_heredoc?(4, ranges)).to be false
    end

    it "returns true for second heredoc content" do
      expect(described_class.inside_heredoc?(5, ranges)).to be true
      expect(described_class.inside_heredoc?(6, ranges)).to be true
    end

    it "returns false for lines after all heredocs" do
      expect(described_class.inside_heredoc?(8, ranges)).to be false
    end
  end
end
`,
  "spec/t_ruby/interface_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::Parser do
  describe "parsing interface definitions" do
    it "parses simple interface with single member" do
      source = "interface User" + "\\n  " \\
                                  "name: String" + "\\n" \\
                                                   "end"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces]).to be_a(Array)
      expect(result[:interfaces][0][:name]).to eq("User")
    end

    it "parses interface with multiple members" do
      source = "interface User" + "\\n  " \\
                                  "name: String" + "\\n  " \\
                                                   "age: Integer" + "\\n" \\
                                                                    "end"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      interface = result[:interfaces][0]
      expect(interface[:members].length).to eq(2)
    end

    it "parses interface member types correctly" do
      source = "interface User" + "\\n  " \\
                                  "name: String" + "\\n  " \\
                                                   "active: Boolean" + "\\n" \\
                                                                       "end"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      interface = result[:interfaces][0]
      expect(interface[:members][0][:name]).to eq("name")
      expect(interface[:members][0][:type]).to eq("String")
    end

    it "handles empty interface" do
      source = "interface Empty" + "\\n" \\
                                   "end"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces][0][:name]).to eq("Empty")
      expect(result[:interfaces][0][:members]).to be_a(Array)
    end
  end
end

describe TRuby::ErrorHandler do
  describe "interface validation" do
    it "detects duplicate interface definitions" do
      source = "interface User" + "\\n  " \\
                                  "name: String" + "\\n" \\
                                                   "end" + "\\n" \\
                                                           "interface User" + "\\n  " \\
                                                                              "age: Integer" + "\\n" \\
                                                                                               "end"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.any? { |e| e.include?("duplicate") || e.include?("User") }).to be true
    end

    it "accepts valid interface definitions" do
      source = "interface User" + "\\n  " \\
                                  "name: String" + "\\n  " \\
                                                   "age: Integer" + "\\n" \\
                                                                    "end"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors.to_s).not_to include("interface")
    end
  end
end
`,
  "spec/t_ruby/intersection_type_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::IntersectionTypeParser do
  describe "#parse" do
    it "parses simple type" do
      parser = described_class.new("String")
      result = parser.parse
      expect(result[:type]).to eq(:simple)
      expect(result[:value]).to eq("String")
    end

    it "parses intersection with two types" do
      parser = described_class.new("Readable & Writable")
      result = parser.parse
      expect(result[:type]).to eq(:intersection)
      expect(result[:members]).to eq(%w[Readable Writable])
    end

    it "parses intersection with multiple types" do
      parser = described_class.new("A & B & C & D")
      result = parser.parse
      expect(result[:type]).to eq(:intersection)
      expect(result[:members]).to eq(%w[A B C D])
    end

    it "detects duplicates" do
      parser = described_class.new("A & B & A")
      result = parser.parse
      expect(result[:has_duplicates]).to be true
      expect(result[:unique_members]).to eq(%w[A B])
    end

    it "reports no duplicates when none exist" do
      parser = described_class.new("A & B")
      result = parser.parse
      expect(result[:has_duplicates]).to be false
    end

    it "strips whitespace" do
      parser = described_class.new("  A  &  B  ")
      result = parser.parse
      expect(result[:members]).to eq(%w[A B])
    end
  end
end
`,
  "spec/t_ruby/intersection_type_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::IntersectionTypeParser do
  describe "parsing intersection types" do
    it "parses simple intersection type" do
      parser = TRuby::IntersectionTypeParser.new("Readable & Writable")
      result = parser.parse

      expect(result[:type]).to eq(:intersection)
      expect(result[:members]).to eq(%w[Readable Writable])
    end

    it "parses intersection with three or more types" do
      parser = TRuby::IntersectionTypeParser.new("Readable & Writable & Closeable")
      result = parser.parse

      expect(result[:members].length).to eq(3)
      expect(result[:members]).to include("Readable", "Writable", "Closeable")
    end

    it "handles whitespace around ampersands" do
      parser = TRuby::IntersectionTypeParser.new("Readable  &  Writable  &  Closeable")
      result = parser.parse

      expect(result[:members]).to eq(%w[Readable Writable Closeable])
    end

    it "identifies non-intersection types" do
      parser = TRuby::IntersectionTypeParser.new("Reader")
      result = parser.parse

      expect(result[:type]).to eq(:simple)
    end

    it "detects duplicate types in intersection" do
      parser = TRuby::IntersectionTypeParser.new("Readable & Readable & Writable")
      result = parser.parse

      expect(result[:has_duplicates]).to be true
    end
  end
end

describe TRuby::Parser do
  describe "parsing functions with intersection types" do
    it "parses function with intersection parameter" do
      source = "def process(obj: Readable & Writable): Boolean\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:params][0][:type]).to eq("Readable & Writable")
    end

    it "parses function with intersection return type" do
      source = "def get_stream(): Readable & Writable\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:return_type]).to eq("Readable & Writable")
    end
  end
end
`,
  "spec/t_ruby/ir_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::IR do
  describe TRuby::IR::Node do
    it "has location and metadata" do
      node = described_class.new(location: { line: 1, column: 0 })
      expect(node.location).to eq({ line: 1, column: 0 })
      expect(node.metadata).to eq({})
    end
  end

  describe TRuby::IR::Program do
    it "holds declarations" do
      alias_node = TRuby::IR::TypeAlias.new(
        name: "UserId",
        definition: TRuby::IR::SimpleType.new(name: "String")
      )
      program = described_class.new(declarations: [alias_node])

      expect(program.declarations.length).to eq(1)
      expect(program.children).to eq([alias_node])
    end
  end

  describe TRuby::IR::SimpleType do
    it "converts to RBS format" do
      type = described_class.new(name: "String")
      expect(type.to_rbs).to eq("String")
      expect(type.to_trb).to eq("String")
    end
  end

  describe TRuby::IR::GenericType do
    it "converts to RBS format" do
      inner = TRuby::IR::SimpleType.new(name: "String")
      type = described_class.new(base: "Array", type_args: [inner])

      expect(type.to_rbs).to eq("Array[String]")
      expect(type.to_trb).to eq("Array<String>")
    end

    it "handles multiple type arguments" do
      key = TRuby::IR::SimpleType.new(name: "String")
      value = TRuby::IR::SimpleType.new(name: "Integer")
      type = described_class.new(base: "Hash", type_args: [key, value])

      expect(type.to_rbs).to eq("Hash[String, Integer]")
      expect(type.to_trb).to eq("Hash<String, Integer>")
    end
  end

  describe TRuby::IR::UnionType do
    it "converts to RBS format" do
      string_type = TRuby::IR::SimpleType.new(name: "String")
      nil_type = TRuby::IR::SimpleType.new(name: "nil")
      type = described_class.new(types: [string_type, nil_type])

      expect(type.to_rbs).to eq("String | nil")
      expect(type.to_trb).to eq("String | nil")
    end
  end

  describe TRuby::IR::IntersectionType do
    it "converts to RBS format" do
      readable = TRuby::IR::SimpleType.new(name: "Readable")
      writable = TRuby::IR::SimpleType.new(name: "Writable")
      type = described_class.new(types: [readable, writable])

      expect(type.to_rbs).to eq("Readable & Writable")
      expect(type.to_trb).to eq("Readable & Writable")
    end
  end

  describe TRuby::IR::FunctionType do
    it "converts to RBS format" do
      param = TRuby::IR::SimpleType.new(name: "String")
      ret = TRuby::IR::SimpleType.new(name: "Integer")
      type = described_class.new(param_types: [param], return_type: ret)

      expect(type.to_rbs).to eq("^(String) -> Integer")
      expect(type.to_trb).to eq("(String) -> Integer")
    end
  end

  describe TRuby::IR::NullableType do
    it "converts to RBS format" do
      inner = TRuby::IR::SimpleType.new(name: "String")
      type = described_class.new(inner_type: inner)

      expect(type.to_rbs).to eq("String?")
      expect(type.to_trb).to eq("String?")
    end
  end

  describe TRuby::IR::TupleType do
    it "converts to RBS format" do
      string_type = TRuby::IR::SimpleType.new(name: "String")
      int_type = TRuby::IR::SimpleType.new(name: "Integer")
      type = described_class.new(element_types: [string_type, int_type])

      expect(type.to_rbs).to eq("[String, Integer]")
      expect(type.to_trb).to eq("[String, Integer]")
    end
  end

  describe TRuby::IR::Builder do
    let(:builder) { described_class.new }

    describe "#build" do
      it "builds program from parse result" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "UserId", definition: "String" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)

        expect(program).to be_a(TRuby::IR::Program)
        expect(program.declarations.length).to eq(1)
        expect(program.declarations.first).to be_a(TRuby::IR::TypeAlias)
      end

      it "builds type aliases with correct type" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "UserId", definition: "String" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.name).to eq("UserId")
        expect(alias_node.definition).to be_a(TRuby::IR::SimpleType)
        expect(alias_node.definition.name).to eq("String")
      end

      it "builds union types" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "StringOrNil", definition: "String | nil" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.definition).to be_a(TRuby::IR::UnionType)
        expect(alias_node.definition.types.length).to eq(2)
      end

      it "builds generic types" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "StringArray", definition: "Array<String>" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.definition).to be_a(TRuby::IR::GenericType)
        expect(alias_node.definition.base).to eq("Array")
        expect(alias_node.definition.type_args.length).to eq(1)
      end

      it "builds nested generic types" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "Matrix", definition: "Array<Array<Integer>>" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.definition).to be_a(TRuby::IR::GenericType)
        expect(alias_node.definition.type_args.first).to be_a(TRuby::IR::GenericType)
      end

      it "builds interfaces" do
        parse_result = {
          type: :success,
          type_aliases: [],
          interfaces: [{
            name: "Serializable",
            members: [
              { name: "to_json", type: "String" },
            ],
          }],
          functions: [],
        }

        program = builder.build(parse_result)
        interface = program.declarations.first

        expect(interface).to be_a(TRuby::IR::Interface)
        expect(interface.name).to eq("Serializable")
        expect(interface.members.length).to eq(1)
        expect(interface.members.first.name).to eq("to_json")
      end

      it "builds methods with parameters" do
        parse_result = {
          type: :success,
          type_aliases: [],
          interfaces: [],
          functions: [{
            name: "greet",
            params: [
              { name: "name", type: "String" },
            ],
            return_type: "String",
          }],
        }

        program = builder.build(parse_result)
        method = program.declarations.first

        expect(method).to be_a(TRuby::IR::MethodDef)
        expect(method.name).to eq("greet")
        expect(method.params.length).to eq(1)
        expect(method.params.first.name).to eq("name")
        expect(method.return_type).to be_a(TRuby::IR::SimpleType)
      end

      it "builds function types" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "Callback", definition: "(String) -> Integer" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.definition).to be_a(TRuby::IR::FunctionType)
        expect(alias_node.definition.param_types.length).to eq(1)
        expect(alias_node.definition.return_type.name).to eq("Integer")
      end

      it "builds nullable types" do
        parse_result = {
          type: :success,
          type_aliases: [{ name: "MaybeString", definition: "String?" }],
          interfaces: [],
          functions: [],
        }

        program = builder.build(parse_result)
        alias_node = program.declarations.first

        expect(alias_node.definition).to be_a(TRuby::IR::NullableType)
        expect(alias_node.definition.inner_type.name).to eq("String")
      end
    end

    describe "#build_from_source" do
      it "parses source and builds IR" do
        source = <<~TRB
          type UserId = String

          def greet(name: String): String
          end
        TRB

        program = builder.build_from_source(source)

        expect(program.declarations.length).to eq(2)
        expect(program.declarations[0]).to be_a(TRuby::IR::TypeAlias)
        expect(program.declarations[1]).to be_a(TRuby::IR::MethodDef)
      end
    end
  end

  describe TRuby::IR::CodeGenerator do
    let(:generator) { described_class.new }

    it "generates Ruby code from method definition" do
      method = TRuby::IR::MethodDef.new(
        name: "greet",
        params: [TRuby::IR::Parameter.new(name: "name")]
      )
      program = TRuby::IR::Program.new(declarations: [method])

      output = generator.generate(program)

      expect(output).to include("def greet(name)")
      expect(output).to include("end")
    end

    it "generates comments for type aliases" do
      type_alias = TRuby::IR::TypeAlias.new(
        name: "UserId",
        definition: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [type_alias])

      output = generator.generate(program)

      expect(output).to include("# type UserId = String")
    end
  end

  describe TRuby::IR::RBSGenerator do
    let(:generator) { described_class.new }

    it "generates RBS type alias" do
      type_alias = TRuby::IR::TypeAlias.new(
        name: "UserId",
        definition: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [type_alias])

      output = generator.generate(program)

      expect(output).to include("type UserId = String")
    end

    it "generates RBS interface" do
      interface = TRuby::IR::Interface.new(
        name: "Serializable",
        members: [
          TRuby::IR::InterfaceMember.new(
            name: "to_json",
            type_signature: TRuby::IR::SimpleType.new(name: "String")
          ),
        ]
      )
      program = TRuby::IR::Program.new(declarations: [interface])

      output = generator.generate(program)

      expect(output).to include("interface _Serializable")
      expect(output).to include("def to_json: String")
      expect(output).to include("end")
    end

    it "generates RBS method signature" do
      method = TRuby::IR::MethodDef.new(
        name: "greet",
        params: [
          TRuby::IR::Parameter.new(
            name: "name",
            type_annotation: TRuby::IR::SimpleType.new(name: "String")
          ),
        ],
        return_type: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [method])

      output = generator.generate(program)

      expect(output).to include("def greet: (name: String) -> String")
    end
  end

  describe TRuby::IR::Passes::DeadCodeElimination do
    let(:pass) { described_class.new }

    it "removes code after return statement" do
      statements = [
        TRuby::IR::Return.new(value: TRuby::IR::Literal.new(value: 1, literal_type: :integer)),
        TRuby::IR::Assignment.new(
          target: "x",
          value: TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        ),
      ]

      block = TRuby::IR::Block.new(statements: statements)
      method = TRuby::IR::MethodDef.new(name: "test", body: block)
      program = TRuby::IR::Program.new(declarations: [method])

      result = pass.run(program)

      expect(result[:changes]).to eq(1)
      expect(method.body.statements.length).to eq(1)
    end
  end

  describe TRuby::IR::Passes::ConstantFolding do
    let(:pass) { described_class.new }

    it "folds constant arithmetic expressions" do
      expr = TRuby::IR::BinaryOp.new(
        operator: "+",
        left: TRuby::IR::Literal.new(value: 2, literal_type: :integer),
        right: TRuby::IR::Literal.new(value: 3, literal_type: :integer)
      )

      ret = TRuby::IR::Return.new(value: expr)
      block = TRuby::IR::Block.new(statements: [ret])
      method = TRuby::IR::MethodDef.new(name: "test", body: block)
      program = TRuby::IR::Program.new(declarations: [method])

      result = pass.run(program)

      expect(result[:changes]).to eq(1)
      expect(method.body.statements.first.value).to be_a(TRuby::IR::Literal)
      expect(method.body.statements.first.value.value).to eq(5)
    end

    it "folds multiplication" do
      expr = TRuby::IR::BinaryOp.new(
        operator: "*",
        left: TRuby::IR::Literal.new(value: 4, literal_type: :integer),
        right: TRuby::IR::Literal.new(value: 5, literal_type: :integer)
      )

      ret = TRuby::IR::Return.new(value: expr)
      block = TRuby::IR::Block.new(statements: [ret])
      method = TRuby::IR::MethodDef.new(name: "test", body: block)
      program = TRuby::IR::Program.new(declarations: [method])

      pass.run(program)

      expect(method.body.statements.first.value.value).to eq(20)
    end

    it "does not fold division by zero" do
      expr = TRuby::IR::BinaryOp.new(
        operator: "/",
        left: TRuby::IR::Literal.new(value: 10, literal_type: :integer),
        right: TRuby::IR::Literal.new(value: 0, literal_type: :integer)
      )

      ret = TRuby::IR::Return.new(value: expr)
      block = TRuby::IR::Block.new(statements: [ret])
      method = TRuby::IR::MethodDef.new(name: "test", body: block)
      program = TRuby::IR::Program.new(declarations: [method])

      result = pass.run(program)

      expect(result[:changes]).to eq(0)
      expect(method.body.statements.first.value).to be_a(TRuby::IR::BinaryOp)
    end
  end

  describe TRuby::IR::Optimizer do
    let(:optimizer) { described_class.new }

    it "runs multiple optimization passes" do
      statements = [
        TRuby::IR::Return.new(
          value: TRuby::IR::BinaryOp.new(
            operator: "+",
            left: TRuby::IR::Literal.new(value: 2, literal_type: :integer),
            right: TRuby::IR::Literal.new(value: 3, literal_type: :integer)
          )
        ),
        TRuby::IR::Assignment.new(
          target: "x",
          value: TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        ),
      ]

      block = TRuby::IR::Block.new(statements: statements)
      method = TRuby::IR::MethodDef.new(name: "test", body: block)
      program = TRuby::IR::Program.new(declarations: [method])

      result = optimizer.optimize(program)

      expect(result[:stats][:total_changes]).to be > 0
      expect(method.body.statements.length).to eq(1)
      expect(method.body.statements.first.value.value).to eq(5)
    end

    it "returns optimization statistics" do
      program = TRuby::IR::Program.new(declarations: [])

      result = optimizer.optimize(program)

      expect(result[:stats]).to have_key(:iterations)
      expect(result[:stats]).to have_key(:total_changes)
      expect(result[:stats]).to have_key(:pass_stats)
    end

    it "stops when no more changes" do
      program = TRuby::IR::Program.new(declarations: [])

      result = optimizer.optimize(program, max_iterations: 100)

      expect(result[:stats][:iterations]).to be < 100
    end
  end

  describe TRuby::IR::Visitor do
    it "visits nodes with visitor pattern" do
      visited = []

      visitor = Class.new(TRuby::IR::Visitor) do
        define_method(:visit_type_alias) do |node|
          visited << node.name
        end
      end.new

      type_alias = TRuby::IR::TypeAlias.new(
        name: "Test",
        definition: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [type_alias])

      visitor.visit(program)

      expect(visited).to eq(["Test"])
    end
  end

  # Additional coverage tests for Node methods
  describe "Node methods" do
    describe TRuby::IR::Node do
      it "accepts visitor" do
        visitor = double("Visitor")
        node = described_class.new
        expect(visitor).to receive(:visit).with(node)
        node.accept(visitor)
      end

      it "returns empty children by default" do
        node = described_class.new
        expect(node.children).to eq([])
      end

      it "transforms with block" do
        node = described_class.new
        result = node.transform { |_n| "transformed" }
        expect(result).to eq("transformed")
      end
    end

    describe TRuby::IR::Interface do
      it "returns members as children" do
        member = TRuby::IR::InterfaceMember.new(
          name: "method1",
          type_signature: TRuby::IR::SimpleType.new(name: "String")
        )
        interface = described_class.new(name: "Test", members: [member])
        expect(interface.children).to eq([member])
      end
    end

    describe TRuby::IR::ClassDecl do
      it "returns body as children" do
        method = TRuby::IR::MethodDef.new(name: "foo")
        class_decl = described_class.new(name: "MyClass", body: [method])
        expect(class_decl.children).to eq([method])
      end
    end

    describe TRuby::IR::ModuleDecl do
      it "returns body as children" do
        method = TRuby::IR::MethodDef.new(name: "helper")
        module_decl = described_class.new(name: "Helpers", body: [method])
        expect(module_decl.children).to eq([method])
      end
    end

    describe TRuby::IR::MethodDef do
      it "returns body as children when present" do
        body = TRuby::IR::Block.new(statements: [])
        method = described_class.new(name: "test", body: body)
        expect(method.children).to eq([body])
      end

      it "returns empty array when body is nil" do
        method = described_class.new(name: "test", body: nil)
        expect(method.children).to eq([])
      end
    end

    describe TRuby::IR::Block do
      it "returns statements as children" do
        stmt1 = TRuby::IR::Return.new
        stmt2 = TRuby::IR::Return.new
        block = described_class.new(statements: [stmt1, stmt2])
        expect(block.children).to eq([stmt1, stmt2])
      end
    end

    describe TRuby::IR::Assignment do
      it "returns value as children" do
        value = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
        assignment = described_class.new(target: "x", value: value)
        expect(assignment.children).to eq([value])
      end
    end

    describe TRuby::IR::MethodCall do
      it "returns receiver, block and arguments as children" do
        receiver = TRuby::IR::VariableRef.new(name: "obj")
        arg = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        block = TRuby::IR::Block.new
        call = described_class.new(
          receiver: receiver,
          method_name: "foo",
          arguments: [arg],
          block: block
        )
        expect(call.children).to include(receiver, block, arg)
      end
    end

    describe TRuby::IR::InterpolatedString do
      it "returns parts as children" do
        part1 = TRuby::IR::Literal.new(value: "hello ", literal_type: :string)
        part2 = TRuby::IR::VariableRef.new(name: "name")
        str = described_class.new(parts: [part1, part2])
        expect(str.children).to eq([part1, part2])
      end
    end

    describe TRuby::IR::ArrayLiteral do
      it "returns elements as children" do
        elem1 = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        elem2 = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        arr = described_class.new(elements: [elem1, elem2])
        expect(arr.children).to eq([elem1, elem2])
      end
    end

    describe TRuby::IR::HashPair do
      it "returns key and value as children" do
        key = TRuby::IR::Literal.new(value: :foo, literal_type: :symbol)
        value = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        pair = described_class.new(key: key, value: value)
        expect(pair.children).to eq([key, value])
      end
    end

    describe TRuby::IR::Conditional do
      it "returns condition, then_branch, and else_branch as children" do
        condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
        then_branch = TRuby::IR::Return.new
        else_branch = TRuby::IR::Return.new
        cond = described_class.new(
          condition: condition,
          then_branch: then_branch,
          else_branch: else_branch
        )
        expect(cond.children).to eq([condition, then_branch, else_branch])
      end
    end

    describe TRuby::IR::CaseExpr do
      it "returns subject, else_clause, and when_clauses as children" do
        subject = TRuby::IR::VariableRef.new(name: "x")
        when_clause = TRuby::IR::WhenClause.new(
          patterns: [TRuby::IR::Literal.new(value: 1, literal_type: :integer)],
          body: TRuby::IR::Return.new
        )
        else_clause = TRuby::IR::Return.new
        case_expr = described_class.new(
          subject: subject,
          when_clauses: [when_clause],
          else_clause: else_clause
        )
        expect(case_expr.children).to include(subject, else_clause, when_clause)
      end
    end

    describe TRuby::IR::WhenClause do
      it "returns body and patterns as children" do
        pattern = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        body = TRuby::IR::Return.new
        when_clause = described_class.new(patterns: [pattern], body: body)
        expect(when_clause.children).to include(body, pattern)
      end
    end

    describe TRuby::IR::Loop do
      it "returns condition and body as children" do
        condition = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
        body = TRuby::IR::Block.new
        loop_node = described_class.new(kind: :while, condition: condition, body: body)
        expect(loop_node.children).to eq([condition, body])
      end
    end

    describe TRuby::IR::ForLoop do
      it "returns iterable and body as children" do
        iterable = TRuby::IR::VariableRef.new(name: "arr")
        body = TRuby::IR::Block.new
        for_loop = described_class.new(variable: "x", iterable: iterable, body: body)
        expect(for_loop.children).to eq([iterable, body])
      end
    end

    describe TRuby::IR::Return do
      it "returns value as children when present" do
        value = TRuby::IR::Literal.new(value: 42, literal_type: :integer)
        ret = described_class.new(value: value)
        expect(ret.children).to eq([value])
      end

      it "returns empty array when value is nil" do
        ret = described_class.new(value: nil)
        expect(ret.children).to eq([])
      end
    end

    describe TRuby::IR::BinaryOp do
      it "returns left and right as children" do
        left = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
        right = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        op = described_class.new(operator: "+", left: left, right: right)
        expect(op.children).to eq([left, right])
      end
    end

    describe TRuby::IR::UnaryOp do
      it "returns operand as children" do
        operand = TRuby::IR::Literal.new(value: true, literal_type: :boolean)
        op = described_class.new(operator: "!", operand: operand)
        expect(op.children).to eq([operand])
      end
    end

    describe TRuby::IR::TypeCast do
      it "returns expression as children" do
        expr = TRuby::IR::VariableRef.new(name: "x")
        cast = described_class.new(
          expression: expr,
          target_type: TRuby::IR::SimpleType.new(name: "String")
        )
        expect(cast.children).to eq([expr])
      end
    end

    describe TRuby::IR::TypeGuard do
      it "returns expression as children" do
        expr = TRuby::IR::VariableRef.new(name: "x")
        guard = described_class.new(expression: expr, type_check: "String")
        expect(guard.children).to eq([expr])
      end
    end

    describe TRuby::IR::Lambda do
      it "returns body as children" do
        body = TRuby::IR::Block.new
        lambda_node = described_class.new(body: body)
        expect(lambda_node.children).to eq([body])
      end
    end

    describe TRuby::IR::BeginBlock do
      it "returns body, clauses as children" do
        body = TRuby::IR::Block.new
        rescue_clause = TRuby::IR::RescueClause.new(body: TRuby::IR::Block.new)
        else_clause = TRuby::IR::Block.new
        ensure_clause = TRuby::IR::Block.new
        begin_block = described_class.new(
          body: body,
          rescue_clauses: [rescue_clause],
          else_clause: else_clause,
          ensure_clause: ensure_clause
        )
        expect(begin_block.children).to include(body, else_clause, ensure_clause, rescue_clause)
      end
    end

    describe TRuby::IR::RescueClause do
      it "returns body as children" do
        body = TRuby::IR::Block.new
        rescue_clause = described_class.new(body: body)
        expect(rescue_clause.children).to eq([body])
      end
    end
  end

  # TypeNode base class
  describe TRuby::IR::TypeNode do
    it "raises NotImplementedError for to_rbs" do
      node = described_class.new
      expect { node.to_rbs }.to raise_error(NotImplementedError)
    end

    it "raises NotImplementedError for to_trb" do
      node = described_class.new
      expect { node.to_trb }.to raise_error(NotImplementedError)
    end
  end

  # LiteralType
  describe TRuby::IR::LiteralType do
    it "converts to RBS format" do
      type = described_class.new(value: "hello")
      expect(type.to_rbs).to eq('"hello"')
    end

    it "converts to TRB format" do
      type = described_class.new(value: 42)
      expect(type.to_trb).to eq("42")
    end
  end

  # HashLiteralType
  describe TRuby::IR::HashLiteralType do
    it "converts to RBS format" do
      type = described_class.new(
        fields: [{ name: "foo", type: TRuby::IR::SimpleType.new(name: "String") }]
      )
      expect(type.to_rbs).to eq("Hash[Symbol, untyped]")
    end

    it "converts to TRB format" do
      type = described_class.new(
        fields: [
          { name: "foo", type: TRuby::IR::SimpleType.new(name: "String") },
          { name: "bar", type: TRuby::IR::SimpleType.new(name: "Integer") },
        ]
      )
      expect(type.to_trb).to eq("{ foo: String, bar: Integer }")
    end
  end

  # Visitor class
  describe TRuby::IR::Visitor do
    it "visits children when method not defined" do
      visitor = TRuby::IR::Visitor.new
      stmt = TRuby::IR::Return.new(value: TRuby::IR::Literal.new(value: 1, literal_type: :integer))
      block = TRuby::IR::Block.new(statements: [stmt])

      # Should not raise
      visitor.visit(block)
    end

    it "visit_children visits all children" do
      visited = []
      visitor = Class.new(TRuby::IR::Visitor) do
        define_method(:visit_literal) do |node|
          visited << node.value
        end
      end.new

      stmt1 = TRuby::IR::Literal.new(value: 1, literal_type: :integer)
      stmt2 = TRuby::IR::Literal.new(value: 2, literal_type: :integer)
      block = TRuby::IR::Block.new(statements: [stmt1, stmt2])

      visitor.visit_children(block)
      expect(visited).to eq([1, 2])
    end
  end
end
`,
  "spec/t_ruby/lsp_server_spec.rb": `# frozen_string_literal: true

require "spec_helper"
require "stringio"

RSpec.describe TRuby::LSPServer do
  let(:input) { StringIO.new }
  let(:output) { StringIO.new }
  let(:server) { described_class.new(input: input, output: output) }

  # Helper to create LSP messages
  def create_message(content)
    json = JSON.generate(content)
    "Content-Length: #{json.bytesize}\\r\\n\\r\\n#{json}"
  end

  # Helper to send a message and get response
  def send_request(method, params = {}, id: 1)
    message = {
      "jsonrpc" => "2.0",
      "id" => id,
      "method" => method,
      "params" => params,
    }
    input.string = create_message(message)
    input.rewind

    server.handle_message(server.read_message)
  end

  # Helper to send notification (no id)
  def send_notification(method, params = {})
    message = {
      "jsonrpc" => "2.0",
      "method" => method,
      "params" => params,
    }
    input.string = create_message(message)
    input.rewind

    server.handle_message(server.read_message)
  end

  describe "message parsing" do
    it "reads LSP messages correctly" do
      message_content = { "jsonrpc" => "2.0", "id" => 1, "method" => "test" }
      input.string = create_message(message_content)
      input.rewind

      result = server.read_message
      expect(result).to eq(message_content)
    end

    it "handles empty input gracefully" do
      input.string = ""
      input.rewind

      result = server.read_message
      expect(result).to be_nil
    end
  end

  describe "initialize" do
    it "returns server capabilities" do
      response = send_request("initialize", {
                                "processId" => 1234,
                                "rootUri" => "file:///project",
                                "capabilities" => {},
                              })

      expect(response["result"]["capabilities"]).to include(
        "textDocumentSync" => hash_including("openClose" => true),
        "completionProvider" => hash_including("triggerCharacters" => [":", "<", "|", "&"]),
        "hoverProvider" => true,
        "definitionProvider" => true
      )
    end

    it "returns server info" do
      response = send_request("initialize", {})

      expect(response["result"]["serverInfo"]).to eq({
                                                       "name" => "t-ruby-lsp",
                                                       "version" => TRuby::LSPServer::VERSION,
                                                     })
    end
  end

  describe "initialized" do
    it "accepts initialized notification" do
      # First initialize
      send_request("initialize", {})

      # Then initialized notification
      result = send_notification("initialized", {})
      expect(result).to be_nil
    end
  end

  describe "shutdown" do
    it "responds to shutdown request" do
      send_request("initialize", {})
      response = send_request("shutdown")

      expect(response["result"]).to be_nil
      expect(response["error"]).to be_nil
    end
  end

  describe "server not initialized error" do
    it "returns error for requests before initialization" do
      response = send_request("textDocument/completion", {})

      expect(response["error"]["code"]).to eq(TRuby::LSPServer::ErrorCodes::SERVER_NOT_INITIALIZED)
    end
  end

  describe "textDocument/didOpen" do
    before { send_request("initialize", {}) }

    it "stores opened document" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "languageId" => "t-ruby",
                            "version" => 1,
                            "text" => "def hello(name: String): String\\nend",
                          },
                        })

      # Verify document was stored by checking hover works
      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 4 },
                              })

      expect(response["result"]).not_to be_nil
    end
  end

  describe "textDocument/didChange" do
    before do
      send_request("initialize", {})
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def old(): void\\nend",
                          },
                        })
    end

    it "updates document content" do
      send_notification("textDocument/didChange", {
                          "textDocument" => { "uri" => "file:///test.trb", "version" => 2 },
                          "contentChanges" => [{ "text" => "def new_function(): String\\nend" }],
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 4 },
                              })

      expect(response["result"]["contents"]["value"]).to include("new_function")
    end
  end

  describe "textDocument/didClose" do
    before do
      send_request("initialize", {})
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def hello(): void\\nend",
                          },
                        })
    end

    it "removes document from storage" do
      send_notification("textDocument/didClose", {
                          "textDocument" => { "uri" => "file:///test.trb" },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 0 },
                              })

      expect(response["result"]).to be_nil
    end
  end

  describe "textDocument/completion" do
    before do
      send_request("initialize", {})
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "type UserId = String\\ndef get_user(id: ): UserId\\nend",
                          },
                        })
    end

    it "provides built-in type completions after colon" do
      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 1, "character" => 17 }, # After "id: "
                              })

      items = response["result"]["items"]
      labels = items.map { |i| i["label"] }

      expect(labels).to include("String", "Integer", "Boolean", "Array", "Hash")
    end

    it "includes type aliases in completions" do
      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 1, "character" => 17 },
                              })

      items = response["result"]["items"]
      labels = items.map { |i| i["label"] }

      expect(labels).to include("UserId")
    end

    it "provides keyword completions at line start" do
      send_notification("textDocument/didChange", {
                          "textDocument" => { "uri" => "file:///test.trb", "version" => 2 },
                          "contentChanges" => [{ "text" => "" }],
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 0 },
                              })

      items = response["result"]["items"]
      labels = items.map { |i| i["label"] }

      expect(labels).to include("type", "interface", "def", "end")
    end
  end

  describe "textDocument/hover" do
    before do
      send_request("initialize", {})
    end

    it "shows hover info for built-in types" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(name: String): Integer\\nend",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 16 }, # On "String"
                              })

      expect(response["result"]["contents"]["value"]).to include("String")
      expect(response["result"]["contents"]["value"]).to include("Built-in")
    end

    it "shows hover info for type aliases" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "type UserId = String\\ndef get(id: UserId): String\\nend",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 6 }, # On "UserId"
                              })

      expect(response["result"]["contents"]["value"]).to include("Type Alias")
      expect(response["result"]["contents"]["value"]).to include("UserId")
    end

    it "shows hover info for functions" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def greet(name: String): String\\n  \\"Hello\\"\\nend",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 5 }, # On "greet"
                              })

      expect(response["result"]["contents"]["value"]).to include("Function")
      expect(response["result"]["contents"]["value"]).to include("greet")
    end

    it "shows hover info for interfaces" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "interface Printable\\n  to_string: String\\nend",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 11 }, # On "Printable"
                              })

      expect(response["result"]["contents"]["value"]).to include("Interface")
      expect(response["result"]["contents"]["value"]).to include("Printable")
    end

    it "returns nil for unknown words" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "unknown_symbol",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 5 },
                              })

      expect(response["result"]).to be_nil
    end
  end

  describe "textDocument/definition" do
    before do
      send_request("initialize", {})
    end

    it "finds type alias definition" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "type UserId = String\\ndef get(id: UserId): String\\nend",
                          },
                        })

      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 1, "character" => 13 }, # On "UserId"
                              })

      expect(response["result"]["uri"]).to eq("file:///test.trb")
      expect(response["result"]["range"]["start"]["line"]).to eq(0)
    end

    it "finds interface definition" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "interface Readable\\n  read: String\\nend\\ndef process(r: Readable): void\\nend",
                          },
                        })

      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 3, "character" => 17 }, # On "Readable"
                              })

      expect(response["result"]["uri"]).to eq("file:///test.trb")
      expect(response["result"]["range"]["start"]["line"]).to eq(0)
    end

    it "finds function definition" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def helper(): String\\n  \\"help\\"\\nend\\ndef main(): void\\n  helper()\\nend",
                          },
                        })

      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 4, "character" => 3 }, # On "helper"
                              })

      expect(response["result"]["uri"]).to eq("file:///test.trb")
      expect(response["result"]["range"]["start"]["line"]).to eq(0)
    end
  end

  describe "diagnostics" do
    before do
      send_request("initialize", {})
    end

    it "publishes diagnostics on document open" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(name: UnknownType): String\\nend",
                          },
                        })

      # Check that diagnostics were published
      output.rewind
      response_text = output.read

      expect(response_text).to include("publishDiagnostics")
    end

    it "detects duplicate function definitions" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def hello(): void\\nend\\ndef hello(): void\\nend",
                          },
                        })

      output.rewind
      response_text = output.read

      expect(response_text).to include("already defined")
    end

    it "detects invalid parameter syntax" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(: String): void\\nend",
                          },
                        })

      output.rewind
      response_text = output.read

      expect(response_text).to include("Invalid parameter syntax")
    end

    it "clears diagnostics on document close" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def hello(): void\\nend",
                          },
                        })

      # Create a new output buffer to capture close notification
      new_output = StringIO.new
      new_output.set_encoding("UTF-8")
      server.instance_variable_set(:@output, new_output)

      send_notification("textDocument/didClose", {
                          "textDocument" => { "uri" => "file:///test.trb" },
                        })

      new_output.rewind
      response_text = new_output.read

      expect(response_text).to include("publishDiagnostics")
      expect(response_text).to include('"diagnostics":[]')
    end

    it "responds to pull-based diagnostic requests" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(name: UnknownType): String\\nend",
                          },
                        })

      response = send_request("textDocument/diagnostic", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                              })

      expect(response["result"]["kind"]).to eq("full")
      expect(response["result"]["items"]).to be_an(Array)
      expect(response["result"]["items"].length).to be > 0
    end

    it "returns empty diagnostics for valid code via pull request" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///valid.trb",
                            "version" => 1,
                            "text" => "def greet(name: String): String\\n  name\\nend",
                          },
                        })

      response = send_request("textDocument/diagnostic", {
                                "textDocument" => { "uri" => "file:///valid.trb" },
                              })

      expect(response["result"]["kind"]).to eq("full")
      expect(response["result"]["items"]).to eq([])
    end

    it "returns empty diagnostics for unknown document" do
      response = send_request("textDocument/diagnostic", {
                                "textDocument" => { "uri" => "file:///unknown.trb" },
                              })

      expect(response["result"]["kind"]).to eq("full")
      expect(response["result"]["items"]).to eq([])
    end
  end

  describe "error handling" do
    before { send_request("initialize", {}) }

    it "returns method not found for unknown methods" do
      response = send_request("unknownMethod", {})

      expect(response["error"]["code"]).to eq(TRuby::LSPServer::ErrorCodes::METHOD_NOT_FOUND)
      expect(response["error"]["message"]).to include("unknownMethod")
    end

    it "handles malformed JSON gracefully" do
      input.string = "Content-Length: 10\\r\\n\\r\\n{invalid}"
      input.rewind

      message = server.read_message
      expect(message).to have_key("error")
    end
  end

  describe "response format" do
    before { send_request("initialize", {}) }

    it "includes jsonrpc version in responses" do
      response = send_request("shutdown")

      expect(response["jsonrpc"]).to eq("2.0")
    end

    it "includes request id in responses" do
      response = send_request("shutdown", {}, id: 42)

      expect(response["id"]).to eq(42)
    end
  end

  describe "textDocument/semanticTokens/full" do
    before do
      send_request("initialize", {})
    end

    it "returns semantic tokens for type aliases" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "type UserId = String",
                          },
                        })

      response = send_request("textDocument/semanticTokens/full", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                              })

      expect(response["result"]["data"]).to be_an(Array)
    end

    it "returns semantic tokens for interfaces" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "interface Printable\\n  to_s: String\\nend",
                          },
                        })

      response = send_request("textDocument/semanticTokens/full", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                              })

      expect(response["result"]["data"]).to be_an(Array)
    end

    it "returns semantic tokens for functions" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def greet(name: String): void\\n  puts name\\nend",
                          },
                        })

      response = send_request("textDocument/semanticTokens/full", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                              })

      expect(response["result"]["data"]).to be_an(Array)
    end

    it "returns empty data for unknown document" do
      response = send_request("textDocument/semanticTokens/full", {
                                "textDocument" => { "uri" => "file:///unknown.trb" },
                              })

      expect(response["result"]["data"]).to eq([])
    end
  end

  describe "completion contexts" do
    before do
      send_request("initialize", {})
    end

    it "provides completions after pipe for union types" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(x: String | ): void\\nend",
                          },
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 21 },
                              })

      items = response["result"]["items"]
      expect(items).not_to be_empty
    end

    it "provides completions after ampersand for intersection types" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(x: Readable & ): void\\nend",
                          },
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 23 },
                              })

      items = response["result"]["items"]
      expect(items).not_to be_empty
    end

    it "provides completions after generic bracket" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test(x: Array< ): void\\nend",
                          },
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 19 },
                              })

      items = response["result"]["items"]
      expect(items).not_to be_empty
    end

    it "provides no completions during def name" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def mymethod",
                          },
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 12 },
                              })

      items = response["result"]["items"]
      labels = items.map { |i| i["label"] }
      # Should not include standard type completions during def naming
      expect(labels).not_to include("type", "interface")
    end

    it "provides interface completions from document" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "interface Readable\\n  read: String\\nend\\ndef test(r: ): void\\nend",
                          },
                        })

      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 3, "character" => 13 },
                              })

      items = response["result"]["items"]
      labels = items.map { |i| i["label"] }
      expect(labels).to include("Readable")
    end

    it "returns empty for unknown document" do
      response = send_request("textDocument/completion", {
                                "textDocument" => { "uri" => "file:///unknown.trb" },
                                "position" => { "line" => 0, "character" => 0 },
                              })

      expect(response["result"]["items"]).to eq([])
    end
  end

  describe "hover edge cases" do
    before { send_request("initialize", {}) }

    it "returns nil for empty line" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "\\n\\n\\n",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 1, "character" => 0 },
                              })

      expect(response["result"]).to be_nil
    end

    it "returns nil for position beyond line length" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "def test",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 100 },
                              })

      expect(response["result"]).to be_nil
    end

    it "shows interface members in hover" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "interface Runnable\\n  run: void\\n  stop: void\\nend",
                          },
                        })

      response = send_request("textDocument/hover", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 11 },
                              })

      expect(response["result"]["contents"]["value"]).to include("Interface")
      expect(response["result"]["contents"]["value"]).to include("Runnable")
    end
  end

  describe "definition edge cases" do
    before { send_request("initialize", {}) }

    it "returns nil for unknown document" do
      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///unknown.trb" },
                                "position" => { "line" => 0, "character" => 0 },
                              })

      expect(response["result"]).to be_nil
    end

    it "returns nil for undefined symbol" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "unknown_symbol",
                          },
                        })

      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 5 },
                              })

      expect(response["result"]).to be_nil
    end

    it "returns nil for empty word" do
      send_notification("textDocument/didOpen", {
                          "textDocument" => {
                            "uri" => "file:///test.trb",
                            "version" => 1,
                            "text" => "   ",
                          },
                        })

      response = send_request("textDocument/definition", {
                                "textDocument" => { "uri" => "file:///test.trb" },
                                "position" => { "line" => 0, "character" => 1 },
                              })

      expect(response["result"]).to be_nil
    end
  end

  describe "LSP constants" do
    it "defines VERSION" do
      expect(TRuby::LSPServer::VERSION).to be_a(String)
    end

    it "defines error codes" do
      expect(TRuby::LSPServer::ErrorCodes::PARSE_ERROR).to eq(-32_700)
      expect(TRuby::LSPServer::ErrorCodes::INVALID_REQUEST).to eq(-32_600)
      expect(TRuby::LSPServer::ErrorCodes::METHOD_NOT_FOUND).to eq(-32_601)
      expect(TRuby::LSPServer::ErrorCodes::INVALID_PARAMS).to eq(-32_602)
      expect(TRuby::LSPServer::ErrorCodes::INTERNAL_ERROR).to eq(-32_603)
      expect(TRuby::LSPServer::ErrorCodes::SERVER_NOT_INITIALIZED).to eq(-32_002)
      expect(TRuby::LSPServer::ErrorCodes::UNKNOWN_ERROR_CODE).to eq(-32_001)
    end

    it "defines completion item kinds" do
      expect(TRuby::LSPServer::CompletionItemKind::CLASS).to eq(7)
      expect(TRuby::LSPServer::CompletionItemKind::INTERFACE).to eq(8)
      expect(TRuby::LSPServer::CompletionItemKind::KEYWORD).to eq(14)
      expect(TRuby::LSPServer::CompletionItemKind::FUNCTION).to eq(3)
    end

    it "defines diagnostic severity" do
      expect(TRuby::LSPServer::DiagnosticSeverity::ERROR).to eq(1)
      expect(TRuby::LSPServer::DiagnosticSeverity::WARNING).to eq(2)
      expect(TRuby::LSPServer::DiagnosticSeverity::INFORMATION).to eq(3)
      expect(TRuby::LSPServer::DiagnosticSeverity::HINT).to eq(4)
    end

    it "defines semantic token types" do
      expect(TRuby::LSPServer::SemanticTokenTypes::TYPE).to eq(1)
      expect(TRuby::LSPServer::SemanticTokenTypes::INTERFACE).to eq(4)
      expect(TRuby::LSPServer::SemanticTokenTypes::FUNCTION).to eq(12)
      expect(TRuby::LSPServer::SemanticTokenTypes::KEYWORD).to eq(15)
    end

    it "defines semantic token modifiers" do
      expect(TRuby::LSPServer::SemanticTokenModifiers::DECLARATION).to eq(0x01)
      expect(TRuby::LSPServer::SemanticTokenModifiers::DEFINITION).to eq(0x02)
      expect(TRuby::LSPServer::SemanticTokenModifiers::DEFAULT_LIBRARY).to eq(0x200)
    end

    it "defines built-in types list" do
      expect(TRuby::LSPServer::BUILT_IN_TYPES).to include("String", "Integer", "Boolean")
    end

    it "defines type keywords list" do
      expect(TRuby::LSPServer::TYPE_KEYWORDS).to include("type", "interface", "def", "end")
    end

    it "defines semantic token type names" do
      expect(TRuby::LSPServer::SEMANTIC_TOKEN_TYPES).to include("type", "interface", "function", "keyword")
    end

    it "defines semantic token modifier names" do
      expect(TRuby::LSPServer::SEMANTIC_TOKEN_MODIFIERS).to include("declaration", "definition", "defaultLibrary")
    end
  end

  describe "send_notification" do
    it "sends notification without id" do
      server.send(:send_notification, "window/logMessage", { "message" => "test" })

      output.rewind
      response_text = output.read

      expect(response_text).to include("window/logMessage")
      expect(response_text).not_to include('"id"')
    end
  end

  describe "uri_to_path" do
    it "converts file URI to path" do
      path = server.send(:uri_to_path, "file:///Users/test/project/test.trb")
      expect(path).to eq("/Users/test/project/test.trb")
    end

    it "returns non-file URIs unchanged" do
      uri = "https://example.com/test"
      expect(server.send(:uri_to_path, uri)).to eq(uri)
    end
  end

  describe "create_diagnostic" do
    it "creates LSP diagnostic format" do
      diagnostic = server.send(:create_diagnostic, 5, "Test error", TRuby::LSPServer::DiagnosticSeverity::ERROR)

      expect(diagnostic["range"]["start"]["line"]).to eq(5)
      expect(diagnostic["message"]).to eq("Test error")
      expect(diagnostic["severity"]).to eq(1)
      expect(diagnostic["source"]).to eq("t-ruby")
    end
  end

  describe "keyword_documentation" do
    it "provides documentation for type keyword" do
      doc = server.send(:keyword_documentation, "type")
      expect(doc).to include("type alias")
    end

    it "provides documentation for interface keyword" do
      doc = server.send(:keyword_documentation, "interface")
      expect(doc).to include("interface")
    end

    it "provides documentation for def keyword" do
      doc = server.send(:keyword_documentation, "def")
      expect(doc).to include("function")
    end

    it "provides documentation for end keyword" do
      doc = server.send(:keyword_documentation, "end")
      expect(doc).to include("End")
    end

    it "returns keyword itself for unknown" do
      doc = server.send(:keyword_documentation, "unknown")
      expect(doc).to eq("unknown")
    end
  end

  describe "extract_word_at_position" do
    it "extracts word at cursor" do
      line = "def hello"
      word = server.send(:extract_word_at_position, line, 5)
      expect(word).to eq("hello")
    end

    it "returns nil for position beyond line" do
      line = "short"
      word = server.send(:extract_word_at_position, line, 100)
      expect(word).to be_nil
    end

    it "handles generic types with brackets" do
      line = "Array<String>"
      word = server.send(:extract_word_at_position, line, 0)
      expect(word).to include("Array")
    end
  end

  describe "word_range" do
    it "calculates word range" do
      range = server.send(:word_range, 10, "def hello", 5, "hello")

      expect(range["start"]["line"]).to eq(10)
      expect(range["end"]["line"]).to eq(10)
    end
  end

  describe "diagnostic_to_lsp" do
    it "converts TRuby diagnostic to LSP format" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR0001",
        message: "Test error",
        file: "test.trb",
        line: 10,
        column: 5,
        severity: :error
      )

      lsp_diag = server.send(:diagnostic_to_lsp, diagnostic)

      expect(lsp_diag["range"]["start"]["line"]).to eq(9) # 0-based
      expect(lsp_diag["range"]["start"]["character"]).to eq(4) # 0-based
      expect(lsp_diag["severity"]).to eq(TRuby::LSPServer::DiagnosticSeverity::ERROR)
      expect(lsp_diag["code"]).to eq("TR0001")
    end

    it "handles warning severity" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR0002",
        message: "Warning",
        file: "test.trb",
        line: 1,
        column: 1,
        severity: :warning
      )

      lsp_diag = server.send(:diagnostic_to_lsp, diagnostic)
      expect(lsp_diag["severity"]).to eq(TRuby::LSPServer::DiagnosticSeverity::WARNING)
    end

    it "handles info severity" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR0003",
        message: "Info",
        file: "test.trb",
        line: 1,
        column: 1,
        severity: :info
      )

      lsp_diag = server.send(:diagnostic_to_lsp, diagnostic)
      expect(lsp_diag["severity"]).to eq(TRuby::LSPServer::DiagnosticSeverity::INFORMATION)
    end

    it "handles negative line numbers" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR0001",
        message: "Error",
        file: "test.trb",
        line: -1,
        column: -1,
        severity: :error
      )

      lsp_diag = server.send(:diagnostic_to_lsp, diagnostic)
      expect(lsp_diag["range"]["start"]["line"]).to eq(0)
      expect(lsp_diag["range"]["start"]["character"]).to eq(0)
    end
  end

  describe "analyze_document" do
    it "analyzes document and returns diagnostics" do
      diagnostics = server.send(:analyze_document, "def test(: String): void\\nend")
      expect(diagnostics).to be_an(Array)
    end

    it "returns empty array for valid code" do
      diagnostics = server.send(:analyze_document, "def test(name: String): void\\nend")
      expect(diagnostics).to eq([])
    end
  end

  describe "encode_tokens" do
    it "encodes tokens with delta encoding" do
      raw_tokens = [
        [0, 0, 4, 15, 1],  # line 0, char 0, length 4, keyword, declaration
        [0, 5, 5, 12, 2],  # line 0, char 5, length 5, function, definition
        [1, 0, 3, 15, 0],  # line 1, char 0, length 3, keyword
      ]

      encoded = server.send(:encode_tokens, raw_tokens)

      expect(encoded).to eq([
                              0, 0, 4, 15, 1,    # First token (no delta)
                              0, 5, 5, 12, 2,    # Same line, delta char = 5
                              1, 0, 3, 15, 0,    # Next line, char resets
                            ])
    end

    it "handles empty tokens" do
      encoded = server.send(:encode_tokens, [])
      expect(encoded).to eq([])
    end
  end

  describe "add_type_tokens" do
    it "adds tokens for built-in types" do
      raw_tokens = []
      server.send(:add_type_tokens, raw_tokens, "def test(name: String)", 0, "String")

      expect(raw_tokens).not_to be_empty
    end

    it "handles generic types" do
      raw_tokens = []
      server.send(:add_type_tokens, raw_tokens, "def test(arr: Array<String>)", 0, "Array<String>")

      expect(raw_tokens).not_to be_empty
    end

    it "handles union types" do
      raw_tokens = []
      server.send(:add_type_tokens, raw_tokens, "def test(x: String | Integer)", 0, "String | Integer")

      expect(raw_tokens).not_to be_empty
    end

    it "handles intersection types" do
      raw_tokens = []
      server.send(:add_type_tokens, raw_tokens, "def test(x: A & B)", 0, "A & B")

      expect(raw_tokens).not_to be_empty
    end

    it "handles nil type string" do
      raw_tokens = []
      server.send(:add_type_tokens, raw_tokens, "def test", 0, nil)

      expect(raw_tokens).to be_empty
    end
  end

  describe "generate_semantic_tokens" do
    it "generates tokens for complete code" do
      code = <<~TRBY
        type UserId = String
        interface Printable
          print: void
        end
        def greet(name: String): void
          puts name
        end
      TRBY

      tokens = server.send(:generate_semantic_tokens, code)

      expect(tokens).to be_an(Array)
      expect(tokens.length).to be > 0
    end

    it "handles empty code" do
      tokens = server.send(:generate_semantic_tokens, "")
      expect(tokens).to eq([])
    end
  end
end
`,
  "spec/t_ruby/package_manager_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::SemanticVersion do
  describe "#initialize" do
    it "parses valid version" do
      v = TRuby::SemanticVersion.new("1.2.3")
      expect(v.major).to eq(1)
      expect(v.minor).to eq(2)
      expect(v.patch).to eq(3)
    end

    it "parses version with prerelease" do
      v = TRuby::SemanticVersion.new("1.0.0-alpha")
      expect(v.prerelease).to eq("alpha")
    end

    it "raises for invalid version" do
      expect { TRuby::SemanticVersion.new("invalid") }.to raise_error(ArgumentError)
    end
  end

  describe "#<=>" do
    it "compares versions" do
      v1 = TRuby::SemanticVersion.new("1.0.0")
      v2 = TRuby::SemanticVersion.new("2.0.0")
      expect(v1 < v2).to be true
    end

    it "compares minor versions" do
      v1 = TRuby::SemanticVersion.new("1.1.0")
      v2 = TRuby::SemanticVersion.new("1.2.0")
      expect(v1 < v2).to be true
    end

    it "compares patch versions" do
      v1 = TRuby::SemanticVersion.new("1.0.1")
      v2 = TRuby::SemanticVersion.new("1.0.2")
      expect(v1 < v2).to be true
    end

    it "release > prerelease" do
      v1 = TRuby::SemanticVersion.new("1.0.0")
      v2 = TRuby::SemanticVersion.new("1.0.0-alpha")
      expect(v1 > v2).to be true
    end
  end

  describe "#satisfies?" do
    it "checks caret constraint" do
      v = TRuby::SemanticVersion.new("1.2.3")
      expect(v.satisfies?("^1.0.0")).to be true
      expect(v.satisfies?("^2.0.0")).to be false
    end
  end

  describe "#to_s" do
    it "returns version string" do
      v = TRuby::SemanticVersion.new("1.2.3")
      expect(v.to_s).to eq("1.2.3")
    end

    it "includes prerelease" do
      v = TRuby::SemanticVersion.new("1.0.0-beta")
      expect(v.to_s).to eq("1.0.0-beta")
    end
  end
end

RSpec.describe TRuby::VersionConstraint do
  describe "#satisfied_by?" do
    it "checks caret constraint" do
      c = TRuby::VersionConstraint.new("^1.2.0")
      expect(c.satisfied_by?("1.2.0")).to be true
      expect(c.satisfied_by?("1.3.0")).to be true
      expect(c.satisfied_by?("1.9.9")).to be true
      expect(c.satisfied_by?("2.0.0")).to be false
    end

    it "checks tilde constraint" do
      c = TRuby::VersionConstraint.new("~1.2.0")
      expect(c.satisfied_by?("1.2.0")).to be true
      expect(c.satisfied_by?("1.2.5")).to be true
      expect(c.satisfied_by?("1.3.0")).to be false
    end

    it "checks >= constraint" do
      c = TRuby::VersionConstraint.new(">=1.0.0")
      expect(c.satisfied_by?("1.0.0")).to be true
      expect(c.satisfied_by?("2.0.0")).to be true
      expect(c.satisfied_by?("0.9.0")).to be false
    end

    it "checks exact version" do
      c = TRuby::VersionConstraint.new("=1.2.3")
      expect(c.satisfied_by?("1.2.3")).to be true
      expect(c.satisfied_by?("1.2.4")).to be false
    end
  end
end

RSpec.describe TRuby::PackageManifest do
  let(:manifest_data) do
    {
      name: "my-package",
      version: "1.0.0",
      description: "A test package",
      dependencies: { "other-pkg" => "^1.0.0" },
    }
  end

  describe "#initialize" do
    it "sets attributes from data" do
      m = TRuby::PackageManifest.new(manifest_data)
      expect(m.name).to eq("my-package")
      expect(m.version).to eq("1.0.0")
      expect(m.dependencies).to eq({ "other-pkg" => "^1.0.0" })
    end
  end

  describe "#valid?" do
    it "returns true for valid manifest" do
      m = TRuby::PackageManifest.new(manifest_data)
      expect(m.valid?).to be true
    end

    it "returns false for missing name" do
      m = TRuby::PackageManifest.new(version: "1.0.0")
      expect(m.valid?).to be false
    end
  end

  describe "#add_dependency" do
    it "adds a dependency" do
      m = TRuby::PackageManifest.new(manifest_data)
      m.add_dependency("new-pkg", "^2.0.0")
      expect(m.dependencies["new-pkg"]).to eq("^2.0.0")
    end
  end

  describe "#remove_dependency" do
    it "removes a dependency" do
      m = TRuby::PackageManifest.new(manifest_data)
      m.remove_dependency("other-pkg")
      expect(m.dependencies).not_to have_key("other-pkg")
    end
  end

  describe "#to_json" do
    it "generates valid JSON" do
      m = TRuby::PackageManifest.new(manifest_data)
      json = JSON.parse(m.to_json)
      expect(json["name"]).to eq("my-package")
    end
  end

  describe ".load and #save" do
    it "round-trips through file" do
      path = "/tmp/test-manifest-#{Process.pid}.json"
      m = TRuby::PackageManifest.new(manifest_data)
      m.save(path)

      loaded = TRuby::PackageManifest.load(path)
      expect(loaded.name).to eq(m.name)
      expect(loaded.version).to eq(m.version)

      File.delete(path)
    end
  end
end

RSpec.describe TRuby::PackageRegistry do
  let(:registry) { TRuby::PackageRegistry.new }

  describe "#register" do
    it "registers a package" do
      manifest = TRuby::PackageManifest.new(name: "pkg", version: "1.0.0")
      registry.register(manifest)
      expect(registry.get_versions("pkg")).to include("1.0.0")
    end
  end

  describe "#get_versions" do
    it "returns all versions" do
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "1.0.0"))
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "1.1.0"))
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "2.0.0"))

      versions = registry.get_versions("pkg")
      expect(versions).to contain_exactly("1.0.0", "1.1.0", "2.0.0")
    end

    it "returns empty for unknown package" do
      expect(registry.get_versions("unknown")).to eq([])
    end
  end

  describe "#get_package" do
    it "returns package info" do
      manifest = TRuby::PackageManifest.new(
        name: "pkg",
        version: "1.0.0",
        dependencies: { "dep" => "^1.0.0" }
      )
      registry.register(manifest)

      info = registry.get_package("pkg", "1.0.0")
      expect(info[:dependencies]).to eq({ "dep" => "^1.0.0" })
    end
  end

  describe "#search" do
    it "finds packages by name" do
      registry.register(TRuby::PackageManifest.new(name: "my-types", version: "1.0.0"))
      registry.register(TRuby::PackageManifest.new(name: "other-lib", version: "1.0.0"))

      results = registry.search("types")
      expect(results).to include("my-types")
      expect(results).not_to include("other-lib")
    end
  end
end

RSpec.describe TRuby::DependencyResolver do
  let(:registry) { TRuby::PackageRegistry.new }
  let(:resolver) { TRuby::DependencyResolver.new(registry) }

  before do
    registry.register(TRuby::PackageManifest.new(name: "dep-a", version: "1.0.0"))
    registry.register(TRuby::PackageManifest.new(name: "dep-a", version: "1.1.0"))
    registry.register(TRuby::PackageManifest.new(name: "dep-b", version: "2.0.0"))
  end

  describe "#resolve" do
    it "resolves dependencies" do
      manifest = TRuby::PackageManifest.new(
        name: "app",
        version: "1.0.0",
        dependencies: { "dep-a" => "^1.0.0" }
      )

      result = resolver.resolve(manifest)
      expect(result[:resolved]["dep-a"]).to eq("1.1.0") # Should get latest matching
      expect(result[:conflicts]).to be_empty
    end

    it "reports conflicts for missing packages" do
      manifest = TRuby::PackageManifest.new(
        name: "app",
        version: "1.0.0",
        dependencies: { "nonexistent" => "^1.0.0" }
      )

      result = resolver.resolve(manifest)
      expect(result[:conflicts]).not_to be_empty
    end
  end
end

RSpec.describe TRuby::PackageManager do
  let(:project_dir) { "/tmp/t-ruby-test-project-#{Process.pid}" }
  let(:manager) { TRuby::PackageManager.new(project_dir: project_dir) }

  before do
    FileUtils.mkdir_p(project_dir)
  end

  after do
    FileUtils.rm_rf(project_dir)
  end

  describe "#init" do
    it "creates manifest" do
      manifest = manager.init(name: "test-project")
      expect(manifest.name).to eq("test-project")
      expect(File.exist?(File.join(project_dir, ".trb-manifest.json"))).to be true
    end
  end

  describe "#add and #remove" do
    before do
      manager.init(name: "test-project")
      # Register packages so dependency resolution works
      manager.registry.register(TRuby::PackageManifest.new(name: "some-pkg", version: "1.0.0"))
      manager.registry.register(TRuby::PackageManifest.new(name: "some-pkg", version: "1.5.0"))
      manager.registry.register(TRuby::PackageManifest.new(name: "test-pkg", version: "1.0.0"))
    end

    it "adds dependency" do
      manager.add("some-pkg", "^1.0.0")
      manifest = TRuby::PackageManifest.load(File.join(project_dir, ".trb-manifest.json"))
      expect(manifest.dependencies).to have_key("some-pkg")
    end

    it "adds dev dependency" do
      manager.add("test-pkg", "^1.0.0", dev: true)
      manifest = TRuby::PackageManifest.load(File.join(project_dir, ".trb-manifest.json"))
      expect(manifest.dev_dependencies).to have_key("test-pkg")
    end

    it "removes dependency" do
      manager.add("some-pkg", "^1.0.0")
      manager.remove("some-pkg")
      manifest = TRuby::PackageManifest.load(File.join(project_dir, ".trb-manifest.json"))
      expect(manifest.dependencies).not_to have_key("some-pkg")
    end
  end

  describe "#list" do
    it "returns empty hash when no lockfile" do
      expect(manager.list).to eq({})
    end

    it "returns lockfile contents when present" do
      manager.init(name: "test-project")
      lockfile = { lockfileVersion: 1, packages: { "pkg" => "1.0.0" } }
      File.write(File.join(project_dir, ".trb-lock.json"), JSON.generate(lockfile))

      result = manager.list
      expect(result["packages"]).to eq({ "pkg" => "1.0.0" })
    end

    it "returns empty hash for invalid JSON" do
      manager.init(name: "test-project")
      File.write(File.join(project_dir, ".trb-lock.json"), "invalid json")
      expect(manager.list).to eq({})
    end
  end

  describe "#install" do
    before do
      manager.init(name: "test-project")
      manager.registry.register(TRuby::PackageManifest.new(name: "pkg-a", version: "1.0.0"))
    end

    it "installs dependencies and generates lockfile" do
      manager.add("pkg-a", "^1.0.0")
      expect(File.exist?(File.join(project_dir, ".trb-lock.json"))).to be true
    end

    it "raises for dependency conflicts" do
      manager.manifest.add_dependency("nonexistent", "^1.0.0")
      expect { manager.install }.to raise_error(/Dependency conflicts/)
    end
  end

  describe "#update" do
    before do
      manager.init(name: "test-project")
      manager.registry.register(TRuby::PackageManifest.new(name: "upd-pkg", version: "1.0.0"))
      manager.registry.register(TRuby::PackageManifest.new(name: "upd-pkg", version: "1.5.0"))
      manager.add("upd-pkg", "^1.0.0")
    end

    it "updates specific package" do
      manager.update("upd-pkg")
      expect(manager.list["packages"]["upd-pkg"]).to eq("1.5.0")
    end

    it "updates all packages" do
      manager.update
      expect(manager.list["packages"]["upd-pkg"]).to eq("1.5.0")
    end
  end

  describe "#publish" do
    before do
      manager.init(name: "test-project")
      # Create a type file so validation passes
      FileUtils.mkdir_p(File.join(project_dir, "lib/types"))
      File.write(File.join(project_dir, "lib/types/test.d.trb"), "type Test = String")
    end

    it "returns publish status" do
      result = manager.publish
      expect(result[:status]).to eq(:published)
      expect(result[:name]).to eq("test-project")
    end

    it "raises for invalid manifest" do
      manager.manifest.instance_variable_set(:@name, nil)
      expect { manager.publish }.to raise_error(/Invalid manifest/)
    end
  end

  describe "#deprecate" do
    before do
      manager.init(name: "test-project")
    end

    it "returns deprecation notice" do
      result = manager.deprecate("1.0.0", "Use v2 instead")
      expect(result[:deprecated]).to be true
      expect(result[:message]).to eq("Use v2 instead")
    end
  end

  describe "without manifest" do
    it "raises error for operations requiring manifest" do
      expect { manager.add("pkg", "1.0.0") }.to raise_error(/No manifest found/)
      expect { manager.remove("pkg") }.to raise_error(/No manifest found/)
      expect { manager.install }.to raise_error(/No manifest found/)
    end
  end
end

RSpec.describe TRuby::SemanticVersion, "additional tests" do
  describe ".parse" do
    it "returns nil for invalid version" do
      expect(TRuby::SemanticVersion.parse("invalid")).to be_nil
    end

    it "parses valid version" do
      v = TRuby::SemanticVersion.parse("1.2.3")
      expect(v).to be_a(TRuby::SemanticVersion)
    end
  end

  describe "#<=>" do
    it "returns nil for non-SemanticVersion" do
      v = TRuby::SemanticVersion.new("1.0.0")
      expect(v <=> "string").to be_nil
    end

    it "compares prereleases alphabetically" do
      v1 = TRuby::SemanticVersion.new("1.0.0-alpha")
      v2 = TRuby::SemanticVersion.new("1.0.0-beta")
      expect(v1 < v2).to be true
    end

    it "returns 0 for identical prereleases" do
      v1 = TRuby::SemanticVersion.new("1.0.0-alpha")
      v2 = TRuby::SemanticVersion.new("1.0.0-alpha")
      expect(v1 <=> v2).to eq(0)
    end
  end
end

RSpec.describe TRuby::VersionConstraint, "additional tests" do
  describe "#satisfied_by?" do
    it "checks ~> (Ruby-style tilde)" do
      # ~> with space splits into two parts, use without space
      c = TRuby::VersionConstraint.new("~1.2.0")
      expect(c.satisfied_by?("1.2.5")).to be true
      expect(c.satisfied_by?("1.3.0")).to be false
    end

    it "checks <= constraint" do
      c = TRuby::VersionConstraint.new("<=2.0.0")
      expect(c.satisfied_by?("1.9.9")).to be true
      expect(c.satisfied_by?("2.0.0")).to be true
      expect(c.satisfied_by?("2.0.1")).to be false
    end

    it "checks > constraint" do
      c = TRuby::VersionConstraint.new(">1.0.0")
      expect(c.satisfied_by?("1.0.1")).to be true
      expect(c.satisfied_by?("1.0.0")).to be false
    end

    it "checks < constraint" do
      c = TRuby::VersionConstraint.new("<2.0.0")
      expect(c.satisfied_by?("1.9.9")).to be true
      expect(c.satisfied_by?("2.0.0")).to be false
    end

    it "handles * wildcard" do
      c = TRuby::VersionConstraint.new("*")
      expect(c.satisfied_by?("1.0.0")).to be true
      expect(c.satisfied_by?("99.99.99")).to be true
    end

    it "handles version string input" do
      c = TRuby::VersionConstraint.new("^1.0.0")
      expect(c.satisfied_by?("1.5.0")).to be true
    end

    it "parses bare version as exact match" do
      c = TRuby::VersionConstraint.new("1.2.3")
      expect(c.satisfied_by?("1.2.3")).to be true
      expect(c.satisfied_by?("1.2.4")).to be false
    end
  end
end

RSpec.describe TRuby::PackageManifest, "additional tests" do
  describe ".load" do
    it "returns nil for non-existent file" do
      expect(TRuby::PackageManifest.load("/nonexistent/path.json")).to be_nil
    end

    it "returns nil for invalid JSON" do
      path = "/tmp/invalid-manifest-#{Process.pid}.json"
      File.write(path, "invalid json {{{")
      expect(TRuby::PackageManifest.load(path)).to be_nil
      File.delete(path)
    end
  end

  describe "#add_dev_dependency" do
    it "adds dev dependency" do
      m = TRuby::PackageManifest.new(name: "pkg", version: "1.0.0")
      m.add_dev_dependency("rspec-types", "^3.0.0")
      expect(m.dev_dependencies["rspec-types"]).to eq("^3.0.0")
    end
  end

  describe "#to_h" do
    it "excludes nil values" do
      m = TRuby::PackageManifest.new(name: "pkg", version: "1.0.0")
      hash = m.to_h
      expect(hash).to have_key(:name)
      expect(hash).to have_key(:version)
      expect(hash).not_to have_key(:description) # nil should be excluded
    end
  end

  describe "string key handling" do
    it "accepts string keys from JSON" do
      m = TRuby::PackageManifest.new(
        "name" => "my-pkg",
        "version" => "2.0.0",
        "devDependencies" => { "test" => "^1.0.0" }
      )
      expect(m.name).to eq("my-pkg")
      expect(m.version).to eq("2.0.0")
      expect(m.dev_dependencies).to eq({ "test" => "^1.0.0" })
    end
  end
end

RSpec.describe TRuby::DependencyResolver, "additional tests" do
  let(:registry) { TRuby::PackageRegistry.new }
  let(:resolver) { TRuby::DependencyResolver.new(registry) }

  describe "#check_circular" do
    it "detects simple circular dependency" do
      pkg_a = TRuby::PackageManifest.new(name: "pkg-a", version: "1.0.0", dependencies: { "pkg-b" => "^1.0.0" })
      pkg_b = TRuby::PackageManifest.new(name: "pkg-b", version: "1.0.0", dependencies: { "pkg-a" => "^1.0.0" })

      registry.register(pkg_a)
      registry.register(pkg_b)

      cycles = resolver.check_circular(pkg_a)
      expect(cycles).not_to be_empty
    end

    it "returns empty for no circular dependency" do
      pkg_a = TRuby::PackageManifest.new(name: "pkg-a", version: "1.0.0", dependencies: { "pkg-b" => "^1.0.0" })
      pkg_b = TRuby::PackageManifest.new(name: "pkg-b", version: "1.0.0", dependencies: {})

      registry.register(pkg_a)
      registry.register(pkg_b)

      cycles = resolver.check_circular(pkg_a)
      expect(cycles).to be_empty
    end

    it "handles empty dependencies" do
      manifest = TRuby::PackageManifest.new(name: "app", version: "1.0.0", dependencies: {})
      expect(resolver.check_circular(manifest)).to eq([])
    end
  end

  describe "#resolve with transitive dependencies" do
    before do
      pkg_a = TRuby::PackageManifest.new(name: "pkg-a", version: "1.0.0", dependencies: { "pkg-b" => "^1.0.0" })
      pkg_b = TRuby::PackageManifest.new(name: "pkg-b", version: "1.0.0", dependencies: {})

      registry.register(pkg_a)
      registry.register(pkg_b)
    end

    it "resolves transitive dependencies" do
      manifest = TRuby::PackageManifest.new(
        name: "app",
        version: "1.0.0",
        dependencies: { "pkg-a" => "^1.0.0" }
      )

      result = resolver.resolve(manifest)
      expect(result[:resolved]).to have_key("pkg-a")
      expect(result[:resolved]).to have_key("pkg-b")
    end
  end
end

RSpec.describe TRuby::PackageRegistry, "additional tests" do
  let(:tmpdir) { "/tmp/t-ruby-registry-test-#{Process.pid}" }
  let(:registry) { TRuby::PackageRegistry.new(local_path: tmpdir) }

  after do
    FileUtils.rm_rf(tmpdir)
  end

  describe "#get_package" do
    before do
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "1.0.0"))
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "2.0.0"))
    end

    it "returns nil for unknown package" do
      expect(registry.get_package("unknown", "1.0.0")).to be_nil
    end

    it "returns latest version for * constraint" do
      info = registry.get_package("pkg", "*")
      expect(info).not_to be_nil
    end
  end

  describe "#load_local" do
    it "loads manifest from directory" do
      pkg_dir = File.join(tmpdir, "my-pkg")
      FileUtils.mkdir_p(pkg_dir)

      manifest = TRuby::PackageManifest.new(name: "my-pkg", version: "1.0.0")
      manifest.save(File.join(pkg_dir, ".trb-manifest.json"))

      loaded = registry.load_local(pkg_dir)
      expect(loaded.name).to eq("my-pkg")
      expect(registry.get_versions("my-pkg")).to include("1.0.0")
    end

    it "returns nil for missing manifest" do
      expect(registry.load_local("/nonexistent")).to be_nil
    end
  end

  describe "#install" do
    before do
      registry.register(TRuby::PackageManifest.new(name: "pkg", version: "1.0.0"))
    end

    it "installs package to target directory" do
      result = registry.install("pkg", "1.0.0")
      expect(result[:name]).to eq("pkg")
      expect(result[:version]).to eq("1.0.0")
      expect(Dir.exist?(result[:path])).to be true
    end

    it "returns nil for unknown package" do
      expect(registry.install("unknown", "1.0.0")).to be_nil
    end
  end
end

RSpec.describe TRuby::RemoteRegistry do
  let(:registry) { TRuby::RemoteRegistry.new }

  describe "#initialize" do
    it "creates cache directory" do
      tmpdir = "/tmp/t-ruby-remote-cache-#{Process.pid}"
      reg = TRuby::RemoteRegistry.new(cache_dir: tmpdir)
      expect(Dir.exist?(tmpdir)).to be true
      expect(reg.cache_dir).to eq(tmpdir)
      FileUtils.rm_rf(tmpdir)
    end
  end

  describe "attribute readers" do
    it "has registry_url" do
      expect(registry.registry_url).to be_a(String)
    end
  end
end
`,
  "spec/t_ruby/parser_combinator_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator do
  include TRuby::ParserCombinator::DSL

  describe TRuby::ParserCombinator::ParseResult do
    describe ".success" do
      it "creates a successful result" do
        result = described_class.success("value", "input", 5)
        expect(result.success?).to be true
        expect(result.value).to eq("value")
        expect(result.position).to eq(5)
      end
    end

    describe ".failure" do
      it "creates a failed result" do
        result = described_class.failure("error", "input", 3)
        expect(result.failure?).to be true
        expect(result.error).to eq("error")
      end
    end

    describe "#map" do
      it "transforms successful result" do
        result = described_class.success(5, "input", 1)
        mapped = result.map { |v| v * 2 }
        expect(mapped.value).to eq(10)
      end

      it "returns same failure" do
        result = described_class.failure("error", "input", 1)
        mapped = result.map { |v| v * 2 }
        expect(mapped.failure?).to be true
      end
    end
  end

  describe "Primitive Parsers" do
    describe TRuby::ParserCombinator::Literal do
      it "parses matching string" do
        parser = literal("hello")
        result = parser.parse("hello world")
        expect(result.success?).to be true
        expect(result.value).to eq("hello")
        expect(result.position).to eq(5)
      end

      it "fails on non-matching string" do
        parser = literal("hello")
        result = parser.parse("world")
        expect(result.failure?).to be true
      end
    end

    describe TRuby::ParserCombinator::Regex do
      it "parses matching pattern" do
        parser = regex(/\\d+/)
        result = parser.parse("123abc")
        expect(result.success?).to be true
        expect(result.value).to eq("123")
      end

      it "fails on non-matching pattern" do
        parser = regex(/\\d+/)
        result = parser.parse("abc")
        expect(result.failure?).to be true
      end
    end

    describe TRuby::ParserCombinator::Satisfy do
      it "parses character matching predicate" do
        parser = satisfy("digit") { |c| c =~ /\\d/ }
        result = parser.parse("5abc")
        expect(result.success?).to be true
        expect(result.value).to eq("5")
      end
    end

    describe TRuby::ParserCombinator::EndOfInput do
      it "succeeds at end of input" do
        parser = eof
        result = parser.parse("", 0)
        expect(result.success?).to be true
      end

      it "fails when not at end" do
        parser = eof
        result = parser.parse("abc", 0)
        expect(result.failure?).to be true
      end
    end
  end

  describe "Combinators" do
    describe "sequence (>>)" do
      it "combines two parsers" do
        parser = literal("a") >> literal("b")
        result = parser.parse("ab")
        expect(result.success?).to be true
        expect(result.value).to eq(%w[a b])
      end

      it "fails if first fails" do
        parser = literal("a") >> literal("b")
        result = parser.parse("bb")
        expect(result.failure?).to be true
      end

      it "fails if second fails" do
        parser = literal("a") >> literal("b")
        result = parser.parse("ac")
        expect(result.failure?).to be true
      end
    end

    describe "alternative (|)" do
      it "tries second if first fails" do
        parser = literal("a") | literal("b")
        result = parser.parse("b")
        expect(result.success?).to be true
        expect(result.value).to eq("b")
      end

      it "returns first if it succeeds" do
        parser = literal("a") | literal("b")
        result = parser.parse("a")
        expect(result.value).to eq("a")
      end
    end

    describe "#many" do
      it "parses zero occurrences" do
        parser = literal("a").many
        result = parser.parse("bbb")
        expect(result.success?).to be true
        expect(result.value).to eq([])
      end

      it "parses multiple occurrences" do
        parser = literal("a").many
        result = parser.parse("aaab")
        expect(result.success?).to be true
        expect(result.value).to eq(%w[a a a])
      end
    end

    describe "#many1" do
      it "fails on zero occurrences" do
        parser = literal("a").many1
        result = parser.parse("bbb")
        expect(result.failure?).to be true
      end

      it "parses multiple occurrences" do
        parser = literal("a").many1
        result = parser.parse("aaab")
        expect(result.success?).to be true
        expect(result.value).to eq(%w[a a a])
      end
    end

    describe "#optional" do
      it "returns nil when not present" do
        parser = literal("a").optional
        result = parser.parse("b")
        expect(result.success?).to be true
        expect(result.value).to be_nil
      end

      it "returns value when present" do
        parser = literal("a").optional
        result = parser.parse("a")
        expect(result.success?).to be true
        expect(result.value).to eq("a")
      end
    end

    describe "#sep_by" do
      it "parses items separated by delimiter" do
        parser = digit.sep_by(char(","))
        result = parser.parse("1,2,3")
        expect(result.success?).to be true
        expect(result.value).to eq(%w[1 2 3])
      end

      it "returns empty array when no items" do
        parser = digit.sep_by(char(","))
        result = parser.parse("abc")
        expect(result.success?).to be true
        expect(result.value).to eq([])
      end
    end

    describe "#sep_by1" do
      it "requires at least one item" do
        parser = digit.sep_by1(char(","))
        result = parser.parse("abc")
        expect(result.failure?).to be true
      end

      it "parses one item" do
        parser = digit.sep_by1(char(","))
        result = parser.parse("1")
        expect(result.success?).to be true
        expect(result.value).to eq(["1"])
      end
    end

    describe "#between" do
      it "parses content between delimiters" do
        parser = identifier.between(char("("), char(")"))
        result = parser.parse("(foo)")
        expect(result.success?).to be true
        expect(result.value).to eq("foo")
      end
    end

    describe "skip right (<<)" do
      it "keeps left result, discards right" do
        parser = identifier << char(";")
        result = parser.parse("foo;")
        expect(result.success?).to be true
        expect(result.value).to eq("foo")
      end
    end

    describe "#map" do
      it "transforms result" do
        parser = digit.many1.map { |ds| ds.join.to_i }
        result = parser.parse("123")
        expect(result.success?).to be true
        expect(result.value).to eq(123)
      end
    end
  end

  describe "DSL helpers" do
    describe "#identifier" do
      it "parses valid identifier" do
        result = identifier.parse("foo_bar123")
        expect(result.success?).to be true
        expect(result.value).to eq("foo_bar123")
      end

      it "fails on starting with number" do
        result = identifier.parse("123foo")
        expect(result.failure?).to be true
      end
    end

    describe "#integer" do
      it "parses positive integer" do
        result = integer.parse("123")
        expect(result.success?).to be true
        expect(result.value).to eq(123)
      end

      it "parses negative integer" do
        result = integer.parse("-456")
        expect(result.success?).to be true
        expect(result.value).to eq(-456)
      end
    end

    describe "#float" do
      it "parses float" do
        result = float.parse("3.14")
        expect(result.success?).to be true
        expect(result.value).to eq(3.14)
      end
    end

    describe "#quoted_string" do
      it "parses quoted string" do
        result = quoted_string('"').parse('"hello world"')
        expect(result.success?).to be true
        expect(result.value).to eq("hello world")
      end
    end

    describe "#choice" do
      it "tries parsers in order" do
        parser = choice(literal("foo"), literal("bar"), literal("baz"))

        expect(parser.parse("foo").value).to eq("foo")
        expect(parser.parse("bar").value).to eq("bar")
        expect(parser.parse("baz").value).to eq("baz")
      end
    end

    describe "#lazy" do
      it "enables recursive parsers" do
        # Simple recursive expression: nested parens
        expr = nil
        expr = lazy { (char("(") >> expr.optional << char(")")) | char("x") }

        expect(expr.parse("x").success?).to be true
        expect(expr.parse("()").success?).to be true
        expect(expr.parse("(())").success?).to be true
      end
    end
  end

  describe TRuby::ParserCombinator::TypeParser do
    let(:parser) { described_class.new }

    describe "#parse" do
      it "parses simple type" do
        result = parser.parse("String")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::SimpleType)
        expect(result[:type].name).to eq("String")
      end

      it "parses generic type" do
        result = parser.parse("Array<String>")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::GenericType)
        expect(result[:type].base).to eq("Array")
        expect(result[:type].type_args.length).to eq(1)
      end

      it "parses nested generic type" do
        result = parser.parse("Map<String, Array<Integer>>")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::GenericType)
        expect(result[:type].base).to eq("Map")
        expect(result[:type].type_args.length).to eq(2)
        expect(result[:type].type_args[1]).to be_a(TRuby::IR::GenericType)
      end

      it "parses union type" do
        result = parser.parse("String | Integer | nil")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::UnionType)
        expect(result[:type].types.length).to eq(3)
      end

      it "parses intersection type" do
        result = parser.parse("Readable & Writable")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::IntersectionType)
        expect(result[:type].types.length).to eq(2)
      end

      it "parses nullable type" do
        result = parser.parse("String?")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::NullableType)
        expect(result[:type].inner_type.name).to eq("String")
      end

      it "parses function type" do
        result = parser.parse("(String, Integer) -> Boolean")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::FunctionType)
        expect(result[:type].param_types.length).to eq(2)
        expect(result[:type].return_type.name).to eq("Boolean")
      end

      it "parses tuple type" do
        result = parser.parse("[String, Integer, Boolean]")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::TupleType)
        expect(result[:type].element_types.length).to eq(3)
      end

      it "parses complex nested type" do
        result = parser.parse("Map<String, Array<Tuple<Integer, String>>> | nil")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::UnionType)
      end

      it "parses parenthesized type" do
        result = parser.parse("(String | Integer)")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::UnionType)
      end

      it "handles whitespace" do
        result = parser.parse("  Array < String >  ")
        expect(result[:success]).to be true
        expect(result[:type]).to be_a(TRuby::IR::GenericType)
      end
    end
  end

  describe TRuby::ParserCombinator::DeclarationParser do
    let(:parser) { described_class.new }

    describe "#parse" do
      it "parses type alias" do
        result = parser.parse("type UserId = String")
        expect(result[:success]).to be true
        decl = result[:declarations]
        expect(decl).to be_a(TRuby::IR::TypeAlias)
        expect(decl.name).to eq("UserId")
      end

      it "parses complex type alias" do
        result = parser.parse("type Callback = (String) -> Integer")
        expect(result[:success]).to be true
        decl = result[:declarations]
        expect(decl.definition).to be_a(TRuby::IR::FunctionType)
      end

      it "parses method definition" do
        result = parser.parse("def greet(name: String): String")
        expect(result[:success]).to be true
        decl = result[:declarations]
        expect(decl).to be_a(TRuby::IR::MethodDef)
        expect(decl.name).to eq("greet")
        expect(decl.params.length).to eq(1)
      end

      it "parses method with multiple parameters" do
        result = parser.parse("def add(a: Integer, b: Integer): Integer")
        expect(result[:success]).to be true
        decl = result[:declarations]
        expect(decl.params.length).to eq(2)
      end

      it "parses method without return type" do
        result = parser.parse("def process(data: String)")
        expect(result[:success]).to be true
        decl = result[:declarations]
        expect(decl.return_type).to be_nil
      end
    end

    describe "#parse_file" do
      it "parses multiple declarations" do
        source = <<~TRB
          type UserId = String
          type Email = String

          def greet(name: String): String
        TRB

        result = parser.parse_file(source)
        expect(result[:success]).to be true
        expect(result[:declarations].length).to eq(3)
      end

      it "handles empty lines" do
        source = <<~TRB
          type UserId = String

          type Email = String
        TRB

        result = parser.parse_file(source)
        expect(result[:success]).to be true
        expect(result[:declarations].length).to eq(2)
      end
    end
  end

  describe TRuby::ParserCombinator::ParseError do
    it "calculates line and column" do
      input = "line1\\nline2\\nerror here"
      error = described_class.new(message: "Unexpected", position: 15, input: input)

      expect(error.line).to eq(3)
      expect(error.column).to eq(4)
    end

    it "formats error message" do
      input = "test"
      error = described_class.new(message: "Unexpected", position: 2, input: input)

      expect(error.to_s).to include("line 1")
      expect(error.to_s).to include("column 3")
    end

    it "provides context" do
      input = "line1\\nline2\\nerror here\\nline4"
      error = described_class.new(message: "Unexpected", position: 15, input: input)

      context = error.context
      expect(context).to include(">>>")
      expect(context).to include("error here")
    end
  end

  describe TRuby::ParserCombinator::ChainLeft do
    include TRuby::ParserCombinator::DSL

    it "parses left-associative operations" do
      num = digit.many1.map { |ds| ds.join.to_i }
      add_op = lexeme(char("+")).map { |_| ->(a, b) { a + b } }
      parser = chainl(num, add_op)

      result = parser.parse("1 + 2 + 3")
      expect(result.success?).to be true
      expect(result.value).to eq(6)
    end

    it "handles single term" do
      num = digit.many1.map { |ds| ds.join.to_i }
      add_op = lexeme(char("+")).map { |_| ->(a, b) { a + b } }
      parser = chainl(num, add_op)

      result = parser.parse("42")
      expect(result.success?).to be true
      expect(result.value).to eq(42)
    end
  end

  describe TRuby::ParserCombinator::Lookahead do
    include TRuby::ParserCombinator::DSL

    it "succeeds without consuming input" do
      parser = literal("hello").lookahead
      result = parser.parse("hello world")

      expect(result.success?).to be true
      expect(result.value).to eq("hello")
      expect(result.position).to eq(0) # Position should not advance
    end

    it "returns failure when inner parser fails" do
      parser = literal("hello").lookahead
      result = parser.parse("world")

      expect(result.failure?).to be true
    end
  end

  describe TRuby::ParserCombinator::NotFollowedBy do
    include TRuby::ParserCombinator::DSL

    it "succeeds when inner parser fails" do
      parser = literal("foo").not_followed_by
      result = parser.parse("bar")

      expect(result.success?).to be true
      expect(result.value).to be_nil
    end

    it "fails when inner parser succeeds" do
      parser = literal("foo").not_followed_by
      result = parser.parse("foobar")

      expect(result.failure?).to be true
      expect(result.error).to include("Unexpected")
    end
  end

  describe TRuby::ParserCombinator::FlatMap do
    include TRuby::ParserCombinator::DSL

    it "chains parsers based on result" do
      # Parse a digit, then parse that many 'a' characters
      parser = digit.flat_map { |n| literal("a" * n.to_i) }
      result = parser.parse("3aaa")

      expect(result.success?).to be true
      expect(result.value).to eq("aaa")
    end

    it "returns failure if first parser fails" do
      parser = digit.flat_map { |n| literal("a" * n.to_i) }
      result = parser.parse("xaaa")

      expect(result.failure?).to be true
    end

    it "returns failure if chained parser fails" do
      parser = digit.flat_map { |n| literal("a" * n.to_i) }
      result = parser.parse("3aa") # Only 2 'a's, needs 3

      expect(result.failure?).to be true
    end
  end

  describe TRuby::ParserCombinator::Pure do
    it "always succeeds with the given value" do
      parser = TRuby::ParserCombinator::Pure.new(42)
      result = parser.parse("anything")

      expect(result.success?).to be true
      expect(result.value).to eq(42)
      expect(result.position).to eq(0)
    end
  end

  describe TRuby::ParserCombinator::Fail do
    it "always fails with the given message" do
      parser = TRuby::ParserCombinator::Fail.new("custom error")
      result = parser.parse("anything")

      expect(result.failure?).to be true
      expect(result.error).to eq("custom error")
    end
  end

  describe TRuby::ParserCombinator::ParseResult, "#flat_map" do
    it "transforms successful result with function" do
      result = described_class.success(5, "input", 1)
      mapped = result.flat_map { |v, rem, pos| described_class.success(v * 2, rem, pos + 1) }

      expect(mapped.success?).to be true
      expect(mapped.value).to eq(10)
      expect(mapped.position).to eq(2)
    end

    it "returns same failure without calling block" do
      result = described_class.failure("error", "input", 1)
      block_called = false
      mapped = result.flat_map { |_v, _r, _p| block_called = true }

      expect(mapped.failure?).to be true
      expect(block_called).to be false
    end
  end

  describe TRuby::ParserCombinator::Parser, "#label" do
    include TRuby::ParserCombinator::DSL

    it "adds descriptive label to error" do
      parser = digit.label("a digit")
      result = parser.parse("abc")

      expect(result.failure?).to be true
      expect(result.error).to include("digit")
    end
  end

  describe "Token-based parsers" do
    # Helper to create mock tokens
    def mock_token(type, value)
      double("Token", type: type, value: value)
    end

    describe TRuby::ParserCombinator::TokenParseResult do
      describe "#map" do
        it "transforms successful result" do
          result = described_class.success(5, [], 1)
          mapped = result.map { |v| v * 2 }

          expect(mapped.success?).to be true
          expect(mapped.value).to eq(10)
        end

        it "returns same failure" do
          result = described_class.failure("error", [], 1)
          mapped = result.map { |v| v * 2 }

          expect(mapped.failure?).to be true
        end
      end
    end

    describe TRuby::ParserCombinator::TokenMany1 do
      it "parses one or more tokens" do
        tokens = [
          mock_token(:IDENT, "a"),
          mock_token(:IDENT, "b"),
          mock_token(:IDENT, "c"),
          mock_token(:OTHER, "x"),
        ]

        inner_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            return TRuby::ParserCombinator::TokenParseResult.failure("end", tokens, position) if position >= tokens.length

            token = tokens[position]
            if token.type == :IDENT
              TRuby::ParserCombinator::TokenParseResult.success(token.value, tokens, position + 1)
            else
              TRuby::ParserCombinator::TokenParseResult.failure("not ident", tokens, position)
            end
          end
        end.new

        parser = TRuby::ParserCombinator::TokenMany1.new(inner_parser)
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to eq(%w[a b c])
        expect(result.position).to eq(3)
      end

      it "fails when no matches" do
        tokens = [mock_token(:OTHER, "x")]

        inner_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            TRuby::ParserCombinator::TokenParseResult.failure("no match", tokens, position)
          end
        end.new

        parser = TRuby::ParserCombinator::TokenMany1.new(inner_parser)
        result = parser.parse(tokens, 0)

        expect(result.failure?).to be true
      end
    end

    describe TRuby::ParserCombinator::TokenSepBy1 do
      it "parses items separated by delimiter" do
        tokens = [
          mock_token(:IDENT, "a"),
          mock_token(:COMMA, ","),
          mock_token(:IDENT, "b"),
          mock_token(:COMMA, ","),
          mock_token(:IDENT, "c"),
        ]

        item_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            return TRuby::ParserCombinator::TokenParseResult.failure("end", tokens, position) if position >= tokens.length

            token = tokens[position]
            if token.type == :IDENT
              TRuby::ParserCombinator::TokenParseResult.success(token.value, tokens, position + 1)
            else
              TRuby::ParserCombinator::TokenParseResult.failure("not ident", tokens, position)
            end
          end
        end.new

        delim_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            return TRuby::ParserCombinator::TokenParseResult.failure("end", tokens, position) if position >= tokens.length

            token = tokens[position]
            if token.type == :COMMA
              TRuby::ParserCombinator::TokenParseResult.success(token.value, tokens, position + 1)
            else
              TRuby::ParserCombinator::TokenParseResult.failure("not comma", tokens, position)
            end
          end
        end.new

        parser = TRuby::ParserCombinator::TokenSepBy1.new(item_parser, delim_parser)
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to eq(%w[a b c])
      end

      it "fails when first item fails" do
        tokens = [mock_token(:COMMA, ",")]

        item_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            TRuby::ParserCombinator::TokenParseResult.failure("no item", tokens, position)
          end
        end.new

        delim_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            TRuby::ParserCombinator::TokenParseResult.success(",", tokens, position + 1)
          end
        end.new

        parser = TRuby::ParserCombinator::TokenSepBy1.new(item_parser, delim_parser)
        result = parser.parse(tokens, 0)

        expect(result.failure?).to be true
      end
    end

    describe TRuby::ParserCombinator::TokenLabel do
      it "adds label to error message on failure" do
        tokens = [mock_token(:OTHER, "x")]

        inner_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            TRuby::ParserCombinator::TokenParseResult.failure("generic error", tokens, position)
          end
        end.new

        parser = TRuby::ParserCombinator::TokenLabel.new(inner_parser, "identifier")
        result = parser.parse(tokens, 0)

        expect(result.failure?).to be true
        expect(result.error).to include("Expected identifier")
      end

      it "returns success unchanged" do
        tokens = [mock_token(:IDENT, "foo")]

        inner_parser = Class.new(TRuby::ParserCombinator::TokenParser) do
          def parse(tokens, position = 0)
            TRuby::ParserCombinator::TokenParseResult.success("foo", tokens, position + 1)
          end
        end.new

        parser = TRuby::ParserCombinator::TokenLabel.new(inner_parser, "identifier")
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to eq("foo")
      end
    end
  end
end
`,
  "spec/t_ruby/parser_extended_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::Parser do
  describe "type alias parsing" do
    context "simple type aliases" do
      it "parses simple type alias definitions" do
        source = "type UserId = String"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases]).to be_a(Array)
        expect(result[:type_aliases][0][:name]).to eq("UserId")
        expect(result[:type_aliases][0][:definition]).to eq("String")
      end

      it "parses multiple type alias definitions" do
        source = "type UserId = String\\ntype Age = Integer\\ntype Active = Boolean"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases].length).to eq(3)
        expect(result[:type_aliases][0][:name]).to eq("UserId")
        expect(result[:type_aliases][1][:name]).to eq("Age")
        expect(result[:type_aliases][2][:name]).to eq("Active")
      end
    end

    context "type alias with different basic types" do
      it "handles Integer type" do
        source = "type Count = Integer"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:definition]).to eq("Integer")
      end

      it "handles Boolean type" do
        source = "type IsActive = Boolean"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:definition]).to eq("Boolean")
      end

      it "handles Array type" do
        source = "type Items = Array"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:definition]).to eq("Array")
      end

      it "handles Hash type" do
        source = "type Data = Hash"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:definition]).to eq("Hash")
      end
    end

    context "type alias with references to other aliases" do
      it "parses reference to another type alias" do
        source = "type UserId = String\\ntype AdminId = UserId"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][1][:definition]).to eq("UserId")
      end
    end

    context "mixed functions and type aliases" do
      it "parses both functions and type aliases" do
        source = "type UserId = String\\ndef greet(id: UserId): String\\n  'hello'\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases].length).to eq(1)
        expect(result[:functions].length).to eq(1)
      end

      it "preserves order of definitions" do
        source = "type UserId = String\\ndef create(id: UserId): Boolean\\n  true\\nend\\ntype Result = Boolean"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:name]).to eq("UserId")
        expect(result[:functions][0][:name]).to eq("create")
        expect(result[:type_aliases][1][:name]).to eq("Result")
      end
    end

    context "type alias with spaces" do
      it "handles spaces around equals sign" do
        source = "type UserId  =  String"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:name]).to eq("UserId")
        expect(result[:type_aliases][0][:definition]).to eq("String")
      end

      it "handles leading spaces" do
        source = "  type UserId = String"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type_aliases][0][:name]).to eq("UserId")
      end
    end
  end
end
`,
  "spec/t_ruby/parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::Parser do
  describe "parsing function signatures" do
    context "with parameter types" do
      it "parses simple parameter type annotation" do
        source = "def greet(name: String)\\n  puts name\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result).to be_a(Hash)
        expect(result[:type]).to eq(:success)
      end

      it "parses multiple parameters with types" do
        source = "def add(a: Integer, b: Integer)\\n  a + b\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
      end

      it "extracts parameter names and types" do
        source = "def greet(name: String)\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions]).to be_a(Array)
        expect(result[:functions][0][:name]).to eq("greet")
        expect(result[:functions][0][:params]).to be_a(Array)
        expect(result[:functions][0][:params][0][:name]).to eq("name")
        expect(result[:functions][0][:params][0][:type]).to eq("String")
      end

      it "handles multiple parameters correctly" do
        source = "def create(name: String, age: Integer, active: Boolean)\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        params = result[:functions][0][:params]
        expect(params.length).to eq(3)
        expect(params[0][:type]).to eq("String")
        expect(params[1][:type]).to eq("Integer")
        expect(params[2][:type]).to eq("Boolean")
      end
    end

    context "with return types" do
      it "parses return type annotation" do
        source = "def get_name(): String\\n  'John'\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:functions][0][:return_type]).to eq("String")
      end

      it "parses void return type" do
        source = "def do_something(): void\\n  puts 'done'\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions][0][:return_type]).to eq("void")
      end

      it "handles both parameter and return types" do
        source = "def greet(name: String): String\\n  'Hello, ' + name\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        func = result[:functions][0]
        expect(func[:params][0][:type]).to eq("String")
        expect(func[:return_type]).to eq("String")
      end
    end

    context "with various type names" do
      it "supports basic types" do
        source = "def test(s: String, i: Integer, b: Boolean, n: nil): void\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
      end

      it "supports Array type" do
        source = "def process(items: Array): Array\\n  items\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions][0][:params][0][:type]).to eq("Array")
        expect(result[:functions][0][:return_type]).to eq("Array")
      end

      it "supports Hash type" do
        source = "def get_data(): Hash\\n  {}\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions][0][:return_type]).to eq("Hash")
      end

      it "supports Symbol type" do
        source = "def get_status(): Symbol\\n  :ok\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions][0][:return_type]).to eq("Symbol")
      end
    end

    context "with functions without types" do
      it "handles functions without any type annotations" do
        source = "def greet(name)\\n  puts name\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:functions][0][:params][0][:type]).to be_nil
      end

      it "handles functions with mixed typed and untyped params" do
        source = "def process(name: String, value)\\n  name + value.to_s\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        params = result[:functions][0][:params]
        expect(params[0][:type]).to eq("String")
        expect(params[1][:type]).to be_nil
      end
    end

    context "with multiple functions" do
      it "parses multiple functions in one source" do
        source = <<~RUBY
          def greet(name: String): String
            'Hello, ' + name
          end

          def add(a: Integer, b: Integer): Integer
            a + b
          end
        RUBY
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:functions].length).to eq(2)
        expect(result[:functions][0][:name]).to eq("greet")
        expect(result[:functions][1][:name]).to eq("add")
      end
    end

    context "error handling" do
      it "reports error for invalid type syntax" do
        source = "def test(x: NotAValidType)\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        # Parser should still parse but may flag as warning
        expect(result).to be_a(Hash)
      end

      it "handles malformed function definitions gracefully" do
        source = "def broken(x: String\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result).to be_a(Hash)
      end
    end

    context "with non-ASCII (Unicode) method names" do
      it "parses method names with Korean characters" do
        source = "def 안녕하세요(name: String): String\\n  name\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:functions].length).to eq(1)
        expect(result[:functions][0][:name]).to eq("안녕하세요")
        expect(result[:functions][0][:params][0][:type]).to eq("String")
        expect(result[:functions][0][:return_type]).to eq("String")
      end

      it "parses method names with mixed ASCII and Unicode characters" do
        source = "def 비_영어_함수명___테스트1!(name: String)\\n  name\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:functions].length).to eq(1)
        expect(result[:functions][0][:name]).to eq("비_영어_함수명___테스트1!")
      end

      it "parses method names with Japanese characters" do
        source = "def こんにちは(): String\\n  'hello'\\nend"
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:functions][0][:name]).to eq("こんにちは")
      end

      it "parses class methods with Unicode names" do
        source = <<~RUBY
          class HelloWorld
            def 인사하기(name: String): String
              "Hello, \\#{name}!"
            end
          end
        RUBY
        parser = TRuby::Parser.new(source)

        result = parser.parse
        expect(result[:type]).to eq(:success)
        expect(result[:classes].length).to eq(1)
        expect(result[:classes][0][:methods].length).to eq(1)
        expect(result[:classes][0][:methods][0][:name]).to eq("인사하기")
      end
    end
  end

  describe "parsing visibility modifiers" do
    context "with private def" do
      it "parses private def in class" do
        source = <<~RUBY
          class Example
            private def secret(x: String): Integer
              x.length
            end
          end
        RUBY
        parser = TRuby::Parser.new(source)
        result = parser.parse

        expect(result[:classes][0][:methods].length).to eq(1)
        expect(result[:classes][0][:methods][0][:name]).to eq("secret")
        expect(result[:classes][0][:methods][0][:visibility]).to eq(:private)
      end

      it "parses private def at top level" do
        source = <<~RUBY
          private def helper(x: String): String
            x.upcase
          end
        RUBY
        parser = TRuby::Parser.new(source)
        result = parser.parse

        expect(result[:functions].length).to eq(1)
        expect(result[:functions][0][:name]).to eq("helper")
        expect(result[:functions][0][:visibility]).to eq(:private)
      end
    end

    context "with protected def" do
      it "parses protected def in class" do
        source = <<~RUBY
          class Example
            protected def internal(n: Integer): Boolean
              n > 0
            end
          end
        RUBY
        parser = TRuby::Parser.new(source)
        result = parser.parse

        expect(result[:classes][0][:methods].length).to eq(1)
        expect(result[:classes][0][:methods][0][:name]).to eq("internal")
        expect(result[:classes][0][:methods][0][:visibility]).to eq(:protected)
      end
    end

    context "without visibility modifier" do
      it "defaults to public visibility" do
        source = "def hello(name: String): String\\n  name\\nend"
        parser = TRuby::Parser.new(source)
        result = parser.parse

        expect(result[:functions][0][:visibility]).to eq(:public)
      end
    end
  end

  describe "heredoc handling" do
    it "ignores def patterns inside heredoc" do
      source = <<~RUBY
        text = <<EOT
        Lorem ipsum
        def x(a: String)
        Dolor sit amet
        EOT

        def real_method(name: String): String
          name
        end
      RUBY
      parser = TRuby::Parser.new(source)
      result = parser.parse

      expect(result[:functions].length).to eq(1)
      expect(result[:functions][0][:name]).to eq("real_method")
    end

    it "handles squiggly heredoc" do
      source = <<~RUBY
        html = <<~HTML
          <script>
            def fake_method(x: Integer): void
          </script>
        HTML

        def process(data: String): Boolean
          true
        end
      RUBY
      parser = TRuby::Parser.new(source)
      result = parser.parse

      expect(result[:functions].length).to eq(1)
      expect(result[:functions][0][:name]).to eq("process")
    end

    it "handles heredoc with dash" do
      source = <<~RUBY
        sql = <<-SQL
          SELECT def from users
          WHERE def foo(x: String)
        SQL

        def query(table: String): Array
          []
        end
      RUBY
      parser = TRuby::Parser.new(source)
      result = parser.parse

      expect(result[:functions].length).to eq(1)
      expect(result[:functions][0][:name]).to eq("query")
    end

    it "ignores def patterns inside =begin/=end block comments" do
      source = <<~RUBY
        =begin
        def fake(x: String): Integer
          x
        end
        =end

        def real(name: String): String
          name
        end
      RUBY
      parser = TRuby::Parser.new(source)
      result = parser.parse

      expect(result[:functions].length).to eq(1)
      expect(result[:functions][0][:name]).to eq("real")
    end
  end

  describe "parsing namespaced interfaces" do
    it "parses namespaced interface correctly" do
      source = <<~RUBY
        interface Rails::Application
          config: String
        end
      RUBY
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces]).to be_a(Array)
      expect(result[:interfaces][0][:name]).to eq("Rails::Application")
    end

    it "parses deeply nested namespace" do
      source = <<~RUBY
        interface Rails::Application::Configuration
          root: Pathname
        end
      RUBY
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces][0][:name]).to eq("Rails::Application::Configuration")
    end

    it "parses interface with method signatures" do
      source = <<~RUBY
        interface Rails::Application
          initialize!: Rails::Application
          eager_load!: void
          initialized?: Boolean
        end
      RUBY
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces][0][:name]).to eq("Rails::Application")
      expect(result[:interfaces][0][:members].length).to eq(3)
    end

    it "parses multiple namespaced interfaces in one file" do
      source = <<~RUBY
        interface Rails
          env: String
        end

        interface Rails::Application
          config: String
        end

        interface ActiveRecord::Base
          id: Integer
        end
      RUBY
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:interfaces].length).to eq(3)
      expect(result[:interfaces].map { |i| i[:name] }).to eq([
                                                               "Rails",
                                                               "Rails::Application",
                                                               "ActiveRecord::Base",
                                                             ])
    end
  end
end
`,
  "spec/t_ruby/ruby_version_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::RubyVersion do
  describe ".parse" do
    it "parses major.minor version string" do
      version = described_class.parse("3.2")
      expect(version.major).to eq(3)
      expect(version.minor).to eq(2)
      expect(version.patch).to eq(0)
    end

    it "parses major.minor.patch version string" do
      version = described_class.parse("3.2.1")
      expect(version.major).to eq(3)
      expect(version.minor).to eq(2)
      expect(version.patch).to eq(1)
    end

    it "parses version with numeric input" do
      version = described_class.parse(3.2)
      expect(version.major).to eq(3)
      expect(version.minor).to eq(2)
    end

    it "raises error for invalid version format" do
      expect { described_class.parse("invalid") }.to raise_error(ArgumentError, /Invalid version/)
      expect { described_class.parse("3") }.to raise_error(ArgumentError, /Invalid version/)
      expect { described_class.parse("") }.to raise_error(ArgumentError, /Invalid version/)
    end
  end

  describe ".current" do
    it "returns the current Ruby version" do
      version = described_class.current
      expect(version).to be_a(described_class)

      parts = RUBY_VERSION.split(".")
      expect(version.major).to eq(parts[0].to_i)
      expect(version.minor).to eq(parts[1].to_i)
      expect(version.patch).to eq(parts[2].to_i)
    end
  end

  describe "comparison" do
    it "compares versions with ==" do
      expect(described_class.parse("3.2")).to eq(described_class.parse("3.2"))
      expect(described_class.parse("3.2")).to eq(described_class.parse("3.2.0"))
      expect(described_class.parse("3.2")).not_to eq(described_class.parse("3.3"))
    end

    it "compares versions with >=" do
      v32 = described_class.parse("3.2")
      v34 = described_class.parse("3.4")
      v40 = described_class.parse("4.0")

      expect(v34 >= v32).to be true
      expect(v32 >= v34).to be false
      expect(v40 >= v34).to be true
      expect(v32 == v32).to be true # rubocop:disable Lint/BinaryOperatorWithIdenticalOperands
    end

    it "compares versions with <" do
      v30 = described_class.parse("3.0")
      v34 = described_class.parse("3.4")

      expect(v30 < v34).to be true
      expect(v34 < v30).to be false
    end

    it "sorts versions correctly" do
      versions = [
        described_class.parse("4.0"),
        described_class.parse("3.0"),
        described_class.parse("3.4"),
        described_class.parse("3.1"),
      ]

      sorted = versions.sort
      expect(sorted.map(&:to_s)).to eq(%w[3.0 3.1 3.4 4.0])
    end
  end

  describe "#to_s" do
    it "returns major.minor format" do
      expect(described_class.parse("3.2").to_s).to eq("3.2")
      expect(described_class.parse("3.2.0").to_s).to eq("3.2")
      expect(described_class.parse("4.0").to_s).to eq("4.0")
    end

    it "includes patch version when non-zero" do
      expect(described_class.parse("3.2.1").to_s).to eq("3.2.1")
    end
  end

  describe "#supported?" do
    it "returns true for supported versions (3.0 ~ 4.x)" do
      expect(described_class.parse("3.0").supported?).to be true
      expect(described_class.parse("3.1").supported?).to be true
      expect(described_class.parse("3.4").supported?).to be true
      expect(described_class.parse("4.0").supported?).to be true
      expect(described_class.parse("4.1").supported?).to be true
    end

    it "returns false for unsupported versions" do
      expect(described_class.parse("2.7").supported?).to be false
      expect(described_class.parse("2.6").supported?).to be false
      expect(described_class.parse("5.0").supported?).to be false
    end
  end

  describe "#validate!" do
    it "returns self for supported versions" do
      version = described_class.parse("3.4")
      expect(version.validate!).to eq(version)
    end

    it "raises UnsupportedRubyVersionError for unsupported versions" do
      expect do
        described_class.parse("2.7").validate!
      end.to raise_error(TRuby::UnsupportedRubyVersionError, /2\\.7.*지원.*3\\.0.*4\\.x/i)

      expect do
        described_class.parse("5.0").validate!
      end.to raise_error(TRuby::UnsupportedRubyVersionError)
    end
  end

  describe "#supports_it_parameter?" do
    it "returns true for Ruby 3.4+" do
      expect(described_class.parse("3.4").supports_it_parameter?).to be true
      expect(described_class.parse("3.5").supports_it_parameter?).to be true
      expect(described_class.parse("4.0").supports_it_parameter?).to be true
    end

    it "returns false for Ruby < 3.4" do
      expect(described_class.parse("3.3").supports_it_parameter?).to be false
      expect(described_class.parse("3.0").supports_it_parameter?).to be false
    end
  end

  describe "#supports_anonymous_block_forwarding?" do
    it "returns true for Ruby 3.1+" do
      expect(described_class.parse("3.1").supports_anonymous_block_forwarding?).to be true
      expect(described_class.parse("3.4").supports_anonymous_block_forwarding?).to be true
      expect(described_class.parse("4.0").supports_anonymous_block_forwarding?).to be true
    end

    it "returns false for Ruby < 3.1" do
      expect(described_class.parse("3.0").supports_anonymous_block_forwarding?).to be false
    end
  end

  describe "#numbered_parameters_raise_error?" do
    it "returns true for Ruby 4.0+" do
      expect(described_class.parse("4.0").numbered_parameters_raise_error?).to be true
      expect(described_class.parse("4.1").numbered_parameters_raise_error?).to be true
    end

    it "returns false for Ruby < 4.0" do
      expect(described_class.parse("3.4").numbered_parameters_raise_error?).to be false
      expect(described_class.parse("3.0").numbered_parameters_raise_error?).to be false
    end
  end
end
`,
  "spec/t_ruby/runner_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::Runner do
  describe "#initialize" do
    it "initializes with default config" do
      runner = TRuby::Runner.new
      expect(runner).to be_a(TRuby::Runner)
    end

    it "accepts custom config" do
      config = TRuby::Config.new
      runner = TRuby::Runner.new(config)
      expect(runner).to be_a(TRuby::Runner)
    end
  end

  describe "#run_file" do
    context "with a valid .trb file" do
      it "executes the file and returns result" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "test.trb")
          File.write(input_file, "puts 'Hello from T-Ruby!'")

          runner = TRuby::Runner.new
          output = capture_stdout { runner.run_file(input_file) }

          expect(output).to include("Hello from T-Ruby!")
        end
      end

      it "strips type annotations before execution" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "typed.trb")
          File.write(input_file, <<~TRB)
            def greet(name: String): String
              "Hello, \\#{name}!"
            end
            puts greet("World")
          TRB

          runner = TRuby::Runner.new
          output = capture_stdout { runner.run_file(input_file) }

          expect(output).to include("Hello, World!")
        end
      end

      it "passes arguments via ARGV" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "args.trb")
          File.write(input_file, "puts ARGV.inspect")

          runner = TRuby::Runner.new
          output = capture_stdout { runner.run_file(input_file, %w[foo bar baz]) }

          expect(output).to include('["foo", "bar", "baz"]')
        end
      end

      it "sets $0 to the script path" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "dollar_zero.trb")
          File.write(input_file, "puts $0")

          runner = TRuby::Runner.new
          output = capture_stdout { runner.run_file(input_file) }

          expect(output.strip).to eq(input_file)
        end
      end
    end

    context "with a non-existent file" do
      it "prints error message and exits with status 1" do
        runner = TRuby::Runner.new

        expect do
          capture_stderr { runner.run_file("/nonexistent/file.trb") }
        end.to raise_error(SystemExit) do |exit_error|
          expect(exit_error.status).to eq(1)
        end
      end

      it "outputs error message to stderr" do
        runner = TRuby::Runner.new

        output = capture_stderr do
          runner.run_file("/nonexistent/file.trb")
        rescue SystemExit
          # Expected
        end

        expect(output).to include("Error: File not found")
        expect(output).to include("/nonexistent/file.trb")
      end
    end

    context "with compile errors" do
      it "prints errors and exits with status 1" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "error.trb")
          File.write(input_file, "puts 'hello'")

          # Mock compile_string to return errors
          compiler = instance_double(TRuby::Compiler)
          allow(TRuby::Compiler).to receive(:new).and_return(compiler)
          allow(compiler).to receive(:compile_string).and_return({
                                                                   ruby: "",
                                                                   rbs: "",
                                                                   errors: ["Syntax error at line 1"],
                                                                 })

          runner = TRuby::Runner.new

          expect do
            capture_stderr { runner.run_file(input_file) }
          end.to raise_error(SystemExit) do |exit_error|
            expect(exit_error.status).to eq(1)
          end
        end
      end
    end
  end

  describe "#run_string" do
    it "executes T-Ruby source code from a string" do
      runner = TRuby::Runner.new
      output = capture_stdout do
        runner.run_string("puts 'Hello from string!'")
      end

      expect(output).to include("Hello from string!")
    end

    it "strips type annotations" do
      runner = TRuby::Runner.new
      output = capture_stdout do
        runner.run_string(<<~TRB)
          def add(a: Integer, b: Integer): Integer
            a + b
          end
          puts add(1, 2)
        TRB
      end

      expect(output.strip).to eq("3")
    end

    it "returns true on success" do
      runner = TRuby::Runner.new
      result = capture_stdout { runner.run_string("puts 'ok'") }

      # run_string returns true on success
      expect(result).to include("ok")
    end

    it "returns false on compile error" do
      # Mock compile_string to return errors
      compiler = instance_double(TRuby::Compiler)
      allow(TRuby::Compiler).to receive(:new).and_return(compiler)
      allow(compiler).to receive(:compile_string).and_return({
                                                               ruby: "",
                                                               rbs: "",
                                                               errors: ["Syntax error"],
                                                             })

      runner = TRuby::Runner.new

      result = nil
      capture_stderr do
        result = runner.run_string("invalid code")
      end

      expect(result).to be false
    end

    it "passes arguments via ARGV" do
      runner = TRuby::Runner.new
      output = capture_stdout do
        runner.run_string("puts ARGV.join(',')", argv: %w[a b c])
      end

      expect(output.strip).to eq("a,b,c")
    end

    it "uses custom filename for error reporting" do
      runner = TRuby::Runner.new
      output = capture_stdout do
        runner.run_string("puts $0", filename: "custom_script.trb")
      end

      expect(output.strip).to eq("custom_script.trb")
    end
  end

  # Helper to capture stdout
  def capture_stdout
    old_stdout = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = old_stdout
  end

  # Helper to capture stderr
  def capture_stderr
    old_stderr = $stderr
    $stderr = StringIO.new
    yield
    $stderr.string
  ensure
    $stderr = old_stderr
  end
end

describe TRuby::RunnerCLI do
  describe ".start" do
    context "with --help flag" do
      it "displays help text" do
        output = capture_stdout { TRuby::RunnerCLI.start(["--help"]) }

        expect(output).to include("t-ruby")
        expect(output).to include("Usage:")
        expect(output).to include("Run a .trb file directly")
      end
    end

    context "with -h flag" do
      it "displays help text" do
        output = capture_stdout { TRuby::RunnerCLI.start(["-h"]) }

        expect(output).to include("Usage:")
      end
    end

    context "with --version flag" do
      it "displays version" do
        output = capture_stdout { TRuby::RunnerCLI.start(["--version"]) }

        expect(output).to include("t-ruby")
        expect(output).to include(TRuby::VERSION)
      end
    end

    context "with -v flag" do
      it "displays version" do
        output = capture_stdout { TRuby::RunnerCLI.start(["-v"]) }

        expect(output).to include(TRuby::VERSION)
      end
    end

    context "with no arguments" do
      it "displays help text" do
        output = capture_stdout { TRuby::RunnerCLI.start([]) }

        expect(output).to include("Usage:")
      end
    end

    context "with a valid .trb file" do
      it "executes the file" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "hello.trb")
          File.write(input_file, "puts 'Hello!'")

          output = capture_stdout { TRuby::RunnerCLI.start([input_file]) }

          expect(output).to include("Hello!")
        end
      end

      it "passes additional arguments to the script" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "args.trb")
          File.write(input_file, "puts ARGV.length")

          output = capture_stdout { TRuby::RunnerCLI.start([input_file, "one", "two", "three"]) }

          expect(output.strip).to eq("3")
        end
      end
    end
  end

  describe "#version" do
    it "outputs version string" do
      cli = TRuby::RunnerCLI.new
      output = capture_stdout { cli.version }

      expect(output).to include("t-ruby")
      expect(output).to include(TRuby::VERSION)
    end
  end

  describe "#help" do
    it "outputs help text with usage examples" do
      cli = TRuby::RunnerCLI.new
      output = capture_stdout { cli.help }

      expect(output).to include("Usage:")
      expect(output).to include("Examples:")
      expect(output).to include("t-ruby hello.trb")
      expect(output).to include("Notes:")
    end
  end

  # Helper to capture stdout
  def capture_stdout
    old_stdout = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = old_stdout
  end
end
`,
  "spec/t_ruby/runtime_validator_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ValidationConfig do
  let(:config) { TRuby::ValidationConfig.new }

  it "has default settings" do
    expect(config.validate_all).to be true
    expect(config.validate_public_only).to be false
    expect(config.raise_on_error).to be true
  end

  it "allows modifying settings" do
    config.validate_public_only = true
    expect(config.validate_public_only).to be true
  end
end

RSpec.describe TRuby::RuntimeValidator do
  let(:validator) { TRuby::RuntimeValidator.new }

  describe "#generate_type_check" do
    context "with simple types" do
      it "generates String check" do
        check = validator.generate_type_check("x", "String")
        expect(check).to eq("x.is_a?(String)")
      end

      it "generates Integer check" do
        check = validator.generate_type_check("x", "Integer")
        expect(check).to eq("x.is_a?(Integer)")
      end

      it "generates Boolean check" do
        check = validator.generate_type_check("x", "Boolean")
        expect(check).to eq("(x == true || x == false)")
      end

      it "generates nil check" do
        check = validator.generate_type_check("x", "nil")
        expect(check).to eq("x.nil?")
      end

      it "generates Symbol check" do
        check = validator.generate_type_check("x", "Symbol")
        expect(check).to eq("x.is_a?(Symbol)")
      end
    end

    context "with union types" do
      it "generates union check" do
        check = validator.generate_type_check("x", "String | Integer")
        expect(check).to include("x.is_a?(String)")
        expect(check).to include("x.is_a?(Integer)")
        expect(check).to include("||")
      end

      it "handles nil in union" do
        check = validator.generate_type_check("x", "String | nil")
        expect(check).to include("x.is_a?(String)")
        expect(check).to include("x.nil?")
      end
    end

    context "with generic types" do
      it "generates Array<T> check" do
        check = validator.generate_type_check("arr", "Array<String>")
        expect(check).to include("arr.is_a?(Array)")
        expect(check).to include("arr.all?")
      end

      it "generates Hash<K, V> check" do
        check = validator.generate_type_check("h", "Hash<String, Integer>")
        expect(check).to include("h.is_a?(Hash)")
        expect(check).to include("h.all?")
      end
    end

    context "with optional types" do
      it "generates optional check" do
        check = validator.generate_type_check("x", "String?")
        expect(check).to include("x.nil?")
        expect(check).to include("x.is_a?(String)")
        expect(check).to include("||")
      end
    end

    context "with intersection types" do
      it "generates intersection check" do
        check = validator.generate_type_check("x", "Readable & Writable")
        expect(check).to include("x.is_a?(Readable)")
        expect(check).to include("x.is_a?(Writable)")
        expect(check).to include("&&")
      end
    end
  end

  describe "#generate_param_validation" do
    it "generates raise statement by default" do
      validation = validator.generate_param_validation("name", "String")
      expect(validation).to include("raise")
      expect(validation).to include("unless")
    end

    it "generates warn statement when configured" do
      config = TRuby::ValidationConfig.new
      config.raise_on_error = false
      warn_validator = TRuby::RuntimeValidator.new(config)

      validation = warn_validator.generate_param_validation("name", "String")
      expect(validation).to include("warn")
    end
  end

  describe "#generate_function_validation" do
    it "generates validations for all typed parameters" do
      func_info = {
        name: "greet",
        params: [
          { name: "name", type: "String" },
          { name: "age", type: "Integer" },
        ],
        return_type: "String",
      }

      validations = validator.generate_function_validation(func_info)
      expect(validations.length).to eq(3) # 2 params + 1 return
    end

    it "skips untyped parameters" do
      func_info = {
        name: "foo",
        params: [
          { name: "x", type: nil },
          { name: "y", type: "String" },
        ],
        return_type: nil,
      }

      validations = validator.generate_function_validation(func_info)
      expect(validations.length).to eq(1)
    end
  end

  describe "#transform" do
    it "inserts validation code after function definition" do
      source = <<~RUBY
        def greet(name: String): String
          "Hello, \\#{name}"
        end
      RUBY

      parse_result = {
        functions: [
          {
            name: "greet",
            params: [{ name: "name", type: "String" }],
            return_type: "String",
          },
        ],
      }

      transformed = validator.transform(source, parse_result)
      expect(transformed).to include("raise")
      expect(transformed).to include("name")
    end
  end

  describe "#generate_validation_module" do
    it "generates a complete validation module" do
      functions = [
        {
          name: "add",
          params: [
            { name: "a", type: "Integer" },
            { name: "b", type: "Integer" },
          ],
          return_type: "Integer",
        },
      ]

      module_code = validator.generate_validation_module(functions)
      expect(module_code).to include("module TRubyValidation")
      expect(module_code).to include("validate_add_params")
      expect(module_code).to include("validate_type")
    end
  end

  describe "#should_validate?" do
    it "returns true for all when validate_all is true" do
      expect(validator.should_validate?(:private)).to be true
      expect(validator.should_validate?(:public)).to be true
    end

    it "returns true only for public when validate_public_only is true" do
      config = TRuby::ValidationConfig.new
      config.validate_all = false
      config.validate_public_only = true
      public_validator = TRuby::RuntimeValidator.new(config)

      expect(public_validator.should_validate?(:public)).to be true
      expect(public_validator.should_validate?(:private)).to be false
    end
  end
end

RSpec.describe TRuby::RuntimeTypeError do
  it "stores type information" do
    error = TRuby::RuntimeTypeError.new(
      "Type mismatch",
      expected_type: "String",
      actual_type: "Integer",
      value: 42
    )

    expect(error.expected_type).to eq("String")
    expect(error.actual_type).to eq("Integer")
    expect(error.value).to eq(42)
  end
end

RSpec.describe TRuby::RuntimeTypeChecks do
  let(:test_class) do
    Class.new do
      include TRuby::RuntimeTypeChecks

      def greet(name)
        validate_param(name, "String", "name")
        "Hello, #{name}"
      end

      def get_number
        result = 42
        validate_return(result, "Integer")
      end
    end
  end

  describe "#validate_param" do
    it "passes for correct type" do
      obj = test_class.new
      expect { obj.greet("World") }.not_to raise_error
    end

    it "raises for incorrect type" do
      obj = test_class.new
      expect { obj.greet(123) }.to raise_error(TRuby::RuntimeTypeError)
    end
  end

  describe "#validate_return" do
    it "returns value for correct type" do
      obj = test_class.new
      expect(obj.get_number).to eq(42)
    end
  end

  describe ".validate_types! and .skip_type_validation!" do
    it "can toggle validation" do
      test_class.skip_type_validation!
      expect(test_class.type_validation_enabled?).to be false

      test_class.validate_types!
      expect(test_class.type_validation_enabled?).to be true
    end
  end
end
`,
  "spec/t_ruby/scanner_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::Scanner do
  describe TRuby::Scanner::Token do
    it "holds token information" do
      token = described_class.new(:identifier, "foo", 0, 3, 1, 1)
      expect(token.type).to eq(:identifier)
      expect(token.value).to eq("foo")
      expect(token.start_pos).to eq(0)
      expect(token.end_pos).to eq(3)
      expect(token.line).to eq(1)
      expect(token.column).to eq(1)
    end
  end

  describe "#scan_all" do
    subject(:scanner) { described_class.new(source) }

    context "with keywords" do
      let(:source) { "def end class module if unless else elsif return type interface" }

      it "tokenizes all Ruby and T-Ruby keywords" do
        tokens = scanner.scan_all
        types = tokens.map(&:type)

        expect(types).to eq(%i[
                              def end class module if unless else elsif
                              return type interface eof
                            ])
      end
    end

    context "with visibility modifiers" do
      let(:source) { "public private protected" }

      it "tokenizes visibility modifiers" do
        tokens = scanner.scan_all
        types = tokens.map(&:type)

        expect(types).to eq(%i[public private protected eof])
      end
    end

    context "with identifiers" do
      let(:source) { "foo bar_baz camelCase method? dangerous!" }

      it "tokenizes identifiers including ? and ! suffixes" do
        tokens = scanner.scan_all
        values = tokens.reject { |t| t.type == :eof }.map(&:value)

        expect(values).to eq(%w[foo bar_baz camelCase method? dangerous!])
      end
    end

    context "with constants" do
      let(:source) { "String Integer MyClass CONSTANT" }

      it "tokenizes constants (uppercase start)" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to all(eq(:constant))
      end
    end

    context "with instance variables" do
      let(:source) { "@name @age @_private" }

      it "tokenizes instance variables" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to all(eq(:ivar))
        expect(tokens.map(&:value)).to eq(%w[@name @age @_private])
      end
    end

    context "with class variables" do
      let(:source) { "@@count @@instance" }

      it "tokenizes class variables" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to all(eq(:cvar))
        expect(tokens.map(&:value)).to eq(%w[@@count @@instance])
      end
    end

    context "with global variables" do
      let(:source) { "$stdout $stderr $0" }

      it "tokenizes global variables" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to all(eq(:gvar))
      end
    end

    context "with integer literals" do
      let(:source) { "0 42 -123 1_000_000" }

      it "tokenizes integer literals" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to eq(%i[integer integer minus integer integer])
        expect(tokens.map(&:value)).to eq(["0", "42", "-", "123", "1_000_000"])
      end
    end

    context "with float literals" do
      let(:source) { "3.14 0.5 -2.718" }

      it "tokenizes float literals" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to eq(%i[float float minus float])
      end
    end

    context "with string literals" do
      let(:source) { '"hello" \\'world\\'' }

      it "tokenizes simple string literals" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to eq(%i[string string])
        expect(tokens.map(&:value)).to eq(['"hello"', "'world'"])
      end
    end

    context "with string interpolation" do
      let(:source) { '"Hello #{name}!"' }

      it "tokenizes string with interpolation markers" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[
                              string_start string_content interpolation_start
                              identifier interpolation_end string_content string_end
                            ])
      end
    end

    context "with symbols" do
      let(:source) { ":foo :bar_baz :CamelCase" }

      it "tokenizes symbol literals" do
        tokens = scanner.scan_all
        tokens = tokens.reject { |t| t.type == :eof }

        expect(tokens.map(&:type)).to all(eq(:symbol))
        expect(tokens.map(&:value)).to eq([":foo", ":bar_baz", ":CamelCase"])
      end
    end

    context "with boolean and nil literals" do
      let(:source) { "true false nil" }

      it "tokenizes boolean and nil literals" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq([true, false, :nil])
      end
    end

    context "with operators" do
      let(:source) { "+ - * / % ** = == != < > <= >= <=> && || !" }

      it "tokenizes all operators" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[
                              plus minus star slash percent star_star
                              eq eq_eq bang_eq lt gt lt_eq gt_eq spaceship
                              and_and or_or bang
                            ])
      end
    end

    context "with type annotation operators" do
      let(:source) { ": -> | & ?" }

      it "tokenizes type annotation operators" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[colon arrow pipe amp question])
      end
    end

    context "with delimiters" do
      let(:source) { "( ) [ ] { } , ." }

      it "tokenizes all delimiters" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[
                              lparen rparen lbracket rbracket lbrace rbrace
                              comma dot
                            ])
      end
    end

    context "with double splat" do
      let(:source) { "**opts" }

      it "tokenizes double splat operator" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[star_star identifier])
      end
    end

    context "with newlines" do
      let(:source) { "foo\\nbar\\nbaz" }

      it "tokenizes newlines" do
        tokens = scanner.scan_all
        types = tokens.map(&:type)

        expect(types).to eq(%i[identifier newline identifier newline identifier eof])
      end
    end

    context "with comments" do
      let(:source) { "foo # this is a comment\\nbar" }

      it "tokenizes comments" do
        tokens = scanner.scan_all
        comment_token = tokens.find { |t| t.type == :comment }

        expect(comment_token).not_to be_nil
        expect(comment_token.value).to eq("# this is a comment")
      end
    end

    context "with a complete function definition" do
      let(:source) { "def greet(n: String): String" + "\\n" + '  "Hello #{n}"' + "\\n" + "end" }

      it "tokenizes a complete function" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        # T-Ruby uses : for return type annotation, not ->
        expect(types).to include(:def, :identifier, :lparen, :colon, :constant, :rparen, :colon, :end)
      end
    end

    context "with type alias" do
      let(:source) { "type UserId = Integer" }

      it "tokenizes type alias" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[type constant eq constant])
      end
    end

    context "with interface" do
      let(:source) { "interface Printable\\n  print: -> void\\nend" }

      it "tokenizes interface definition" do
        tokens = scanner.scan_all
        types = tokens.map(&:type)

        expect(types).to include(:interface, :constant, :newline, :identifier, :colon, :arrow, :identifier, :newline, :end)
      end
    end

    context "with generic types" do
      let(:source) { "Array<String>" }

      it "tokenizes generic type syntax" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[constant lt constant gt])
      end
    end

    context "with union types" do
      let(:source) { "String | Integer | nil" }

      it "tokenizes union type syntax" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[constant pipe constant pipe nil])
      end
    end

    context "with keyword arguments" do
      let(:source) { "{ name: String, age: Integer }" }

      it "tokenizes keyword argument group" do
        tokens = scanner.scan_all
        types = tokens.reject { |t| t.type == :eof }.map(&:type)

        expect(types).to eq(%i[
                              lbrace identifier colon constant comma
                              identifier colon constant rbrace
                            ])
      end
    end
  end

  describe "#next_token" do
    it "returns tokens one at a time" do
      scanner = described_class.new("foo bar")

      token1 = scanner.next_token
      expect(token1.type).to eq(:identifier)
      expect(token1.value).to eq("foo")

      token2 = scanner.next_token
      expect(token2.type).to eq(:identifier)
      expect(token2.value).to eq("bar")

      token3 = scanner.next_token
      expect(token3.type).to eq(:eof)
    end
  end

  describe "#peek" do
    it "looks ahead without consuming" do
      scanner = described_class.new("foo bar baz")

      peeked = scanner.peek
      expect(peeked.value).to eq("foo")

      # Should still return foo since peek doesn't consume
      token = scanner.next_token
      expect(token.value).to eq("foo")
    end

    it "can look ahead multiple tokens" do
      scanner = described_class.new("foo bar baz")

      tokens = scanner.peek(3)
      expect(tokens.map(&:value)).to eq(%w[foo bar baz])
    end
  end

  describe "position tracking" do
    it "tracks line and column correctly" do
      source = "foo\\nbar\\n  baz"
      scanner = described_class.new(source)
      tokens = scanner.scan_all

      foo = tokens[0]
      expect(foo.line).to eq(1)
      expect(foo.column).to eq(1)

      bar = tokens[2] # after newline
      expect(bar.line).to eq(2)
      expect(bar.column).to eq(1)

      baz = tokens[4] # after newline and spaces
      expect(baz.line).to eq(3)
      expect(baz.column).to eq(3)
    end
  end

  describe "error handling" do
    it "raises error on invalid character" do
      scanner = described_class.new("foo § bar")

      expect { scanner.scan_all }.to raise_error(TRuby::Scanner::ScanError) do |error|
        expect(error.message).to include("Unexpected character")
        expect(error.line).to eq(1)
        expect(error.column).to eq(5)
      end
    end

    it "raises error on unterminated string" do
      scanner = described_class.new('"hello')

      expect { scanner.scan_all }.to raise_error(TRuby::Scanner::ScanError) do |error|
        expect(error.message).to include("Unterminated string")
      end
    end
  end

  describe "heredoc handling" do
    let(:source) { "sql = <<~SQL\\n  SELECT * FROM users\\nSQL" }

    it "tokenizes heredoc as a unit" do
      scanner = described_class.new(source)
      tokens = scanner.scan_all

      heredoc_token = tokens.find { |t| t.type == :heredoc }
      expect(heredoc_token).not_to be_nil
    end
  end
end
`,
  "spec/t_ruby/smt_solver_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::SMT do
  include TRuby::SMT::DSL

  describe "Logical Formulas" do
    describe TRuby::SMT::Variable do
      it "has a name" do
        v = var("x")
        expect(v.name).to eq("x")
      end

      it "tracks free variables" do
        v = var("x")
        expect(v.free_variables).to include("x")
      end
    end

    describe TRuby::SMT::Not do
      it "negates a variable" do
        v = var("x")
        neg = !v
        expect(neg).to be_a(TRuby::SMT::Not)
        expect(neg.operand).to eq(v)
      end

      it "simplifies double negation" do
        v = var("x")
        double_neg = TRuby::SMT::Not.new(TRuby::SMT::Not.new(v))
        expect(double_neg.simplify).to eq(v)
      end

      it "simplifies negation of true" do
        result = (!TRuby::SMT::TRUE).simplify
        expect(result).to eq(TRuby::SMT::FALSE)
      end
    end

    describe TRuby::SMT::And do
      it "combines two formulas" do
        x = var("x")
        y = var("y")
        conj = x & y
        expect(conj).to be_a(TRuby::SMT::And)
      end

      it "simplifies with true" do
        x = var("x")
        result = (x & TRuby::SMT::TRUE).simplify
        expect(result).to eq(x)
      end

      it "simplifies with false" do
        x = var("x")
        result = (x & TRuby::SMT::FALSE).simplify
        expect(result).to eq(TRuby::SMT::FALSE)
      end

      it "simplifies identical operands" do
        x = var("x")
        result = (x & x).simplify
        expect(result).to eq(x)
      end
    end

    describe TRuby::SMT::Or do
      it "combines two formulas" do
        x = var("x")
        y = var("y")
        disj = x | y
        expect(disj).to be_a(TRuby::SMT::Or)
      end

      it "simplifies with true" do
        x = var("x")
        result = (x | TRuby::SMT::TRUE).simplify
        expect(result).to eq(TRuby::SMT::TRUE)
      end

      it "simplifies with false" do
        x = var("x")
        result = (x | TRuby::SMT::FALSE).simplify
        expect(result).to eq(x)
      end
    end

    describe TRuby::SMT::Implies do
      it "creates implication" do
        x = var("x")
        y = var("y")
        impl = x.implies(y)
        expect(impl).to be_a(TRuby::SMT::Implies)
      end

      it "simplifies to disjunction" do
        x = var("x")
        y = var("y")
        impl = x.implies(y)
        simplified = impl.simplify
        expect(simplified).to be_a(TRuby::SMT::Or)
      end
    end

    describe TRuby::SMT::Iff do
      it "creates biconditional" do
        x = var("x")
        y = var("y")
        iff = x.iff(y)
        expect(iff).to be_a(TRuby::SMT::Iff)
      end
    end

    describe "#substitute" do
      it "replaces variables with values" do
        x = var("x")
        y = var("y")
        formula = x & y

        result = formula.substitute({ "x" => TRuby::SMT::TRUE })
        expect(result.left).to eq(TRuby::SMT::TRUE)
        expect(result.right).to eq(y)
      end
    end

    describe "#to_cnf" do
      it "converts simple variable to CNF" do
        x = var("x")
        cnf = x.to_cnf
        expect(cnf).to eq([["x"]])
      end

      it "converts negation to CNF" do
        x = var("x")
        cnf = (!x).to_cnf
        expect(cnf).to eq([["!x"]])
      end

      it "converts conjunction to CNF" do
        x = var("x")
        y = var("y")
        cnf = (x & y).to_cnf
        expect(cnf).to eq([["x"], ["y"]])
      end

      it "converts disjunction to CNF" do
        x = var("x")
        y = var("y")
        cnf = (x | y).to_cnf
        expect(cnf).to eq([%w[x y]])
      end
    end
  end

  describe "Type Constraints" do
    describe TRuby::SMT::TypeVar do
      it "creates type variable" do
        t = type_var("T")
        expect(t.name).to eq("T")
      end

      it "can have bounds" do
        t = type_var("T", bounds: { upper: "Object" })
        expect(t.bounds[:upper]).to eq("Object")
      end
    end

    describe TRuby::SMT::Subtype do
      it "creates subtype constraint" do
        t1 = type_var("T1")
        t2 = type_var("T2")
        constraint = subtype(t1, t2)

        expect(constraint.subtype).to eq(t1)
        expect(constraint.supertype).to eq(t2)
      end

      it "tracks free variables" do
        t1 = type_var("T1")
        t2 = type_var("T2")
        constraint = subtype(t1, t2)

        expect(constraint.free_variables).to include("T1", "T2")
      end
    end

    describe TRuby::SMT::TypeEqual do
      it "creates equality constraint" do
        t1 = type_var("T1")
        t2 = type_var("T2")
        constraint = type_equal(t1, t2)

        expect(constraint.left).to eq(t1)
        expect(constraint.right).to eq(t2)
      end

      it "simplifies when equal" do
        t = type_var("T")
        constraint = type_equal(t, t)
        expect(constraint.simplify).to eq(TRuby::SMT::TRUE)
      end
    end

    describe TRuby::SMT::HasProperty do
      it "creates property constraint" do
        t = type_var("T")
        prop_type = concrete("String")
        constraint = has_property(t, "name", prop_type)

        expect(constraint.type_var).to eq(t)
        expect(constraint.property).to eq("name")
        expect(constraint.property_type).to eq(prop_type)
      end
    end

    describe TRuby::SMT::ConcreteType do
      it "wraps type name" do
        t = concrete("String")
        expect(t.name).to eq("String")
      end

      it "compares by name" do
        t1 = concrete("String")
        t2 = concrete("String")
        expect(t1).to eq(t2)
      end
    end
  end

  describe TRuby::SMT::SATSolver do
    let(:solver) { described_class.new }

    it "solves simple satisfiable formula" do
      cnf = [["x"], ["y"]]
      result = solver.solve(cnf)

      expect(result).not_to be_nil
      expect(result["x"]).to be true
      expect(result["y"]).to be true
    end

    it "returns nil for unsatisfiable formula" do
      cnf = [["x"], ["!x"]]
      result = solver.solve(cnf)

      expect(result).to be_nil
    end

    it "solves disjunction" do
      cnf = [%w[x y]]
      result = solver.solve(cnf)

      expect(result).not_to be_nil
      expect(result["x"] || result["y"]).to be true
    end

    it "handles complex formulas" do
      # (x || y) && (!x || z) && (!y || !z)
      cnf = [["x", "y"], ["!x", "z"], ["!y", "!z"]]
      result = solver.solve(cnf)

      expect(result).not_to be_nil
    end

    it "handles empty formula (trivially satisfiable)" do
      result = solver.solve([])
      expect(result).to eq({})
    end
  end

  describe TRuby::SMT::ConstraintSolver do
    let(:solver) { described_class.new }

    describe "#fresh_var" do
      it "creates unique type variables" do
        v1 = solver.fresh_var
        v2 = solver.fresh_var

        expect(v1.name).not_to eq(v2.name)
      end

      it "uses provided prefix" do
        v = solver.fresh_var("Param")
        expect(v.name).to start_with("Param")
      end
    end

    describe "#add_constraint" do
      it "stores constraints" do
        t1 = solver.fresh_var
        t2 = concrete("String")
        solver.add_equal(t1, t2)

        expect(solver.constraints.length).to eq(1)
      end
    end

    describe "#subtype?" do
      it "returns true for equal types" do
        t = concrete("String")
        expect(solver.subtype?(t, t)).to be true
      end

      it "returns true for Object supertype" do
        t = concrete("String")
        obj = concrete("Object")
        expect(solver.subtype?(t, obj)).to be true
      end

      it "returns true for nil subtype" do
        nil_type = concrete("nil")
        string = concrete("String")
        expect(solver.subtype?(nil_type, string)).to be true
      end

      it "checks type hierarchy" do
        int = concrete("Integer")
        num = concrete("Numeric")
        expect(solver.subtype?(int, num)).to be true
      end

      it "checks transitive hierarchy" do
        int = concrete("Integer")
        obj = concrete("Object")
        expect(solver.subtype?(int, obj)).to be true
      end

      it "returns false for incompatible types" do
        string = concrete("String")
        int = concrete("Integer")
        expect(solver.subtype?(string, int)).to be false
      end
    end

    describe "#solve" do
      it "solves equality constraints" do
        t1 = solver.fresh_var
        t2 = concrete("String")
        solver.add_equal(t1, t2)

        result = solver.solve

        expect(result[:success]).to be true
        expect(result[:solution][t1.name].name).to eq("String")
      end

      it "solves chained equalities" do
        t1 = solver.fresh_var
        t2 = solver.fresh_var
        t3 = concrete("Integer")

        solver.add_equal(t1, t2)
        solver.add_equal(t2, t3)

        result = solver.solve

        expect(result[:success]).to be true
      end

      it "validates subtype constraints" do
        t1 = concrete("Integer")
        t2 = concrete("Numeric")
        solver.add_subtype(t1, t2)

        result = solver.solve

        expect(result[:success]).to be true
      end

      it "fails on invalid subtype" do
        t1 = concrete("String")
        t2 = concrete("Integer")
        solver.add_subtype(t1, t2)

        result = solver.solve

        expect(result[:success]).to be false
        expect(result[:errors]).not_to be_empty
      end

      it "instantiates unconstrained variables to Object" do
        t = solver.fresh_var

        result = solver.solve

        expect(result[:success]).to be true
        expect(result[:solution][t.name].name).to eq("Object")
      end
    end

    describe "#infer" do
      it "returns solved type for variable" do
        t = solver.fresh_var
        solver.add_equal(t, concrete("String"))
        solver.solve

        expect(solver.infer(t).name).to eq("String")
      end
    end
  end

  describe TRuby::SMT::TypeInferenceEngine do
    let(:engine) { described_class.new }

    describe "#infer_method" do
      it "infers types for annotated method" do
        method = TRuby::IR::MethodDef.new(
          name: "greet",
          params: [
            TRuby::IR::Parameter.new(
              name: "name",
              type_annotation: TRuby::IR::SimpleType.new(name: "String")
            ),
          ],
          return_type: TRuby::IR::SimpleType.new(name: "String")
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
        expect(result[:params]["name"]).to eq("String")
        expect(result[:return_type]).to eq("String")
      end

      it "infers types for partially annotated method" do
        method = TRuby::IR::MethodDef.new(
          name: "process",
          params: [
            TRuby::IR::Parameter.new(name: "x"),
            TRuby::IR::Parameter.new(
              name: "y",
              type_annotation: TRuby::IR::SimpleType.new(name: "Integer")
            ),
          ],
          return_type: nil
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
        expect(result[:params]["y"]).to eq("Integer")
      end

      it "infers from return statement" do
        ret_stmt = TRuby::IR::Return.new(
          value: TRuby::IR::Literal.new(value: "hello", literal_type: :string)
        )

        method = TRuby::IR::MethodDef.new(
          name: "get_string",
          params: [],
          return_type: nil,
          body: TRuby::IR::Block.new(statements: [ret_stmt])
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
      end

      it "infers from assignments" do
        assign = TRuby::IR::Assignment.new(
          target: "x",
          value: TRuby::IR::Literal.new(value: 42, literal_type: :integer)
        )

        ret = TRuby::IR::Return.new(
          value: TRuby::IR::VariableRef.new(name: "x")
        )

        method = TRuby::IR::MethodDef.new(
          name: "get_number",
          params: [],
          return_type: TRuby::IR::SimpleType.new(name: "Integer"),
          body: TRuby::IR::Block.new(statements: [assign, ret])
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
      end

      it "infers from method calls" do
        call = TRuby::IR::MethodCall.new(
          receiver: TRuby::IR::Literal.new(value: "hello", literal_type: :string),
          method_name: "length"
        )

        ret = TRuby::IR::Return.new(value: call)

        method = TRuby::IR::MethodDef.new(
          name: "get_length",
          params: [],
          return_type: nil,
          body: TRuby::IR::Block.new(statements: [ret])
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
      end

      it "validates binary operation constraints" do
        add = TRuby::IR::BinaryOp.new(
          operator: "+",
          left: TRuby::IR::VariableRef.new(name: "a"),
          right: TRuby::IR::VariableRef.new(name: "b")
        )

        ret = TRuby::IR::Return.new(value: add)

        method = TRuby::IR::MethodDef.new(
          name: "add",
          params: [
            TRuby::IR::Parameter.new(
              name: "a",
              type_annotation: TRuby::IR::SimpleType.new(name: "Integer")
            ),
            TRuby::IR::Parameter.new(
              name: "b",
              type_annotation: TRuby::IR::SimpleType.new(name: "Integer")
            ),
          ],
          return_type: nil,
          body: TRuby::IR::Block.new(statements: [ret])
        )

        result = engine.infer_method(method)

        expect(result[:success]).to be true
      end
    end
  end

  describe "DSL" do
    it "provides var helper" do
      v = var("x")
      expect(v).to be_a(TRuby::SMT::Variable)
    end

    it "provides type_var helper" do
      t = type_var("T")
      expect(t).to be_a(TRuby::SMT::TypeVar)
    end

    it "provides concrete helper" do
      c = concrete("String")
      expect(c).to be_a(TRuby::SMT::ConcreteType)
    end

    it "provides all helper" do
      x = var("x")
      y = var("y")
      z = var("z")
      result = all(x, y, z)
      expect(result).to be_a(TRuby::SMT::And)
    end

    it "provides any helper" do
      x = var("x")
      y = var("y")
      result = any(x, y)
      expect(result).to be_a(TRuby::SMT::Or)
    end
  end

  # Additional coverage tests
  describe "Formula base class" do
    it "raises NotImplementedError for free_variables" do
      formula = TRuby::SMT::Formula.new
      expect { formula.free_variables }.to raise_error(NotImplementedError)
    end

    it "raises NotImplementedError for substitute" do
      formula = TRuby::SMT::Formula.new
      expect { formula.substitute({}) }.to raise_error(NotImplementedError)
    end

    it "raises NotImplementedError for to_cnf" do
      formula = TRuby::SMT::Formula.new
      expect { formula.to_cnf }.to raise_error(NotImplementedError)
    end
  end

  describe TRuby::SMT::BoolConst do
    it "returns empty set for free_variables" do
      expect(TRuby::SMT::TRUE.free_variables).to eq(Set.new)
    end

    it "returns self for substitute" do
      result = TRuby::SMT::TRUE.substitute({ "x" => TRuby::SMT::FALSE })
      expect(result).to eq(TRuby::SMT::TRUE)
    end

    it "returns CNF for to_cnf" do
      expect(TRuby::SMT::TRUE.to_cnf).to eq([[]])
    end

    it "returns string for to_s" do
      expect(TRuby::SMT::TRUE.to_s).to eq("true")
      expect(TRuby::SMT::FALSE.to_s).to eq("false")
    end
  end

  describe TRuby::SMT::Variable do
    it "has consistent hash based on name" do
      v1 = var("x")
      v2 = var("x")
      expect(v1.hash).to eq(v2.hash)
    end

    it "implements eql? for hash key equality" do
      v1 = var("x")
      v2 = var("x")
      expect(v1.eql?(v2)).to be true
    end

    it "returns name for to_s" do
      v = var("my_var")
      expect(v.to_s).to eq("my_var")
    end
  end

  describe TRuby::SMT::Not do
    it "returns operand free_variables" do
      v = var("x")
      neg = !v
      expect(neg.free_variables).to eq(Set.new(["x"]))
    end

    it "substitutes in operand" do
      v = var("x")
      neg = !v
      result = neg.substitute({ "x" => TRuby::SMT::TRUE })
      expect(result.operand).to eq(TRuby::SMT::TRUE)
    end

    it "converts double negation to CNF" do
      v = var("x")
      double_neg = TRuby::SMT::Not.new(TRuby::SMT::Not.new(v))
      cnf = double_neg.to_cnf
      expect(cnf).to eq([["x"]])
    end

    it "converts negation of And to CNF (De Morgan)" do
      x = var("x")
      y = var("y")
      neg_and = TRuby::SMT::Not.new(x & y)
      cnf = neg_and.to_cnf
      expect(cnf).to be_a(Array)
    end

    it "converts negation of Or to CNF (De Morgan)" do
      x = var("x")
      y = var("y")
      neg_or = TRuby::SMT::Not.new(x | y)
      cnf = neg_or.to_cnf
      expect(cnf).to eq([["!x"], ["!y"]])
    end

    it "converts negation of unknown to CNF" do
      bool = TRuby::SMT::TRUE
      neg = TRuby::SMT::Not.new(bool)
      cnf = neg.to_cnf
      expect(cnf).to be_a(Array)
    end

    it "returns string for to_s" do
      v = var("x")
      neg = !v
      expect(neg.to_s).to eq("!x")
    end
  end

  describe TRuby::SMT::And do
    it "returns combined free_variables" do
      x = var("x")
      y = var("y")
      conj = x & y
      expect(conj.free_variables).to eq(Set.new(%w[x y]))
    end

    it "creates new And when simplify produces neither TRUE nor FALSE" do
      x = var("x")
      y = var("y")
      result = (x & y).simplify
      expect(result).to be_a(TRuby::SMT::And)
    end

    it "implements ==" do
      x = var("x")
      y = var("y")
      a1 = x & y
      a2 = x & y
      expect(a1 == a2).to be true
    end

    it "returns string for to_s" do
      x = var("x")
      y = var("y")
      expect((x & y).to_s).to eq("(x && y)")
    end
  end

  describe TRuby::SMT::Or do
    it "returns combined free_variables" do
      x = var("x")
      y = var("y")
      disj = x | y
      expect(disj.free_variables).to eq(Set.new(%w[x y]))
    end

    it "substitutes in both operands" do
      x = var("x")
      y = var("y")
      disj = x | y
      result = disj.substitute({ "x" => TRuby::SMT::TRUE })
      expect(result.left).to eq(TRuby::SMT::TRUE)
    end

    it "implements ==" do
      x = var("x")
      y = var("y")
      o1 = x | y
      o2 = x | y
      expect(o1 == o2).to be true
    end

    it "returns string for to_s" do
      x = var("x")
      y = var("y")
      expect((x | y).to_s).to eq("(x || y)")
    end
  end

  describe TRuby::SMT::Implies do
    it "returns combined free_variables" do
      x = var("x")
      y = var("y")
      impl = x.implies(y)
      expect(impl.free_variables).to eq(Set.new(%w[x y]))
    end

    it "substitutes in both operands" do
      x = var("x")
      y = var("y")
      impl = x.implies(y)
      result = impl.substitute({ "x" => TRuby::SMT::TRUE })
      expect(result.antecedent).to eq(TRuby::SMT::TRUE)
    end

    it "converts to CNF" do
      x = var("x")
      y = var("y")
      impl = x.implies(y)
      cnf = impl.to_cnf
      expect(cnf).to be_a(Array)
    end

    it "implements ==" do
      x = var("x")
      y = var("y")
      i1 = x.implies(y)
      i2 = x.implies(y)
      expect(i1 == i2).to be true
    end

    it "returns string for to_s" do
      x = var("x")
      y = var("y")
      expect(x.implies(y).to_s).to eq("(x -> y)")
    end
  end

  describe TRuby::SMT::Iff do
    it "returns combined free_variables" do
      x = var("x")
      y = var("y")
      iff = x.iff(y)
      expect(iff.free_variables).to eq(Set.new(%w[x y]))
    end

    it "substitutes in both operands" do
      x = var("x")
      y = var("y")
      iff = x.iff(y)
      result = iff.substitute({ "x" => TRuby::SMT::TRUE })
      expect(result.left).to eq(TRuby::SMT::TRUE)
    end

    it "simplifies to conjunction of implications" do
      x = var("x")
      y = var("y")
      iff = x.iff(y)
      simplified = iff.simplify
      # A <-> B = (A -> B) & (B -> A) which simplifies to And with Or operands
      expect(simplified).to be_a(TRuby::SMT::And)
    end

    it "converts to CNF" do
      x = var("x")
      y = var("y")
      iff = x.iff(y)
      cnf = iff.to_cnf
      expect(cnf).to be_a(Array)
    end

    it "implements ==" do
      x = var("x")
      y = var("y")
      iff1 = x.iff(y)
      iff2 = x.iff(y)
      expect(iff1 == iff2).to be true
    end

    it "returns string for to_s" do
      x = var("x")
      y = var("y")
      expect(x.iff(y).to_s).to eq("(x <-> y)")
    end
  end

  describe TRuby::SMT::TypeVar do
    it "substitutes when binding exists" do
      t = type_var("T")
      concrete_type = concrete("String")
      result = t.substitute({ "T" => concrete_type })
      expect(result).to eq(concrete_type)
    end

    it "returns self when no binding" do
      t = type_var("T")
      result = t.substitute({ "X" => concrete("String") })
      expect(result).to eq(t)
    end

    it "converts to CNF" do
      t = type_var("T")
      expect(t.to_cnf).to eq([["T"]])
    end

    it "has consistent hash" do
      t1 = type_var("T")
      t2 = type_var("T")
      expect(t1.hash).to eq(t2.hash)
    end

    it "implements eql?" do
      t1 = type_var("T")
      t2 = type_var("T")
      expect(t1.eql?(t2)).to be true
    end

    it "returns name for to_s" do
      t = type_var("MyType")
      expect(t.to_s).to eq("MyType")
    end
  end

  describe TRuby::SMT::Subtype do
    it "substitutes with concrete types" do
      sub = subtype(concrete("Integer"), concrete("Numeric"))
      result = sub.substitute({ "Integer" => concrete("Float") })
      expect(result.subtype.name).to eq("Integer")
    end

    it "substitutes type vars" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      sub = subtype(t1, t2)
      result = sub.substitute({ "T1" => concrete("String") })
      expect(result.subtype.name).to eq("String")
    end

    it "returns string for to_s" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      expect(subtype(t1, t2).to_s).to eq("T1 <: T2")
    end

    it "converts to CNF" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      cnf = subtype(t1, t2).to_cnf
      expect(cnf).to eq([["T1<:T2"]])
    end
  end

  describe TRuby::SMT::TypeEqual do
    it "substitutes type vars" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      eq = type_equal(t1, t2)
      result = eq.substitute({ "T1" => concrete("String") })
      expect(result.left.name).to eq("String")
    end

    it "returns string for to_s" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      expect(type_equal(t1, t2).to_s).to eq("T1 = T2")
    end

    it "converts to CNF" do
      t1 = type_var("T1")
      t2 = type_var("T2")
      cnf = type_equal(t1, t2).to_cnf
      expect(cnf).to eq([["T1=T2"]])
    end
  end

  describe TRuby::SMT::HasProperty do
    it "returns free_variables from type_var and property_type" do
      t = type_var("T")
      pt = type_var("PT")
      prop = has_property(t, "name", pt)
      expect(prop.free_variables).to eq(Set.new(%w[T PT]))
    end

    it "substitutes type_var and property_type" do
      t = type_var("T")
      pt = type_var("PT")
      prop = has_property(t, "name", pt)
      result = prop.substitute({ "T" => concrete("User"), "PT" => concrete("String") })
      expect(result.type_var.name).to eq("User")
      expect(result.property_type.name).to eq("String")
    end

    it "converts to CNF" do
      t = type_var("T")
      pt = concrete("String")
      prop = has_property(t, "name", pt)
      cnf = prop.to_cnf
      expect(cnf).to eq([["T.name:String"]])
    end

    it "returns string for to_s" do
      t = type_var("T")
      pt = concrete("String")
      prop = has_property(t, "name", pt)
      expect(prop.to_s).to eq("T has name: String")
    end
  end

  describe TRuby::SMT::ConcreteType do
    it "has consistent hash based on name" do
      t1 = concrete("String")
      t2 = concrete("String")
      expect(t1.hash).to eq(t2.hash)
    end

    it "implements eql?" do
      t1 = concrete("String")
      t2 = concrete("String")
      expect(t1.eql?(t2)).to be true
    end

    it "returns name for to_s" do
      t = concrete("MyClass")
      expect(t.to_s).to eq("MyClass")
    end
  end

  describe TRuby::SMT::TypeInferenceEngine do
    let(:engine) { described_class.new }

    describe "#infer_expression" do
      it "infers array literal type" do
        arr = TRuby::IR::ArrayLiteral.new(
          elements: [
            TRuby::IR::Literal.new(value: 1, literal_type: :integer),
            TRuby::IR::Literal.new(value: 2, literal_type: :integer),
          ]
        )
        result = engine.infer_expression(arr)
        expect(result.name).to eq("Array")
      end

      it "handles empty array literal" do
        arr = TRuby::IR::ArrayLiteral.new(elements: [])
        result = engine.infer_expression(arr)
        expect(result.name).to eq("Array")
      end

      it "creates fresh var for unknown expression" do
        # Using a generic struct as unknown expression type
        unknown = Struct.new(:type).new(:unknown)
        result = engine.infer_expression(unknown)
        expect(result).to be_a(TRuby::SMT::TypeVar)
      end

      it "handles method call without receiver" do
        call = TRuby::IR::MethodCall.new(
          receiver: nil,
          method_name: "some_method"
        )
        result = engine.infer_expression(call)
        expect(result).to be_a(TRuby::SMT::TypeVar)
      end

      it "handles comparison operators" do
        cmp = TRuby::IR::BinaryOp.new(
          operator: "==",
          left: TRuby::IR::Literal.new(value: 1, literal_type: :integer),
          right: TRuby::IR::Literal.new(value: 2, literal_type: :integer)
        )
        result = engine.infer_expression(cmp)
        expect(result.name).to eq("Boolean")
      end

      it "handles logical operators" do
        logical = TRuby::IR::BinaryOp.new(
          operator: "&&",
          left: TRuby::IR::Literal.new(value: true, literal_type: :boolean),
          right: TRuby::IR::Literal.new(value: false, literal_type: :boolean)
        )
        result = engine.infer_expression(logical)
        expect(result.name).to eq("Boolean")
      end

      it "handles unknown operators" do
        unknown_op = TRuby::IR::BinaryOp.new(
          operator: "**",
          left: TRuby::IR::Literal.new(value: 2, literal_type: :integer),
          right: TRuby::IR::Literal.new(value: 3, literal_type: :integer)
        )
        result = engine.infer_expression(unknown_op)
        expect(result).to be_a(TRuby::SMT::TypeVar)
      end
    end

    describe "#infer_statement" do
      it "handles assignment with type annotation" do
        assign = TRuby::IR::Assignment.new(
          target: "x",
          value: TRuby::IR::Literal.new(value: 42, literal_type: :integer),
          type_annotation: TRuby::IR::SimpleType.new(name: "Numeric")
        )
        # Need to set up method context
        engine.infer_statement(assign, TRuby::SMT::ConcreteType.new("Object"))
        expect(engine.type_env["x"]).to be_a(TRuby::SMT::ConcreteType)
      end

      it "handles conditional statements" do
        cond = TRuby::IR::Conditional.new(
          condition: TRuby::IR::Literal.new(value: true, literal_type: :boolean),
          then_branch: TRuby::IR::Block.new(statements: []),
          else_branch: TRuby::IR::Block.new(statements: [])
        )
        engine.infer_statement(cond, TRuby::SMT::ConcreteType.new("Object"))
        # Should not raise
      end
    end

    describe "#infer_method with generic types" do
      it "handles generic type annotations" do
        method = TRuby::IR::MethodDef.new(
          name: "get_first",
          params: [
            TRuby::IR::Parameter.new(
              name: "arr",
              type_annotation: TRuby::IR::GenericType.new(base: "Array", type_args: ["T"])
            ),
          ],
          return_type: nil
        )

        result = engine.infer_method(method)
        expect(result[:success]).to be true
      end

      it "handles union type annotations" do
        method = TRuby::IR::MethodDef.new(
          name: "process",
          params: [
            TRuby::IR::Parameter.new(
              name: "val",
              type_annotation: TRuby::IR::UnionType.new(types: %w[String Integer])
            ),
          ],
          return_type: nil
        )

        result = engine.infer_method(method)
        expect(result[:success]).to be true
      end

      it "handles nullable type annotations" do
        method = TRuby::IR::MethodDef.new(
          name: "maybe_string",
          params: [
            TRuby::IR::Parameter.new(
              name: "val",
              type_annotation: TRuby::IR::NullableType.new(inner_type: "String")
            ),
          ],
          return_type: nil
        )

        result = engine.infer_method(method)
        expect(result[:success]).to be true
      end

      it "handles unknown type annotation" do
        unknown_type = Struct.new(:type).new(:unknown)
        method = TRuby::IR::MethodDef.new(
          name: "test",
          params: [
            TRuby::IR::Parameter.new(name: "val", type_annotation: unknown_type),
          ],
          return_type: nil
        )

        result = engine.infer_method(method)
        expect(result[:success]).to be true
      end
    end

    describe "#infer_body" do
      it "handles Return directly" do
        ret = TRuby::IR::Return.new(
          value: TRuby::IR::Literal.new(value: "test", literal_type: :string)
        )
        # Should not raise
        engine.infer_body(ret, TRuby::SMT::ConcreteType.new("String"))
      end
    end

    describe "literal type inference" do
      it "infers all literal types" do
        literals = [
          [:string, "String"],
          [:integer, "Integer"],
          [:float, "Float"],
          [:boolean, "Boolean"],
          [:symbol, "Symbol"],
          [:nil, "nil"],
          [:array, "Array"],
          [:hash, "Hash"],
          [:unknown, "Object"],
        ]

        literals.each do |lit_type, expected_type|
          lit = TRuby::IR::Literal.new(value: nil, literal_type: lit_type)
          result = engine.infer_expression(lit)
          expect(result.name).to eq(expected_type), "Expected #{lit_type} to infer as #{expected_type}"
        end
      end
    end
  end

  describe TRuby::SMT::ConstraintSolver do
    let(:solver) { described_class.new }

    describe "unification edge cases" do
      it "fails unification on incompatible concrete types" do
        solver.add_equal(concrete("String"), concrete("Integer"))
        result = solver.solve
        expect(result[:success]).to be false
      end

      it "handles occurs check" do
        # T = Array[T] would cause infinite recursion
        t = solver.fresh_var
        # Create a scenario where occurs check matters
        solver.add_equal(t, t)
        result = solver.solve
        expect(result[:success]).to be true
      end
    end
  end
end
`,
  "spec/t_ruby/statement_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator::StatementParser do
  include TRuby::ParserCombinator::TokenDSL

  let(:parser) { described_class.new }
  let(:scanner) { TRuby::Scanner.new(source) }
  let(:tokens) { scanner.scan_all }

  describe "expression statements" do
    let(:source) { "foo(1, 2)" }

    it "parses expression as statement" do
      result = parser.parse_statement(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::MethodCall)
    end
  end

  describe "assignment statements" do
    describe "local variable assignment" do
      let(:source) { "x = 42" }

      it "parses simple assignment" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Assignment)
        expect(result.value.target).to eq("x")
        expect(result.value.value).to be_a(TRuby::IR::Literal)
        expect(result.value.value.value).to eq(42)
      end
    end

    describe "instance variable assignment" do
      let(:source) { "@name = value" }

      it "parses instance variable assignment" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Assignment)
        expect(result.value.target).to eq("@name")
      end
    end

    describe "class variable assignment" do
      let(:source) { "@@count = 0" }

      it "parses class variable assignment" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.target).to eq("@@count")
      end
    end

    describe "typed assignment" do
      let(:source) { "name: String = value" }

      it "parses typed assignment" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Assignment)
        expect(result.value.target).to eq("name")
        expect(result.value.type_annotation).not_to be_nil
      end
    end

    describe "compound assignment" do
      it "parses += operator" do
        scanner = TRuby::Scanner.new("x += 1")
        result = parser.parse_statement(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Assignment)
        # Compound assignment expands to x = x + 1
        expect(result.value.value).to be_a(TRuby::IR::BinaryOp)
        expect(result.value.value.operator).to eq(:+)
      end
    end
  end

  describe "return statements" do
    describe "return without value" do
      let(:source) { "return" }

      it "parses empty return" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Return)
        expect(result.value.value).to be_nil
      end
    end

    describe "return with value" do
      let(:source) { "return 42" }

      it "parses return with expression" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Return)
        expect(result.value.value).to be_a(TRuby::IR::Literal)
        expect(result.value.value.value).to eq(42)
      end
    end

    describe "return with complex expression" do
      let(:source) { "return foo + bar" }

      it "parses return with binary operation" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.value).to be_a(TRuby::IR::BinaryOp)
      end
    end
  end

  describe "if statements" do
    describe "simple if" do
      let(:source) { "if condition\\n  foo\\nend" }

      it "parses if statement" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Conditional)
        expect(result.value.kind).to eq(:if)
        expect(result.value.condition).not_to be_nil
        expect(result.value.then_branch).not_to be_nil
      end
    end

    describe "if with else" do
      let(:source) { "if condition\\n  foo\\nelse\\n  bar\\nend" }

      it "parses if-else statement" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Conditional)
        expect(result.value.else_branch).not_to be_nil
      end
    end

    describe "if with elsif" do
      let(:source) { "if a\\n  1\\nelsif b\\n  2\\nelse\\n  3\\nend" }

      it "parses if-elsif-else chain" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Conditional)
        # elsif becomes nested if in else branch
        expect(result.value.else_branch).to be_a(TRuby::IR::Conditional)
      end
    end
  end

  describe "unless statements" do
    let(:source) { "unless condition\\n  foo\\nend" }

    it "parses unless statement" do
      result = parser.parse_statement(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::Conditional)
      expect(result.value.kind).to eq(:unless)
    end
  end

  describe "while statements" do
    let(:source) { "while condition\\n  foo\\nend" }

    it "parses while loop" do
      result = parser.parse_statement(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::Loop)
      expect(result.value.kind).to eq(:while)
      expect(result.value.condition).not_to be_nil
      expect(result.value.body).not_to be_nil
    end
  end

  describe "until statements" do
    let(:source) { "until done\\n  work\\nend" }

    it "parses until loop" do
      result = parser.parse_statement(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::Loop)
      expect(result.value.kind).to eq(:until)
    end
  end

  describe "case statements" do
    let(:source) do
      <<~RUBY
        case x
        when 1
          foo
        when 2
          bar
        else
          baz
        end
      RUBY
    end

    it "parses case expression" do
      result = parser.parse_statement(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::CaseExpr)
      expect(result.value.subject).not_to be_nil
      expect(result.value.when_clauses.length).to eq(2)
      expect(result.value.else_clause).not_to be_nil
    end
  end

  describe "begin/rescue/ensure" do
    describe "simple rescue" do
      let(:source) do
        <<~RUBY
          begin
            risky
          rescue
            handle
          end
        RUBY
      end

      it "parses begin-rescue block" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::BeginBlock)
        expect(result.value.rescue_clauses).not_to be_empty
      end
    end

    describe "rescue with exception type" do
      let(:source) do
        <<~RUBY
          begin
            risky
          rescue StandardError => e
            handle(e)
          end
        RUBY
      end

      it "parses rescue with exception binding" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.rescue_clauses.first.exception_types).not_to be_empty
        expect(result.value.rescue_clauses.first.variable).to eq("e")
      end
    end

    describe "with ensure" do
      let(:source) do
        <<~RUBY
          begin
            risky
          ensure
            cleanup
          end
        RUBY
      end

      it "parses ensure clause" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.ensure_clause).not_to be_nil
      end
    end
  end

  describe "block parsing" do
    let(:source) do
      <<~RUBY
        foo
        bar
        baz
      RUBY
    end

    it "parses multiple statements into a block" do
      result = parser.parse_block(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::Block)
      expect(result.value.statements.length).to eq(3)
    end
  end

  describe "modifier statements" do
    describe "if modifier" do
      let(:source) { "return 0 if x < 0" }

      it "parses statement with if modifier" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Conditional)
        expect(result.value.kind).to eq(:if)
        # then_branch is wrapped in a Block containing the Return
        expect(result.value.then_branch).to be_a(TRuby::IR::Block)
        expect(result.value.then_branch.statements.first).to be_a(TRuby::IR::Return)
      end
    end

    describe "unless modifier" do
      let(:source) { "foo unless condition" }

      it "parses statement with unless modifier" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Conditional)
        expect(result.value.kind).to eq(:unless)
      end
    end

    describe "while modifier" do
      let(:source) { "x += 1 while condition" }

      it "parses statement with while modifier" do
        result = parser.parse_statement(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Loop)
        expect(result.value.kind).to eq(:while)
      end
    end
  end
end
`,
  "spec/t_ruby/string_utils_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::StringUtils do
  describe ".split_by_comma" do
    it "splits simple comma-separated values" do
      result = described_class.split_by_comma("a, b, c")
      expect(result).to eq(%w[a b c])
    end

    it "handles nested angle brackets" do
      result = described_class.split_by_comma("Array<String>, Hash<String, Integer>")
      expect(result).to eq(["Array<String>", "Hash<String, Integer>"])
    end

    it "handles nested angle brackets with parentheses inside" do
      # split_by_comma tracks <> [] () {} for nesting
      result = described_class.split_by_comma("Hash<String, Integer>, Array<String>")
      expect(result).to eq(["Hash<String, Integer>", "Array<String>"])
    end

    it "handles nested square brackets" do
      result = described_class.split_by_comma("Array[String], Tuple[Integer, String]")
      expect(result).to eq(["Array[String]", "Tuple[Integer, String]"])
    end

    it "handles nested curly braces" do
      result = described_class.split_by_comma("{a: String}, {b: Integer}")
      expect(result).to eq(["{a: String}", "{b: Integer}"])
    end

    it "handles deeply nested structures" do
      result = described_class.split_by_comma("Hash<String, Array<Hash<Symbol, Integer>>>")
      expect(result).to eq(["Hash<String, Array<Hash<Symbol, Integer>>>"])
    end

    it "handles empty string" do
      result = described_class.split_by_comma("")
      expect(result).to eq([])
    end

    it "handles single value" do
      result = described_class.split_by_comma("String")
      expect(result).to eq(["String"])
    end

    it "strips whitespace" do
      result = described_class.split_by_comma("  a  ,  b  ,  c  ")
      expect(result).to eq(%w[a b c])
    end
  end

  describe ".split_type_and_default" do
    it "splits type and default value" do
      type, default = described_class.split_type_and_default("String = 'hello'")
      expect(type).to eq("String")
      expect(default).to eq("'hello'")
    end

    it "returns nil default when no = present" do
      type, default = described_class.split_type_and_default("String")
      expect(type).to eq("String")
      expect(default).to be_nil
    end

    it "ignores = inside angle brackets" do
      type, default = described_class.split_type_and_default("Hash<K = String, V> = {}")
      expect(type).to eq("Hash<K = String, V>")
      expect(default).to eq("{}")
    end

    it "handles simple type with default" do
      type, default = described_class.split_type_and_default("Integer = 42")
      expect(type).to eq("Integer")
      expect(default).to eq("42")
    end

    it "ignores = inside square brackets" do
      type, default = described_class.split_type_and_default("Array[x = 1] = []")
      expect(type).to eq("Array[x = 1]")
      expect(default).to eq("[]")
    end

    it "ignores = inside curly braces" do
      type, default = described_class.split_type_and_default("{x: y = 1} = {}")
      expect(type).to eq("{x: y = 1}")
      expect(default).to eq("{}")
    end

    it "strips whitespace from both parts" do
      type, default = described_class.split_type_and_default("  String  =  'test'  ")
      expect(type).to eq("String")
      expect(default).to eq("'test'")
    end
  end

  describe ".extract_default_value" do
    it "extracts default value" do
      result = described_class.extract_default_value("String = 'hello'")
      expect(result).to eq("'hello'")
    end

    it "returns nil when no default" do
      result = described_class.extract_default_value("String")
      expect(result).to be_nil
    end
  end
end
`,
  "spec/t_ruby/token_declaration_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator::TokenDeclarationParser do
  include TRuby::ParserCombinator::TokenDSL

  let(:parser) { described_class.new }
  let(:scanner) { TRuby::Scanner.new(source) }
  let(:tokens) { scanner.scan_all }

  describe "method definitions" do
    describe "simple method" do
      let(:source) do
        <<~RUBY
          def foo
            bar
          end
        RUBY
      end

      it "parses simple method definition" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodDef)
        expect(result.value.name).to eq("foo")
        expect(result.value.params).to be_empty
        expect(result.value.body).to be_a(TRuby::IR::Block)
      end
    end

    describe "method with parameters" do
      let(:source) do
        <<~RUBY
          def greet(name)
            name
          end
        RUBY
      end

      it "parses method with untyped parameters" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.name).to eq("greet")
        expect(result.value.params.length).to eq(1)
        expect(result.value.params[0].name).to eq("name")
      end
    end

    describe "method with typed parameters" do
      let(:source) do
        <<~RUBY
          def greet(name: String)
            name
          end
        RUBY
      end

      it "parses method with typed parameters" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.params[0].type_annotation).not_to be_nil
        expect(result.value.params[0].type_annotation).to be_a(TRuby::IR::SimpleType)
      end
    end

    describe "method with return type" do
      let(:source) do
        <<~RUBY
          def greet(name: String): String
            name
          end
        RUBY
      end

      it "parses method with return type annotation" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.return_type).not_to be_nil
        expect(result.value.return_type).to be_a(TRuby::IR::SimpleType)
        expect(result.value.return_type.name).to eq("String")
      end
    end

    describe "method with visibility" do
      let(:source) do
        <<~RUBY
          private def secret
            42
          end
        RUBY
      end

      it "parses method with visibility modifier" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::MethodDef)
        expect(result.value.name).to eq("secret")
        expect(result.value.visibility).to eq(:private)
      end
    end

    describe "method with special names" do
      it "parses method with ? suffix" do
        scanner = TRuby::Scanner.new("def valid?\\n  true\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.name).to eq("valid?")
      end

      it "parses method with ! suffix" do
        scanner = TRuby::Scanner.new("def save!\\n  true\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value.name).to eq("save!")
      end
    end
  end

  describe "class definitions" do
    describe "simple class" do
      let(:source) do
        <<~RUBY
          class User
          end
        RUBY
      end

      it "parses simple class definition" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::ClassDecl)
        expect(result.value.name).to eq("User")
      end
    end

    describe "class with superclass" do
      let(:source) do
        <<~RUBY
          class Admin < User
          end
        RUBY
      end

      it "parses class with inheritance" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.superclass).to eq("User")
      end
    end

    describe "class with methods" do
      let(:source) do
        <<~RUBY
          class User
            def initialize(name: String)
              @name = name
            end

            def greet: String
              @name
            end
          end
        RUBY
      end

      it "parses class with method definitions" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.body.length).to eq(2)
        expect(result.value.body[0]).to be_a(TRuby::IR::MethodDef)
        expect(result.value.body[1]).to be_a(TRuby::IR::MethodDef)
      end
    end

    describe "class with instance variables" do
      let(:source) do
        <<~RUBY
          class User
            @name: String
            @age: Integer
          end
        RUBY
      end

      it "parses class with typed instance variables" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.instance_vars.length).to eq(2)
        expect(result.value.instance_vars[0].name).to eq("name")
        expect(result.value.instance_vars[1].name).to eq("age")
      end
    end
  end

  describe "module definitions" do
    describe "simple module" do
      let(:source) do
        <<~RUBY
          module Greeting
          end
        RUBY
      end

      it "parses module definition" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::ModuleDecl)
        expect(result.value.name).to eq("Greeting")
      end
    end

    describe "module with methods" do
      let(:source) do
        <<~RUBY
          module Greeting
            def greet: String
              "Hello"
            end
          end
        RUBY
      end

      it "parses module with methods" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.body.length).to eq(1)
      end
    end
  end

  describe "type alias" do
    let(:source) { "type UserId = Integer" }

    it "parses type alias" do
      result = parser.parse_declaration(tokens, 0)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::TypeAlias)
      expect(result.value.name).to eq("UserId")
      expect(result.value.definition).to be_a(TRuby::IR::SimpleType)
    end
  end

  describe "interface" do
    describe "simple interface" do
      let(:source) do
        <<~RUBY
          interface Printable
            print: -> void
          end
        RUBY
      end

      it "parses interface definition" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::Interface)
        expect(result.value.name).to eq("Printable")
        expect(result.value.members.length).to eq(1)
      end
    end

    describe "interface with multiple members" do
      let(:source) do
        <<~RUBY
          interface Comparable
            compare: (Self) -> Integer
            equal: (Self) -> Boolean
          end
        RUBY
      end

      it "parses interface with multiple members" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.members.length).to eq(2)
      end
    end
  end

  describe "program parsing" do
    let(:source) do
      <<~RUBY
        type UserId = Integer

        class User
          @id: UserId
          @name: String

          def initialize(id: UserId, name: String)
            @id = id
            @name = name
          end

          def greet: String
            @name
          end
        end
      RUBY
    end

    it "parses a complete program" do
      result = parser.parse_program(tokens)

      expect(result.success?).to be true
      expect(result.value).to be_a(TRuby::IR::Program)
      expect(result.value.declarations.length).to eq(2)
      expect(result.value.declarations[0]).to be_a(TRuby::IR::TypeAlias)
      expect(result.value.declarations[1]).to be_a(TRuby::IR::ClassDecl)
    end
  end

  describe "array shorthand syntax" do
    describe "basic array shorthand" do
      it "parses String[] as Array<String>" do
        scanner = TRuby::Scanner.new("def foo(names: String[])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")
        expect(param_type.type_args.length).to eq(1)
        expect(param_type.type_args[0]).to be_a(TRuby::IR::SimpleType)
        expect(param_type.type_args[0].name).to eq("String")
      end

      it "parses Integer[] as Array<Integer>" do
        scanner = TRuby::Scanner.new("def foo(nums: Integer[])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")
        expect(param_type.type_args[0].name).to eq("Integer")
      end

      it "parses array shorthand in return type" do
        scanner = TRuby::Scanner.new("def foo(): String[]\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        return_type = result.value.return_type
        expect(return_type).to be_a(TRuby::IR::GenericType)
        expect(return_type.base).to eq("Array")
        expect(return_type.type_args[0].name).to eq("String")
      end
    end

    describe "nested array shorthand" do
      it "parses Integer[][] as Array<Array<Integer>>" do
        scanner = TRuby::Scanner.new("def foo(matrix: Integer[][])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")

        inner_type = param_type.type_args[0]
        expect(inner_type).to be_a(TRuby::IR::GenericType)
        expect(inner_type.base).to eq("Array")
        expect(inner_type.type_args[0].name).to eq("Integer")
      end

      it "parses String[][][] as triple-nested array" do
        scanner = TRuby::Scanner.new("def foo(cube: String[][][])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        # String[][][] = Array<Array<Array<String>>>
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")

        level2 = param_type.type_args[0]
        expect(level2).to be_a(TRuby::IR::GenericType)
        expect(level2.base).to eq("Array")

        level3 = level2.type_args[0]
        expect(level3).to be_a(TRuby::IR::GenericType)
        expect(level3.base).to eq("Array")
        expect(level3.type_args[0].name).to eq("String")
      end
    end

    describe "nullable array shorthand" do
      it "parses String[]? as nullable array (array itself can be nil)" do
        scanner = TRuby::Scanner.new("def foo(names: String[]?)\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        # String[]? = NullableType(GenericType(Array, [String]))
        expect(param_type).to be_a(TRuby::IR::NullableType)
        inner = param_type.inner_type
        expect(inner).to be_a(TRuby::IR::GenericType)
        expect(inner.base).to eq("Array")
        expect(inner.type_args[0].name).to eq("String")
      end

      it "parses String?[] as array of nullable elements" do
        scanner = TRuby::Scanner.new("def foo(names: String?[])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        # String?[] = GenericType(Array, [NullableType(String)])
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")
        inner = param_type.type_args[0]
        expect(inner).to be_a(TRuby::IR::NullableType)
        expect(inner.inner_type.name).to eq("String")
      end

      it "parses Integer?[]? as nullable array of nullable elements" do
        scanner = TRuby::Scanner.new("def foo(nums: Integer?[]?)\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        # Integer?[]? = NullableType(GenericType(Array, [NullableType(Integer)]))
        expect(param_type).to be_a(TRuby::IR::NullableType)
        array_type = param_type.inner_type
        expect(array_type).to be_a(TRuby::IR::GenericType)
        expect(array_type.base).to eq("Array")
        element_type = array_type.type_args[0]
        expect(element_type).to be_a(TRuby::IR::NullableType)
        expect(element_type.inner_type.name).to eq("Integer")
      end
    end

    describe "union type array shorthand" do
      it "parses (String | Integer)[] as array of union type" do
        scanner = TRuby::Scanner.new("def foo(values: (String | Integer)[])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        # (String | Integer)[] = GenericType(Array, [UnionType([String, Integer])])
        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")
        union_type = param_type.type_args[0]
        expect(union_type).to be_a(TRuby::IR::UnionType)
        expect(union_type.types.length).to eq(2)
        expect(union_type.types[0].name).to eq("String")
        expect(union_type.types[1].name).to eq("Integer")
      end

      it "parses (String | Integer | nil)[] as array of nullable union type" do
        scanner = TRuby::Scanner.new("def foo(values: (String | Integer | nil)[])\\nend")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        param_type = result.value.params[0].type_annotation

        expect(param_type).to be_a(TRuby::IR::GenericType)
        expect(param_type.base).to eq("Array")
        union_type = param_type.type_args[0]
        expect(union_type).to be_a(TRuby::IR::UnionType)
        expect(union_type.types.length).to eq(3)
      end
    end

    describe "type alias with array shorthand" do
      it "parses type alias with array shorthand" do
        scanner = TRuby::Scanner.new("type StringList = String[]")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        expect(result.value).to be_a(TRuby::IR::TypeAlias)
        expect(result.value.name).to eq("StringList")

        definition = result.value.definition
        expect(definition).to be_a(TRuby::IR::GenericType)
        expect(definition.base).to eq("Array")
        expect(definition.type_args[0].name).to eq("String")
      end

      it "parses type alias with nested array shorthand" do
        scanner = TRuby::Scanner.new("type IntMatrix = Integer[][]")
        result = parser.parse_declaration(scanner.scan_all, 0)

        expect(result.success?).to be true
        definition = result.value.definition
        expect(definition).to be_a(TRuby::IR::GenericType)
        expect(definition.base).to eq("Array")
        expect(definition.type_args[0]).to be_a(TRuby::IR::GenericType)
        expect(definition.type_args[0].base).to eq("Array")
      end
    end

    describe "class with array shorthand instance variables" do
      let(:source) do
        <<~RUBY
          class DataStore
            @items: String[]
            @matrix: Integer[][]
            @optional: Float[]?
          end
        RUBY
      end

      it "parses instance variables with array shorthand types" do
        result = parser.parse_declaration(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.instance_vars.length).to eq(3)

        items_type = result.value.instance_vars[0].type_annotation
        expect(items_type).to be_a(TRuby::IR::GenericType)
        expect(items_type.base).to eq("Array")

        matrix_type = result.value.instance_vars[1].type_annotation
        expect(matrix_type).to be_a(TRuby::IR::GenericType)
        expect(matrix_type.type_args[0]).to be_a(TRuby::IR::GenericType)

        optional_type = result.value.instance_vars[2].type_annotation
        expect(optional_type).to be_a(TRuby::IR::NullableType)
        expect(optional_type.inner_type).to be_a(TRuby::IR::GenericType)
      end
    end

    describe "equivalence with Array<T> syntax" do
      it "String[] and Array<String> produce equivalent IR" do
        scanner1 = TRuby::Scanner.new("def foo(a: String[])\\nend")
        scanner2 = TRuby::Scanner.new("def foo(a: Array<String>)\\nend")

        result1 = parser.parse_declaration(scanner1.scan_all, 0)
        result2 = parser.parse_declaration(scanner2.scan_all, 0)

        expect(result1.success?).to be true
        expect(result2.success?).to be true

        type1 = result1.value.params[0].type_annotation
        type2 = result2.value.params[0].type_annotation

        expect(type1).to be_a(TRuby::IR::GenericType)
        expect(type2).to be_a(TRuby::IR::GenericType)
        expect(type1.base).to eq(type2.base)
        expect(type1.type_args[0].name).to eq(type2.type_args[0].name)
      end

      it "Integer[][] and Array<Array<Integer>> produce equivalent IR" do
        scanner1 = TRuby::Scanner.new("def foo(a: Integer[][])\\nend")
        scanner2 = TRuby::Scanner.new("def foo(a: Array<Array<Integer>>)\\nend")

        result1 = parser.parse_declaration(scanner1.scan_all, 0)
        result2 = parser.parse_declaration(scanner2.scan_all, 0)

        expect(result1.success?).to be true
        expect(result2.success?).to be true

        type1 = result1.value.params[0].type_annotation
        type2 = result2.value.params[0].type_annotation

        expect(type1.base).to eq(type2.base)
        expect(type1.type_args[0].base).to eq(type2.type_args[0].base)
        expect(type1.type_args[0].type_args[0].name).to eq(type2.type_args[0].type_args[0].name)
      end
    end
  end
end
`,
  "spec/t_ruby/token_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::ParserCombinator::TokenParser do
  include TRuby::ParserCombinator::TokenDSL

  let(:scanner) { TRuby::Scanner.new(source) }
  let(:tokens) { scanner.scan_all }

  describe "basic token matching" do
    let(:source) { "def foo" }

    it "matches a specific token type" do
      parser = token(:def)
      result = parser.parse(tokens, 0)

      expect(result.success?).to be true
      expect(result.value.type).to eq(:def)
      expect(result.value.value).to eq("def")
      expect(result.position).to eq(1)
    end

    it "fails when token type does not match" do
      parser = token(:class)
      result = parser.parse(tokens, 0)

      expect(result.failure?).to be true
      expect(result.error).to include("Expected :class")
    end
  end

  describe "#keyword" do
    let(:source) { "def end class if return" }

    it "matches Ruby keywords" do
      expect(keyword(:def).parse(tokens, 0).success?).to be true
      expect(keyword(:end).parse(tokens, 1).success?).to be true
      expect(keyword(:class).parse(tokens, 2).success?).to be true
      expect(keyword(:if).parse(tokens, 3).success?).to be true
      expect(keyword(:return).parse(tokens, 4).success?).to be true
    end
  end

  describe "combinator operations" do
    describe "sequence (>>)" do
      let(:source) { "def foo" }

      it "sequences two token parsers" do
        parser = token(:def) >> token(:identifier)
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to be_an(Array)
        expect(result.value[0].type).to eq(:def)
        expect(result.value[1].value).to eq("foo")
        expect(result.position).to eq(2)
      end

      it "fails if first parser fails" do
        parser = token(:class) >> token(:identifier)
        result = parser.parse(tokens, 0)

        expect(result.failure?).to be true
      end

      it "fails if second parser fails" do
        parser = token(:def) >> token(:class)
        result = parser.parse(tokens, 0)

        expect(result.failure?).to be true
      end
    end

    describe "alternative (|)" do
      let(:source) { "class Foo" }

      it "tries alternative when first fails" do
        parser = token(:def) | token(:class)
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.type).to eq(:class)
      end
    end

    describe "#many" do
      let(:source) { "public private protected def" }

      it "matches zero or more tokens" do
        visibility = token(:public) | token(:private) | token(:protected)
        parser = visibility.many

        result = parser.parse(tokens, 0)
        expect(result.success?).to be true
        expect(result.value.length).to eq(3)
        expect(result.value.map(&:type)).to eq(%i[public private protected])
      end

      it "returns empty array when no matches" do
        parser = token(:class).many
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to eq([])
      end
    end

    describe "#optional" do
      let(:source) { "def foo" }

      it "returns nil when not matching" do
        parser = token(:public).optional >> token(:def)
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value[0]).to be_nil
        expect(result.value[1].type).to eq(:def)
      end

      let(:source_with_visibility) { "private def foo" }

      it "returns value when matching" do
        scanner2 = TRuby::Scanner.new("private def foo")
        tokens2 = scanner2.scan_all

        parser = token(:private).optional >> token(:def)
        result = parser.parse(tokens2, 0)

        expect(result.success?).to be true
        expect(result.value[0].type).to eq(:private)
        expect(result.value[1].type).to eq(:def)
      end
    end

    describe "#sep_by" do
      let(:source) { "String, Integer, Boolean" }

      it "parses comma-separated tokens" do
        parser = token(:constant).sep_by(token(:comma))
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.length).to eq(3)
        expect(result.value.map(&:value)).to eq(%w[String Integer Boolean])
      end
    end

    describe "#map" do
      let(:source) { "42" }

      it "transforms the result" do
        parser = token(:integer).map { |t| t.value.to_i }
        result = parser.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value).to eq(42)
      end
    end

    describe "skip right (<<)" do
      let(:source) { "foo;" }

      it "keeps left, discards right" do
        # Simulate semicolon by using newline
        scanner2 = TRuby::Scanner.new("foo\\n")
        tokens2 = scanner2.scan_all

        parser = token(:identifier) << token(:newline)
        result = parser.parse(tokens2, 0)

        expect(result.success?).to be true
        expect(result.value.value).to eq("foo")
      end
    end
  end

  describe "complex parsing patterns" do
    describe "function signature" do
      let(:source) { "def greet(name: String): String" }

      it "parses a complete function signature" do
        # def identifier ( params ) : return_type
        param = token(:identifier) >> token(:colon) >> token(:constant)
        params = param.sep_by(token(:comma))
        return_type = (token(:colon) >> token(:constant)).optional

        func_sig = token(:def) >> token(:identifier) >>
                   token(:lparen) >> params >> token(:rparen) >>
                   return_type

        result = func_sig.parse(tokens, 0)

        expect(result.success?).to be true
      end
    end

    describe "type alias" do
      let(:source) { "type UserId = Integer" }

      it "parses a type alias" do
        type_alias = token(:type) >> token(:constant) >> token(:eq) >> token(:constant)
        result = type_alias.parse(tokens, 0)

        expect(result.success?).to be true
        values = flatten_tokens(result.value)
        expect(values.map(&:value)).to eq(%w[type UserId = Integer])
      end
    end

    describe "union type" do
      let(:source) { "String | Integer | nil" }

      it "parses union type syntax" do
        base_type = token(:constant) | token(:nil)
        union_type = base_type.sep_by(token(:pipe))

        result = union_type.parse(tokens, 0)

        expect(result.success?).to be true
        expect(result.value.length).to eq(3)
      end
    end

    describe "generic type" do
      let(:source) { "Array<String>" }

      it "parses generic type syntax" do
        type_arg = token(:constant)
        generic = token(:constant) >> token(:lt) >> type_arg >> token(:gt)

        result = generic.parse(tokens, 0)

        expect(result.success?).to be true
      end
    end

    describe "visibility modifier" do
      let(:source) { "private def secret" }

      it "parses visibility with method definition" do
        visibility = token(:public) | token(:private) | token(:protected)
        method_def = visibility.optional >> token(:def) >> token(:identifier)

        result = method_def.parse(tokens, 0)

        expect(result.success?).to be true
      end
    end
  end

  describe "error handling" do
    let(:source) { "def 123" }

    it "provides useful error messages" do
      parser = token(:def) >> token(:identifier)
      result = parser.parse(tokens, 0)

      expect(result.failure?).to be true
      expect(result.error).to include("identifier")
    end
  end

  describe "position tracking" do
    let(:source) { "def foo end" }

    it "correctly advances position" do
      parser = token(:def) >> token(:identifier) >> token(:end)
      result = parser.parse(tokens, 0)

      expect(result.success?).to be true
      expect(result.position).to eq(3)
    end

    it "can parse from arbitrary position" do
      parser = token(:identifier)
      result = parser.parse(tokens, 1)

      expect(result.success?).to be true
      expect(result.value.value).to eq("foo")
    end
  end

  # Helper to flatten nested arrays of tokens
  def flatten_tokens(value)
    case value
    when Array
      value.flat_map { |v| flatten_tokens(v) }
    when TRuby::Scanner::Token
      [value]
    else
      []
    end
  end
end
`,
  "spec/t_ruby/type_alias_registry_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::TypeAliasRegistry do
  let(:registry) { TRuby::TypeAliasRegistry.new }

  describe "basic type alias registration" do
    it "registers a simple type alias" do
      registry.register("UserId", "String")
      expect(registry.resolve("UserId")).to eq("String")
    end

    it "handles multiple type aliases" do
      registry.register("UserId", "String")
      registry.register("Age", "Integer")

      expect(registry.resolve("UserId")).to eq("String")
      expect(registry.resolve("Age")).to eq("Integer")
    end

    it "returns nil for undefined aliases" do
      expect(registry.resolve("NonExistent")).to be_nil
    end
  end

  describe "alias validation" do
    it "detects duplicate type alias definitions" do
      registry.register("UserId", "String")

      expect do
        registry.register("UserId", "Integer")
      end.to raise_error(TRuby::DuplicateTypeAliasError)
    end

    it "detects immediate circular references (A -> B -> A)" do
      registry.register("A", "B")

      expect do
        registry.register("B", "A")
      end.to raise_error(TRuby::CircularTypeAliasError)
    end

    it "detects longer circular references (A -> B -> C -> A)" do
      registry.register("A", "B")
      registry.register("B", "C")

      expect do
        registry.register("C", "A")
      end.to raise_error(TRuby::CircularTypeAliasError)
    end

    it "detects self-referencing alias" do
      expect do
        registry.register("A", "A")
      end.to raise_error(TRuby::CircularTypeAliasError)
    end

    it "detects reference to undefined type" do
      registry.register("UserId", "UndefinedType")

      expect do
        registry.validate_all
      end.to raise_error(TRuby::UndefinedTypeError)
    end
  end

  describe "alias resolution" do
    it "resolves transitive aliases" do
      registry.register("UserId", "Id")
      registry.register("Id", "String")

      # Should resolve to actual type
      expect(registry.resolve("UserId")).to eq("Id") # Direct resolution
    end

    it "lists all registered aliases" do
      registry.register("UserId", "String")
      registry.register("Age", "Integer")

      aliases = registry.all
      expect(aliases.count).to eq(2)
      expect(aliases["UserId"]).to eq("String")
      expect(aliases["Age"]).to eq("Integer")
    end
  end

  describe "type system integration" do
    it "recognizes basic types as valid even without registration" do
      expect(registry.valid_type?("String")).to be true
      expect(registry.valid_type?("Integer")).to be true
      expect(registry.valid_type?("Boolean")).to be true
    end

    it "recognizes registered aliases as valid" do
      registry.register("UserId", "String")
      expect(registry.valid_type?("UserId")).to be true
    end

    it "recognizes undefined custom types as invalid" do
      expect(registry.valid_type?("CustomUndefinedType")).to be false
    end
  end

  describe "clearing and reset" do
    it "can clear all aliases" do
      registry.register("UserId", "String")
      registry.clear

      expect(registry.resolve("UserId")).to be_nil
    end
  end
end
`,
  "spec/t_ruby/type_checker_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::TypeHierarchy do
  let(:hierarchy) { TRuby::TypeHierarchy.new }

  describe "#subtype_of?" do
    it "recognizes same type" do
      expect(hierarchy.subtype_of?("String", "String")).to be true
    end

    it "recognizes Integer as subtype of Numeric" do
      expect(hierarchy.subtype_of?("Integer", "Numeric")).to be true
    end

    it "recognizes Float as subtype of Numeric" do
      expect(hierarchy.subtype_of?("Float", "Numeric")).to be true
    end

    it "recognizes all types as subtype of Object" do
      expect(hierarchy.subtype_of?("String", "Object")).to be true
      expect(hierarchy.subtype_of?("Integer", "Object")).to be true
    end

    it "does not recognize Numeric as subtype of Integer" do
      expect(hierarchy.subtype_of?("Numeric", "Integer")).to be false
    end
  end

  describe "#compatible?" do
    it "recognizes compatible types" do
      expect(hierarchy.compatible?("Integer", "Numeric")).to be true
      expect(hierarchy.compatible?("Numeric", "Integer")).to be true
    end
  end

  describe "#common_supertype" do
    it "finds common supertype" do
      expect(hierarchy.common_supertype("Integer", "Float")).to eq("Numeric")
    end

    it "returns same type for identical types" do
      expect(hierarchy.common_supertype("String", "String")).to eq("String")
    end
  end
end

RSpec.describe TRuby::TypeScope do
  describe "#define and #lookup" do
    it "stores and retrieves types" do
      scope = TRuby::TypeScope.new
      scope.define("x", "Integer")
      expect(scope.lookup("x")).to eq("Integer")
    end

    it "looks up in parent scope" do
      parent = TRuby::TypeScope.new
      parent.define("x", "Integer")

      child = parent.child_scope
      expect(child.lookup("x")).to eq("Integer")
    end

    it "shadows parent scope" do
      parent = TRuby::TypeScope.new
      parent.define("x", "Integer")

      child = parent.child_scope
      child.define("x", "String")
      expect(child.lookup("x")).to eq("String")
      expect(parent.lookup("x")).to eq("Integer")
    end
  end
end

RSpec.describe TRuby::FlowContext do
  describe "#narrow" do
    it "narrows variable type" do
      context = TRuby::FlowContext.new
      context.narrow("x", "String")
      expect(context.get_narrowed_type("x")).to eq("String")
    end
  end

  describe "#branch" do
    it "creates independent copy" do
      context = TRuby::FlowContext.new
      context.narrow("x", "String")

      branch = context.branch
      branch.narrow("x", "Integer")

      expect(context.get_narrowed_type("x")).to eq("String")
      expect(branch.get_narrowed_type("x")).to eq("Integer")
    end
  end

  describe "#merge" do
    it "creates union for different types" do
      context1 = TRuby::FlowContext.new
      context1.narrow("x", "String")

      context2 = TRuby::FlowContext.new
      context2.narrow("x", "Integer")

      merged = context1.merge(context2)
      expect(merged.get_narrowed_type("x")).to include("String")
      expect(merged.get_narrowed_type("x")).to include("Integer")
    end

    it "keeps same type when both branches agree" do
      context1 = TRuby::FlowContext.new
      context1.narrow("x", "String")

      context2 = TRuby::FlowContext.new
      context2.narrow("x", "String")

      merged = context1.merge(context2)
      expect(merged.get_narrowed_type("x")).to eq("String")
    end
  end
end

RSpec.describe TRuby::TypeChecker do
  let(:checker) { TRuby::TypeChecker.new }

  describe "#register_function" do
    it "registers function signature" do
      checker.register_function(
        "greet",
        params: [{ name: "name", type: "String" }],
        return_type: "String"
      )

      # Verify by checking a call
      result = checker.check_call("greet", ['"hello"'])
      expect(result).to eq("String")
    end
  end

  describe "#check_call" do
    before do
      checker.register_function(
        "add",
        params: [
          { name: "a", type: "Integer" },
          { name: "b", type: "Integer" },
        ],
        return_type: "Integer"
      )
    end

    it "validates correct argument types" do
      checker.check_call("add", %w[1 2])
      expect(checker.errors).to be_empty
    end

    it "reports wrong argument count" do
      checker.check_call("add", ["1"])
      expect(checker.errors).not_to be_empty
      expect(checker.errors.first.message).to include("Wrong number")
    end

    it "reports type mismatch" do
      checker.check_call("add", ['"hello"', "2"])
      expect(checker.errors).not_to be_empty
      expect(checker.errors.first.message).to include("Type mismatch")
    end

    it "warns about unknown functions" do
      checker.check_call("unknown_func", [])
      expect(checker.warnings).not_to be_empty
    end
  end

  describe "#check_return" do
    it "validates matching return type" do
      result = checker.check_return('"hello"', "String")
      expect(result).to be true
      expect(checker.errors).to be_empty
    end

    it "reports return type mismatch" do
      checker.check_return("42", "String")
      expect(checker.errors).not_to be_empty
    end
  end

  describe "#check_assignment" do
    it "allows compatible assignment" do
      result = checker.check_assignment("x", "42", declared_type: "Integer")
      expect(result).to be true
    end

    it "reports incompatible assignment" do
      checker.check_assignment("x", '"hello"', declared_type: "Integer")
      expect(checker.errors).not_to be_empty
    end
  end

  describe "#check_operator" do
    it "validates arithmetic operators" do
      result = checker.check_operator("Integer", "+", "Integer")
      expect(result).to eq("Integer")
    end

    it "promotes to Float when needed" do
      result = checker.check_operator("Integer", "+", "Float")
      expect(result).to eq("Float")
    end

    it "allows string concatenation" do
      result = checker.check_operator("String", "+", "String")
      expect(result).to eq("String")
    end

    it "reports error for invalid string concatenation" do
      checker.check_operator("String", "+", "Integer")
      expect(checker.errors).not_to be_empty
    end

    it "returns Boolean for comparisons" do
      result = checker.check_operator("Integer", "==", "Integer")
      expect(result).to eq("Boolean")
    end
  end

  describe "#narrow_in_conditional" do
    it "narrows type from is_a? guard" do
      then_scope = TRuby::FlowContext.new
      else_scope = TRuby::FlowContext.new

      checker.narrow_in_conditional("x.is_a?(String)", then_scope, else_scope)

      expect(then_scope.get_narrowed_type("x")).to eq("String")
    end

    it "narrows from nil? check" do
      then_scope = TRuby::FlowContext.new
      else_scope = TRuby::FlowContext.new

      checker.narrow_in_conditional("x.nil?", then_scope, else_scope)

      expect(then_scope.get_narrowed_type("x")).to eq("nil")
    end
  end

  describe "#register_alias" do
    it "registers and resolves type aliases" do
      checker.register_alias("UserId", "Integer")
      expect(checker.resolve_type("UserId")).to eq("Integer")
    end
  end

  describe "#reset" do
    it "clears all state" do
      checker.register_function("test", params: [], return_type: "String")
      checker.check_call("unknown", [])

      checker.reset

      expect(checker.errors).to be_empty
      expect(checker.warnings).to be_empty
    end
  end

  describe "#diagnostics" do
    it "returns combined errors and warnings" do
      checker.check_call("unknown", [])

      diagnostics = checker.diagnostics
      expect(diagnostics).not_to be_empty
      expect(diagnostics.first[:type]).to eq(:warning)
    end
  end
end

RSpec.describe TRuby::TypeCheckError do
  it "formats error message" do
    error = TRuby::TypeCheckError.new(
      message: "Type mismatch",
      expected: "String",
      actual: "Integer",
      suggestion: "Use .to_s"
    )

    str = error.to_s
    expect(str).to include("Type mismatch")
    expect(str).to include("Expected: String")
    expect(str).to include("Actual: Integer")
    expect(str).to include("Suggestion: Use .to_s")
  end

  it "converts to diagnostic" do
    error = TRuby::TypeCheckError.new(
      message: "Type error",
      location: "line 5",
      expected: "String",
      actual: "Integer",
      severity: :error
    )

    diagnostic = error.to_diagnostic
    expect(diagnostic[:severity]).to eq(:error)
    expect(diagnostic[:message]).to eq("Type error")
    expect(diagnostic[:location]).to eq("line 5")
    expect(diagnostic[:expected]).to eq("String")
    expect(diagnostic[:actual]).to eq("Integer")
  end
end

RSpec.describe TRuby::TypeHierarchy do
  describe "#register_subtype" do
    it "registers custom subtype relationships" do
      hierarchy = TRuby::TypeHierarchy.new
      hierarchy.register_subtype("MyClass", "BaseClass")
      hierarchy.register_subtype("MyClass", "Interface")

      # Should be idempotent
      hierarchy.register_subtype("MyClass", "BaseClass")
    end
  end
end

RSpec.describe TRuby::FlowContext do
  describe "#push_guard and #pop_guard" do
    it "manages guard condition stack" do
      context = TRuby::FlowContext.new
      context.push_guard("x.is_a?(String)")
      context.push_guard("y > 0")

      expect(context.guard_conditions.length).to eq(2)

      context.pop_guard
      expect(context.guard_conditions.length).to eq(1)
    end
  end

  describe "#merge" do
    it "handles variables only in one branch" do
      context1 = TRuby::FlowContext.new
      context1.narrow("x", "String")

      context2 = TRuby::FlowContext.new
      # y not in context1

      merged = context1.merge(context2)
      expect(merged.get_narrowed_type("x")).to eq("String")
    end
  end
end

RSpec.describe TRuby::TypeChecker do
  describe "#check_program" do
    it "processes TypeAlias declarations" do
      checker = TRuby::TypeChecker.new(use_smt: true)
      alias_node = TRuby::IR::TypeAlias.new(
        name: "UserId",
        definition: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [alias_node])

      result = checker.check_program(program)
      expect(result[:success]).to be true
    end

    it "processes Interface declarations" do
      checker = TRuby::TypeChecker.new(use_smt: true)
      interface = TRuby::IR::Interface.new(
        name: "Serializable",
        members: [
          TRuby::IR::InterfaceMember.new(
            name: "to_json",
            type_signature: TRuby::IR::SimpleType.new(name: "String")
          ),
        ]
      )
      program = TRuby::IR::Program.new(declarations: [interface])

      result = checker.check_program(program)
      expect(result[:success]).to be true
    end

    it "processes MethodDef with SMT" do
      checker = TRuby::TypeChecker.new(use_smt: true)
      method = TRuby::IR::MethodDef.new(
        name: "greet",
        params: [
          TRuby::IR::Parameter.new(
            name: "name",
            type_annotation: TRuby::IR::SimpleType.new(name: "String")
          ),
        ],
        return_type: TRuby::IR::SimpleType.new(name: "String")
      )
      program = TRuby::IR::Program.new(declarations: [method])

      result = checker.check_program(program)
      expect(result[:success]).to be true
    end
  end

  describe "#check_method_with_smt" do
    it "handles methods with SMT errors" do
      checker = TRuby::TypeChecker.new(use_smt: true)

      # Method that would cause type inference issues
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [],
        return_type: nil
      )

      result = checker.check_method_with_smt(method)
      expect(result).to have_key(:success)
    end
  end

  describe "#validate_type" do
    let(:checker) { TRuby::TypeChecker.new(use_smt: true) }

    it "validates GenericType with unknown base" do
      type = TRuby::IR::GenericType.new(
        base: "UnknownGeneric",
        type_args: [TRuby::IR::SimpleType.new(name: "String")]
      )
      checker.validate_type(type)
      expect(checker.warnings).not_to be_empty
    end

    it "validates UnionType members" do
      type = TRuby::IR::UnionType.new(
        types: [
          TRuby::IR::SimpleType.new(name: "String"),
          TRuby::IR::SimpleType.new(name: "UnknownType"),
        ]
      )
      checker.validate_type(type)
      expect(checker.warnings).not_to be_empty
    end

    it "validates IntersectionType members" do
      type = TRuby::IR::IntersectionType.new(
        types: [
          TRuby::IR::SimpleType.new(name: "String"),
          TRuby::IR::SimpleType.new(name: "UnknownType"),
        ]
      )
      checker.validate_type(type)
      expect(checker.warnings).not_to be_empty
    end

    it "validates NullableType inner" do
      type = TRuby::IR::NullableType.new(
        inner_type: TRuby::IR::SimpleType.new(name: "UnknownType")
      )
      checker.validate_type(type)
      expect(checker.warnings).not_to be_empty
    end

    it "validates FunctionType" do
      type = TRuby::IR::FunctionType.new(
        param_types: [TRuby::IR::SimpleType.new(name: "UnknownParam")],
        return_type: TRuby::IR::SimpleType.new(name: "UnknownReturn")
      )
      checker.validate_type(type)
      expect(checker.warnings.length).to eq(2)
    end
  end

  describe "#subtype_with_smt?" do
    it "uses SMT solver for subtype check" do
      checker = TRuby::TypeChecker.new(use_smt: true)
      expect(checker.subtype_with_smt?("String", "String")).to be true
    end

    it "uses hierarchy without SMT" do
      checker = TRuby::TypeChecker.new(use_smt: false)
      expect(checker.subtype_with_smt?("Integer", "Numeric")).to be true
    end
  end

  describe "#to_smt_type" do
    let(:checker) { TRuby::TypeChecker.new(use_smt: true) }

    it "converts String to ConcreteType" do
      result = checker.to_smt_type("String")
      expect(result).to be_a(TRuby::SMT::ConcreteType)
      expect(result.name).to eq("String")
    end

    it "converts SimpleType to ConcreteType" do
      simple = TRuby::IR::SimpleType.new(name: "Integer")
      result = checker.to_smt_type(simple)
      expect(result).to be_a(TRuby::SMT::ConcreteType)
      expect(result.name).to eq("Integer")
    end

    it "passes through ConcreteType" do
      concrete = TRuby::SMT::ConcreteType.new("Boolean")
      result = checker.to_smt_type(concrete)
      expect(result).to eq(concrete)
    end

    it "passes through TypeVar" do
      type_var = TRuby::SMT::TypeVar.new("T")
      result = checker.to_smt_type(type_var)
      expect(result).to eq(type_var)
    end

    it "converts unknown to ConcreteType using to_s" do
      unknown = double("UnknownType", to_s: "Custom")
      result = checker.to_smt_type(unknown)
      expect(result).to be_a(TRuby::SMT::ConcreteType)
      expect(result.name).to eq("Custom")
    end
  end

  describe "#check_property_access" do
    let(:checker) { TRuby::TypeChecker.new }

    it "returns type for known property" do
      result = checker.check_property_access("String", "length")
      expect(result).to eq("Integer")
    end

    it "warns for unknown property" do
      checker.check_property_access("String", "unknown_property")
      expect(checker.warnings).not_to be_empty
    end

    it "returns nil for unknown receiver type" do
      result = checker.check_property_access("UnknownType", "foo")
      expect(result).to be_nil
    end
  end

  describe "#check_operator" do
    let(:checker) { TRuby::TypeChecker.new }

    it "handles logical operators" do
      result = checker.check_operator("Boolean", "&&", "String")
      expect(result).to eq("String")

      result = checker.check_operator("Integer", "||", "Float")
      expect(result).to eq("Float")
    end

    it "reports error for non-numeric arithmetic" do
      checker.check_operator("Boolean", "+", "String")
      expect(checker.errors).not_to be_empty
    end

    it "returns nil for unknown operator" do
      result = checker.check_operator("String", "<=>", "String")
      expect(result).to be_nil
    end
  end

  describe "#narrow_in_conditional" do
    let(:checker) { TRuby::TypeChecker.new }

    it "narrows from !nil? check" do
      then_scope = TRuby::FlowContext.new
      else_scope = TRuby::FlowContext.new

      checker.narrow_in_conditional("!x.nil?", then_scope, else_scope)

      expect(else_scope.get_narrowed_type("x")).to eq("nil")
    end
  end

  describe "#check_function" do
    let(:checker) { TRuby::TypeChecker.new }

    it "checks function body" do
      function_info = {
        name: "test",
        params: [{ name: "x", type: "Integer" }],
        return_type: "Integer",
      }

      body_lines = [
        "y = x",
        "return y",
      ]

      checker.check_function(function_info, body_lines)
      # Should not raise
    end
  end

  describe "#check_statement" do
    let(:checker) { TRuby::TypeChecker.new }

    it "parses return statement" do
      checker.check_statement("return 42")
      # Should not raise
    end

    it "parses assignment" do
      checker.check_statement("x = 42")
      # Should not raise
    end

    it "parses method call" do
      checker.register_function("puts", params: [], return_type: "nil")
      checker.check_statement("puts()")
      # Should not raise
    end
  end

  describe "#known_type?" do
    let(:checker) { TRuby::TypeChecker.new }

    it "recognizes built-in types" do
      %w[String Integer Float Boolean Array Hash Symbol void nil Object Numeric Enumerable].each do |type|
        expect(checker.known_type?(type)).to be true
      end
    end

    it "recognizes registered aliases" do
      checker.register_alias("UserId", "Integer")
      expect(checker.known_type?("UserId")).to be true
    end

    it "returns false for unknown types" do
      expect(checker.known_type?("SomeRandomType")).to be false
    end
  end

  describe "#infer_param_type" do
    let(:checker) { TRuby::TypeChecker.new }

    it "returns type from annotation" do
      param = TRuby::IR::Parameter.new(
        name: "x",
        type_annotation: TRuby::IR::SimpleType.new(name: "String")
      )
      expect(checker.infer_param_type(param)).to eq("String")
    end

    it "returns Object when no annotation" do
      param = TRuby::IR::Parameter.new(name: "x")
      expect(checker.infer_param_type(param)).to eq("Object")
    end

    it "handles non-simple type annotations" do
      param = TRuby::IR::Parameter.new(
        name: "arr",
        type_annotation: TRuby::IR::GenericType.new(base: "Array", type_args: [])
      )
      result = checker.infer_param_type(param)
      expect(result).to be_a(String)
    end
  end

  describe "#check_program_legacy" do
    it "checks program without SMT" do
      checker = TRuby::TypeChecker.new(use_smt: false)
      method = TRuby::IR::MethodDef.new(
        name: "test",
        params: [],
        return_type: nil
      )
      program = TRuby::IR::Program.new(declarations: [method])

      result = checker.check_program(program)
      expect(result[:success]).to be true
    end
  end
end

RSpec.describe TRuby::LegacyTypeChecker do
  it "initializes without SMT" do
    checker = TRuby::LegacyTypeChecker.new
    expect(checker.use_smt).to be false
  end
end

RSpec.describe TRuby::SMTTypeChecker do
  it "initializes with SMT" do
    checker = TRuby::SMTTypeChecker.new
    expect(checker.use_smt).to be true
  end

  describe "#check_with_constraints" do
    it "allows custom constraints" do
      checker = TRuby::SMTTypeChecker.new
      program = TRuby::IR::Program.new(declarations: [])

      result = checker.check_with_constraints(program) do |solver|
        # Add custom constraint
        solver.add_equal(
          TRuby::SMT::TypeVar.new("T"),
          TRuby::SMT::ConcreteType.new("String")
        )
      end

      expect(result[:success]).to be true
    end
  end

  describe "#solve_constraints" do
    it "solves current constraints" do
      checker = TRuby::SMTTypeChecker.new
      result = checker.solve_constraints
      expect(result[:success]).to be true
    end
  end

  describe "#inferred_type" do
    it "returns inferred type for variable" do
      checker = TRuby::SMTTypeChecker.new
      # Would need to run type inference first for meaningful result
      # Result may be nil if not inferred
      expect(checker.inferred_type("SomeVar")).to be_nil
    end
  end
end
`,
  "spec/t_ruby/type_env_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::TypeEnv do
  let(:env) { described_class.new }

  describe "#initialize" do
    it "creates env without parent" do
      expect(env.parent).to be_nil
    end

    it "creates env with parent" do
      child = described_class.new(env)
      expect(child.parent).to eq(env)
    end

    it "initializes with empty bindings" do
      expect(env.bindings).to eq({})
    end

    it "initializes with empty instance_vars" do
      expect(env.instance_vars).to eq({})
    end
  end

  describe "#define" do
    it "defines a local variable" do
      env.define("x", "Integer")
      expect(env.bindings["x"]).to eq("Integer")
    end
  end

  describe "#lookup" do
    it "returns defined variable type" do
      env.define("x", "Integer")
      expect(env.lookup("x")).to eq("Integer")
    end

    it "returns nil for undefined variable" do
      expect(env.lookup("unknown")).to be_nil
    end

    it "looks up in parent scope" do
      env.define("x", "Integer")
      child = described_class.new(env)
      expect(child.lookup("x")).to eq("Integer")
    end

    it "prefers child scope binding" do
      env.define("x", "Integer")
      child = described_class.new(env)
      child.define("x", "String")
      expect(child.lookup("x")).to eq("String")
    end

    it "delegates instance var lookup" do
      env.define_instance_var("@name", "String")
      expect(env.lookup("@name")).to eq("String")
    end

    it "delegates class var lookup" do
      env.define_class_var("@@count", "Integer")
      expect(env.lookup("@@count")).to eq("Integer")
    end
  end

  describe "#define_instance_var" do
    it "defines instance variable" do
      env.define_instance_var("@name", "String")
      expect(env.instance_vars["@name"]).to eq("String")
    end

    it "normalizes name without @" do
      env.define_instance_var("name", "String")
      expect(env.instance_vars["@name"]).to eq("String")
    end
  end

  describe "#lookup_instance_var" do
    it "returns instance variable type" do
      env.define_instance_var("@name", "String")
      expect(env.lookup_instance_var("@name")).to eq("String")
    end

    it "normalizes name without @" do
      env.define_instance_var("@name", "String")
      expect(env.lookup_instance_var("name")).to eq("String")
    end

    it "looks up in parent scope" do
      env.define_instance_var("@name", "String")
      child = described_class.new(env)
      expect(child.lookup_instance_var("@name")).to eq("String")
    end
  end

  describe "#define_class_var" do
    it "defines class variable" do
      env.define_class_var("@@count", "Integer")
      result = env.lookup_class_var("@@count")
      expect(result).to eq("Integer")
    end

    it "normalizes name without @@" do
      env.define_class_var("count", "Integer")
      expect(env.lookup_class_var("@@count")).to eq("Integer")
    end
  end

  describe "#lookup_class_var" do
    it "looks up in parent scope" do
      env.define_class_var("@@count", "Integer")
      child = described_class.new(env)
      expect(child.lookup_class_var("@@count")).to eq("Integer")
    end
  end

  describe "#child_scope" do
    it "creates child with self as parent" do
      child = env.child_scope
      expect(child.parent).to eq(env)
    end
  end

  describe "#local_names" do
    it "returns local variable names" do
      env.define("x", "Integer")
      env.define("y", "String")
      expect(env.local_names).to contain_exactly("x", "y")
    end
  end

  describe "#instance_var_names" do
    it "returns instance variable names" do
      env.define_instance_var("@x", "Integer")
      env.define_instance_var("@y", "String")
      expect(env.instance_var_names).to contain_exactly("@x", "@y")
    end
  end

  describe "#defined_locally?" do
    it "returns true for locally defined variable" do
      env.define("x", "Integer")
      expect(env.defined_locally?("x")).to be true
    end

    it "returns false for undefined variable" do
      expect(env.defined_locally?("x")).to be false
    end

    it "returns false for parent-defined variable" do
      env.define("x", "Integer")
      child = described_class.new(env)
      expect(child.defined_locally?("x")).to be false
    end
  end

  describe "#depth" do
    it "returns 0 for root env" do
      expect(env.depth).to eq(0)
    end

    it "returns correct depth for nested envs" do
      child = described_class.new(env)
      grandchild = described_class.new(child)
      expect(child.depth).to eq(1)
      expect(grandchild.depth).to eq(2)
    end
  end

  describe "#all_bindings" do
    it "merges parent bindings" do
      env.define("x", "Integer")
      child = described_class.new(env)
      child.define("y", "String")

      expect(child.all_bindings).to eq({ "x" => "Integer", "y" => "String" })
    end

    it "child bindings override parent" do
      env.define("x", "Integer")
      child = described_class.new(env)
      child.define("x", "String")

      expect(child.all_bindings["x"]).to eq("String")
    end
  end

  describe "#to_s" do
    it "includes depth" do
      expect(env.to_s).to include("depth=0")
    end

    it "includes locals when present" do
      env.define("x", "Integer")
      expect(env.to_s).to include("locals:")
    end

    it "includes ivars when present" do
      env.define_instance_var("@x", "Integer")
      expect(env.to_s).to include("ivars:")
    end
  end
end
`,
  "spec/t_ruby/type_erasure_extended_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::TypeErasure do
  describe "type alias erasure" do
    context "simple type alias removal" do
      it "removes type alias definitions" do
        source = "type UserId = String"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).not_to include("type UserId")
        expect(result.strip).to be_empty
      end

      it "removes multiple type alias definitions" do
        source = "type UserId = String\\ntype Age = Integer"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).not_to include("type UserId")
        expect(result).not_to include("type Age")
      end

      it "preserves code after type aliases" do
        source = "type UserId = String\\ndef greet(id: UserId): String\\n  'hello'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def greet(id)")
        expect(result).not_to include("type UserId")
      end
    end

    context "mixed content" do
      it "handles type alias followed by function" do
        source = "type UserId = String" + "\\n" \\
                                          "def create(id: UserId): Boolean" + "\\n  " \\
                                                                              "true" + "\\n" \\
                                                                                       "end"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).not_to include("type UserId")
        expect(result).to include("def create(id)")
      end

      it "preserves function with type alias reference" do
        source = "type Result = Boolean" + "\\n" \\
                                           "def success(): Result" + "\\n  " \\
                                                                     "true" + "\\n" \\
                                                                              "end"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).not_to include("type Result")
        expect(result).to include("def success()")
      end
    end

    context "type alias with complex definitions" do
      it "removes type alias with reference to another type" do
        source = "type AdminId = UserId"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result.strip).to be_empty
      end
    end
  end
end
`,
  "spec/t_ruby/type_erasure_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::TypeErasure do
  describe "type annotation removal" do
    context "parameter type annotations" do
      it "removes simple parameter type annotation" do
        source = "def greet(name: String)\\n  puts name\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def greet(name)")
        expect(result).not_to include(": String")
      end

      it "removes multiple parameter type annotations" do
        source = "def add(a: Integer, b: Integer)\\n  a + b\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def add(a, b)")
        expect(result).not_to include(": Integer")
      end

      it "preserves function body" do
        source = "def greet(name: String)" + "\\n  " \\
                                             'puts "Hello, #{name}"' + "\\n" \\
                                                                       "end"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include('puts "Hello, #{')
      end

      it "handles multiple parameters with various types" do
        source = "def create(name: String, age: Integer, active: Boolean)\\n  name\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def create(name, age, active)")
      end

      it "preserves default value for parameter with type" do
        source = "def greet(name: String, greeting: String = \\"Hello\\")\\n  " \\
                 "\\"\\#{greeting}, \\#{name}!\\"\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include('def greet(name, greeting = "Hello")')
        expect(result).not_to include(": String")
      end

      it "preserves default value with numeric value" do
        source = "def add(a: Integer, b: Integer = 0)\\n  a + b\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def add(a, b = 0)")
      end

      it "preserves default value with nil" do
        source = "def find(id: Integer, fallback: String = nil)\\n  id\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def find(id, fallback = nil)")
      end

      it "preserves multiple default values" do
        source = "def config(host: String = \\"localhost\\", port: Integer = 8080)\\n  " \\
                 "host\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include('def config(host = "localhost", port = 8080)')
      end
    end

    context "return type annotations" do
      it "removes return type annotation" do
        source = "def get_name(): String\\n  'John'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def get_name()")
        expect(result).not_to include(": String")
      end

      it "removes return type when there are parameters" do
        source = "def greet(name: String): String\\n  name\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def greet(name)")
        expect(result).not_to include(": String")
      end

      it "removes void return type" do
        source = "def do_something(): void\\n  puts 'done'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def do_something()")
        expect(result).not_to include(": void")
      end
    end

    context "mixed typed and untyped code" do
      it "preserves untyped function definitions" do
        source = "def untyped(x)\\n  x\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to eq(source)
      end

      it "handles code with typed and untyped functions" do
        source = <<~RUBY
          def typed(x: String)
            x
          end

          def untyped(y)
            y
          end
        RUBY
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def typed(x)")
        expect(result).to include("def untyped(y)")
      end

      it "preserves comments" do
        source = <<~RUBY
          # This is a comment
          def greet(name: String): String
            # Inner comment
            name
          end
        RUBY
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("# This is a comment")
        expect(result).to include("# Inner comment")
      end
    end

    context "special cases" do
      it "handles functions with no parameters" do
        source = "def hello(): String\\n  'hello'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def hello()")
      end

      it "handles functions without parentheses and with return type" do
        source = "def hello: String\\n  'hello'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def hello")
        expect(result).not_to include(": String")
      end

      it "handles nested structures" do
        source = "class Greeter" + "\\n  " \\
                                   "def greet(name: String): String" + "\\n    " \\
                                                                       '"Hello, #{name}"' + "\\n  " \\
                                                                                            "end" + "\\n" \\
                                                                                                    "end"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def greet(name)")
        expect(result).not_to include(": String")
      end

      it "preserves whitespace in function bodies" do
        source = "def greet(name: String)\\n  puts name\\n\\n  puts 'done'\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def greet(name)")
        expect(result).to include("\\n  puts name\\n\\n  puts 'done'\\n")
      end
    end

    context "edge cases" do
      it "handles parameter without type followed by one with type" do
        source = "def process(value, name: String)\\n  value + name\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def process(value, name)")
      end

      it "handles type with spaces" do
        source = "def test(x: String , y: Integer )\\n  x\\nend"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        # After type removal, spaces remain but types are gone
        expect(result).to include("def test(x , y )")
        expect(result).not_to include(": String")
        expect(result).not_to include(": Integer")
      end

      it "preserves existing Ruby code without types" do
        source = "puts 'hello'\\narray = [1, 2, 3]\\nhash = { key: 'value' }"
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to eq(source)
      end
    end

    context "multiple functions" do
      it "erases types in all functions" do
        source = <<~RUBY
          def add(a: Integer, b: Integer): Integer
            a + b
          end

          def concat(s1: String, s2: String): String
            s1 + s2
          end
        RUBY
        eraser = TRuby::TypeErasure.new(source)

        result = eraser.erase
        expect(result).to include("def add(a, b)")
        expect(result).to include("def concat(s1, s2)")
        expect(result).not_to include(": Integer")
        expect(result).not_to include(": String")
      end
    end
  end
end
`,
  "spec/t_ruby/type_inferencer_spec.rb": `# frozen_string_literal: true

require "spec_helper"

RSpec.describe TRuby::InferredType do
  describe "#high_confidence?" do
    it "returns true for high confidence" do
      type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::HIGH)
      expect(type.high_confidence?).to be true
    end

    it "returns false for medium confidence" do
      type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::MEDIUM)
      expect(type.high_confidence?).to be false
    end
  end

  describe "#to_s" do
    it "returns the type string" do
      type = TRuby::InferredType.new(type: "Integer")
      expect(type.to_s).to eq("Integer")
    end
  end
end

RSpec.describe TRuby::TypeInferencer do
  let(:inferencer) { TRuby::TypeInferencer.new }

  describe "#infer_literal" do
    context "with string literals" do
      it "infers double-quoted strings" do
        result = inferencer.infer_literal('"hello"')
        expect(result.type).to eq("String")
        expect(result.confidence).to eq(TRuby::InferredType::HIGH)
      end

      it "infers single-quoted strings" do
        result = inferencer.infer_literal("'hello'")
        expect(result.type).to eq("String")
      end
    end

    context "with integer literals" do
      it "infers decimal integers" do
        result = inferencer.infer_literal("42")
        expect(result.type).to eq("Integer")
      end

      it "infers negative integers" do
        result = inferencer.infer_literal("-42")
        expect(result.type).to eq("Integer")
      end

      it "infers hexadecimal integers" do
        result = inferencer.infer_literal("0xFF")
        expect(result.type).to eq("Integer")
      end

      it "infers binary integers" do
        result = inferencer.infer_literal("0b1010")
        expect(result.type).to eq("Integer")
      end

      it "infers octal integers" do
        result = inferencer.infer_literal("0o755")
        expect(result.type).to eq("Integer")
      end
    end

    context "with float literals" do
      it "infers decimal floats" do
        result = inferencer.infer_literal("3.14")
        expect(result.type).to eq("Float")
      end

      it "infers scientific notation" do
        result = inferencer.infer_literal("1e10")
        expect(result.type).to eq("Float")
      end
    end

    context "with boolean literals" do
      it "infers true" do
        result = inferencer.infer_literal("true")
        expect(result.type).to eq("Boolean")
      end

      it "infers false" do
        result = inferencer.infer_literal("false")
        expect(result.type).to eq("Boolean")
      end
    end

    context "with nil literal" do
      it "infers nil" do
        result = inferencer.infer_literal("nil")
        expect(result.type).to eq("nil")
      end
    end

    context "with symbol literals" do
      it "infers symbols" do
        result = inferencer.infer_literal(":symbol")
        expect(result.type).to eq("Symbol")
      end
    end

    context "with array literals" do
      it "infers arrays" do
        result = inferencer.infer_literal("[1, 2, 3]")
        expect(result.type).to eq("Array")
      end
    end

    context "with hash literals" do
      it "infers hashes" do
        result = inferencer.infer_literal("{a: 1}")
        expect(result.type).to eq("Hash")
      end
    end

    context "with regex literals" do
      it "infers regexes" do
        result = inferencer.infer_literal("/pattern/")
        expect(result.type).to eq("Regexp")
      end
    end
  end

  describe "#infer_method_call" do
    it "infers to_s returns String" do
      result = inferencer.infer_method_call("Integer", "to_s")
      expect(result.type).to eq("String")
    end

    it "infers to_i returns Integer" do
      result = inferencer.infer_method_call("String", "to_i")
      expect(result.type).to eq("Integer")
    end

    it "infers length returns Integer" do
      result = inferencer.infer_method_call("String", "length")
      expect(result.type).to eq("Integer")
    end

    it "infers upcase returns String" do
      result = inferencer.infer_method_call("String", "upcase")
      expect(result.type).to eq("String")
    end

    it "infers split returns Array<String>" do
      result = inferencer.infer_method_call("String", "split")
      expect(result.type).to eq("Array<String>")
    end

    it "infers empty? returns Boolean" do
      result = inferencer.infer_method_call("Array", "empty?")
      expect(result.type).to eq("Boolean")
    end

    it "infers keys returns Array" do
      result = inferencer.infer_method_call("Hash", "keys")
      expect(result.type).to eq("Array")
    end
  end

  describe "#infer_return_type" do
    it "infers from explicit return with literal" do
      body = <<~RUBY
        return "hello"
      RUBY
      result = inferencer.infer_return_type(body)
      expect(result.type).to eq("String")
    end

    it "infers from explicit return with integer" do
      body = <<~RUBY
        return 42
      RUBY
      result = inferencer.infer_return_type(body)
      expect(result.type).to eq("Integer")
    end

    it "infers nil for empty body" do
      result = inferencer.infer_return_type("")
      expect(result.type).to eq("nil")
    end

    it "infers union type for multiple return types" do
      body = <<~RUBY
        if condition
          return "string"
        else
          return 42
        end
      RUBY
      result = inferencer.infer_return_type(body)
      expect(result.type).to include("String")
      expect(result.type).to include("Integer")
    end
  end

  describe "#infer_parameter_types" do
    it "infers numeric type from arithmetic usage" do
      body = "x + 1"
      params = [{ name: "x" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result["x"]&.type).to eq("Numeric")
    end

    it "infers String type from string method usage" do
      body = "s.upcase"
      params = [{ name: "s" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result["s"]&.type).to eq("String")
    end

    it "infers Array type from array method usage" do
      body = "arr.map { |x| x }"
      params = [{ name: "arr" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result["arr"]&.type).to eq("Array")
    end
  end

  describe "#infer_narrowed_type" do
    it "narrows type from is_a? guard" do
      result = inferencer.infer_narrowed_type("x", "x.is_a?(String)")
      expect(result.type).to eq("String")
    end

    it "narrows type from nil? check" do
      result = inferencer.infer_narrowed_type("x", "x.nil?")
      expect(result.type).to eq("nil")
    end
  end

  describe "#infer_expression_type" do
    it "infers literal types" do
      expect(inferencer.infer_expression_type("42").type).to eq("Integer")
      expect(inferencer.infer_expression_type('"hello"').type).to eq("String")
    end

    it "infers comparison operator returns Boolean" do
      result = inferencer.infer_expression_type("a == b")
      expect(result.type).to eq("Boolean")
    end

    it "infers array construction" do
      result = inferencer.infer_expression_type("[1, 2, 3]")
      expect(result.type).to include("Array")
    end

    it "infers empty array" do
      result = inferencer.infer_expression_type("[]")
      expect(result.type).to eq("Array")
    end

    it "infers hash construction" do
      result = inferencer.infer_expression_type("{a: 1}")
      expect(result.type).to eq("Hash")
    end
  end

  describe "#record_variable_type and #get_variable_type" do
    it "records and retrieves variable types" do
      type = TRuby::InferredType.new(type: "String")
      inferencer.record_variable_type("name", type)
      expect(inferencer.get_variable_type("name")).to eq(type)
    end
  end

  describe "#add_warning" do
    it "adds warnings to the list" do
      inferencer.add_warning("Ambiguous type inference")
      expect(inferencer.warnings.length).to eq(1)
      expect(inferencer.warnings.first[:message]).to eq("Ambiguous type inference")
    end
  end

  describe "#reset" do
    it "clears all state" do
      inferencer.record_variable_type("x", TRuby::InferredType.new(type: "String"))
      inferencer.add_warning("test")
      inferencer.reset
      expect(inferencer.get_variable_type("x")).to be_nil
      expect(inferencer.warnings).to be_empty
    end
  end

  describe "#infer_generic_params" do
    it "infers generic parameters from arguments" do
      call_args = ['"hello"']
      func_params = [{ name: "item", type: "Array<T>" }]

      # This is a simplified test - real implementation would be more complex
      result = inferencer.infer_generic_params(call_args, func_params)
      expect(result).to be_a(Hash)
    end

    it "returns empty hash when no generics" do
      call_args = ['"hello"']
      func_params = [{ name: "item", type: "String" }]

      result = inferencer.infer_generic_params(call_args, func_params)
      expect(result).to eq({})
    end
  end

  describe "InferredType" do
    describe "#medium_confidence?" do
      it "returns true for medium confidence" do
        type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::MEDIUM)
        expect(type.medium_confidence?).to be true
      end

      it "returns false for high confidence" do
        type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::HIGH)
        expect(type.medium_confidence?).to be false
      end
    end

    describe "#low_confidence?" do
      it "returns true for low confidence" do
        type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::LOW)
        expect(type.low_confidence?).to be true
      end

      it "returns false for medium confidence" do
        type = TRuby::InferredType.new(type: "String", confidence: TRuby::InferredType::MEDIUM)
        expect(type.low_confidence?).to be false
      end
    end

    describe "attributes" do
      it "stores source" do
        type = TRuby::InferredType.new(type: "String", source: :literal)
        expect(type.source).to eq(:literal)
      end

      it "stores location" do
        type = TRuby::InferredType.new(type: "String", location: { line: 10, column: 5 })
        expect(type.location).to eq({ line: 10, column: 5 })
      end
    end
  end

  describe "#infer_literal" do
    it "returns nil for non-literal expressions" do
      result = inferencer.infer_literal("some_variable")
      expect(result).to be_nil
    end

    it "handles underscored integers" do
      result = inferencer.infer_literal("1_000_000")
      # Depends on pattern - may or may not match
      expect(result.nil? || result.type == "Integer").to be true
    end
  end

  describe "#infer_method_call" do
    it "infers gsub returns String" do
      result = inferencer.infer_method_call("String", "gsub")
      expect(result.type).to eq("String")
    end

    it "infers chars returns Array<String>" do
      result = inferencer.infer_method_call("String", "chars")
      expect(result.type).to eq("Array<String>")
    end

    it "infers bytes returns Array<Integer>" do
      result = inferencer.infer_method_call("String", "bytes")
      expect(result.type).to eq("Array<Integer>")
    end

    it "infers to_f returns Float" do
      result = inferencer.infer_method_call("Integer", "to_f")
      expect(result.type).to eq("Float")
    end

    it "infers flatten returns Array" do
      result = inferencer.infer_method_call("Array", "flatten")
      expect(result.type).to eq("Array")
    end

    it "infers merge returns Hash" do
      result = inferencer.infer_method_call("Hash", "merge")
      expect(result.type).to eq("Hash")
    end

    it "infers class returns Class" do
      result = inferencer.infer_method_call("Object", "class")
      expect(result.type).to eq("Class")
    end

    it "infers inspect returns String" do
      result = inferencer.infer_method_call("Object", "inspect")
      expect(result.type).to eq("String")
    end

    it "infers nil? returns Boolean" do
      result = inferencer.infer_method_call("Object", "nil?")
      expect(result.type).to eq("Boolean")
    end

    it "infers from receiver for unknown method on string" do
      # Unknown methods on String receiver may return String (via infer_from_receiver heuristic)
      result = inferencer.infer_method_call("String", "some_method_x")
      # The implementation returns String for any lowercase method on String receiver
      expect(result).not_to be_nil
    end

    context "with receiver type" do
      it "infers String method returns from receiver" do
        # This uses infer_from_receiver
        result = inferencer.infer_method_call("String", "chars")
        expect(result.type).to eq("Array<String>")
      end
    end
  end

  describe "#infer_return_type" do
    it "returns nil for body with no inferable returns" do
      body = "some_method_call()"
      result = inferencer.infer_return_type(body)
      # Returns nil confidence medium due to implicit return
      expect(result.type).to eq("nil")
    end
  end

  describe "#infer_parameter_types" do
    it "infers Hash type from hash method usage" do
      body = "h.keys"
      params = [{ name: "h" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result["h"]&.type).to eq("Hash")
    end

    it "infers Numeric type from numeric method usage" do
      body = "n.abs"
      params = [{ name: "n" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result["n"]&.type).to eq("Numeric")
    end

    it "returns empty hash for unused parameters" do
      body = "puts 'hello'"
      params = [{ name: "unused" }]
      result = inferencer.infer_parameter_types(body, params)
      expect(result).to eq({})
    end

    it "handles comparison operations" do
      body = "x > 10"
      params = [{ name: "x" }]
      result = inferencer.infer_parameter_types(body, params)
      # Comparison doesn't determine type by itself
      expect(result).to be_a(Hash)
    end

    it "handles string interpolation" do
      body = 'puts "Hello #{name}"'
      params = [{ name: "name" }]
      result = inferencer.infer_parameter_types(body, params)
      # String interpolation doesn't determine type
      expect(result).to be_a(Hash)
    end
  end

  describe "#infer_narrowed_type" do
    it "returns nil for respond_to? check" do
      result = inferencer.infer_narrowed_type("x", "x.respond_to?(:to_s)")
      expect(result).to be_nil
    end

    it "returns nil for unknown condition" do
      result = inferencer.infer_narrowed_type("x", "some_condition")
      expect(result).to be_nil
    end
  end

  describe "#infer_expression_type" do
    it "infers method chain" do
      result = inferencer.infer_expression_type('"hello".upcase.length')
      expect(result&.type).to eq("Integer")
    end

    it "infers logical operators" do
      result = inferencer.infer_expression_type("a && b")
      # && propagates types, may return nil
      expect(result).to be_nil
    end

    it "infers negation operator" do
      result = inferencer.infer_expression_type("a ! b")
      # Negation requires space-surrounded operator in the implementation
      expect(result&.type).to eq("Boolean") if result
    end

    it "infers bitwise operators" do
      result = inferencer.infer_expression_type("a & b")
      expect(result&.type).to eq("Integer")
    end

    it "infers spaceship operator" do
      result = inferencer.infer_expression_type("a <=> b")
      expect(result&.type).to eq("Integer")
    end

    it "infers less-than-or-equal operator" do
      result = inferencer.infer_expression_type("a <= b")
      expect(result&.type).to eq("Boolean")
    end

    it "infers modulo operator" do
      result = inferencer.infer_expression_type("a % b")
      expect(result&.type).to eq("Numeric")
    end

    it "infers typed array construction" do
      result = inferencer.infer_expression_type('["a", "b", "c"]')
      expect(result&.type).to include("Array")
      # Element type inference may not work for quoted strings in simple split
    end

    it "infers mixed type array" do
      result = inferencer.infer_expression_type('[1, "hello"]')
      expect(result&.type).to include("Array")
    end
  end

  describe "LITERAL_PATTERNS constant" do
    it "includes all expected patterns" do
      patterns = TRuby::TypeInferencer::LITERAL_PATTERNS
      expect(patterns.values).to include("String", "Integer", "Float", "Boolean", "nil", "Symbol", "Array", "Hash", "Regexp")
    end
  end

  describe "METHOD_RETURN_TYPES constant" do
    it "includes common methods" do
      types = TRuby::TypeInferencer::METHOD_RETURN_TYPES
      expect(types["to_s"]).to eq("String")
      expect(types["to_i"]).to eq("Integer")
      expect(types["empty?"]).to eq("Boolean")
    end
  end

  describe "OPERATOR_TYPES constant" do
    it "includes arithmetic operators" do
      ops = TRuby::TypeInferencer::OPERATOR_TYPES
      expect(ops["+"]).to eq(:numeric_or_string)
      expect(ops["-"]).to eq(:numeric)
    end

    it "includes comparison operators" do
      ops = TRuby::TypeInferencer::OPERATOR_TYPES
      expect(ops["=="]).to eq("Boolean")
      expect(ops["<"]).to eq("Boolean")
    end
  end

  describe "#add_warning" do
    it "stores warning with location" do
      inferencer.add_warning("Test warning", location: { line: 5 })
      warning = inferencer.warnings.first
      expect(warning[:location]).to eq({ line: 5 })
    end
  end

  describe "private methods via send" do
    describe "#extract_return_statements" do
      it "extracts explicit returns" do
        body = "return 42"
        statements = inferencer.send(:extract_return_statements, body)
        expect(statements.length).to eq(1)
        expect(statements.first[:value]).to eq("42")
      end

      it "handles multiple returns" do
        body = "if x\\n  return 1\\nelse\\n  return 2\\nend"
        statements = inferencer.send(:extract_return_statements, body)
        expect(statements.length).to eq(2)
      end
    end

    describe "#find_parameter_usages" do
      it "finds method calls on parameter" do
        body = "x.upcase.strip"
        usages = inferencer.send(:find_parameter_usages, body, "x")
        expect(usages.any? { |u| u[:type] == :method_call }).to be true
      end

      it "finds arithmetic usage" do
        body = "x + 1"
        usages = inferencer.send(:find_parameter_usages, body, "x")
        expect(usages.any? { |u| u[:type] == :arithmetic }).to be true
      end
    end

    describe "#infer_type_from_method" do
      it "identifies string methods" do
        expect(inferencer.send(:infer_type_from_method, "upcase")).to eq("String")
        expect(inferencer.send(:infer_type_from_method, "downcase")).to eq("String")
      end

      it "identifies array methods" do
        expect(inferencer.send(:infer_type_from_method, "each")).to eq("Array")
        expect(inferencer.send(:infer_type_from_method, "map")).to eq("Array")
      end

      it "identifies hash methods" do
        expect(inferencer.send(:infer_type_from_method, "keys")).to eq("Hash")
        expect(inferencer.send(:infer_type_from_method, "values")).to eq("Hash")
      end

      it "identifies numeric methods" do
        expect(inferencer.send(:infer_type_from_method, "abs")).to eq("Numeric")
        expect(inferencer.send(:infer_type_from_method, "times")).to eq("Numeric")
      end

      it "returns nil for unknown methods" do
        expect(inferencer.send(:infer_type_from_method, "unknown")).to be_nil
      end
    end

    describe "#infer_from_receiver" do
      it "returns nil for nil receiver" do
        result = inferencer.send(:infer_from_receiver, nil, "length")
        expect(result).to be_nil
      end

      it "infers String receiver methods" do
        expect(inferencer.send(:infer_from_receiver, "String", "length")).to eq("Integer")
        expect(inferencer.send(:infer_from_receiver, "String", "chars")).to eq("Array<String>")
      end

      it "infers Array receiver methods" do
        expect(inferencer.send(:infer_from_receiver, "Array", "length")).to eq("Integer")
        expect(inferencer.send(:infer_from_receiver, "Array", "join")).to eq("String")
      end

      it "infers Numeric receiver methods" do
        expect(inferencer.send(:infer_from_receiver, "Integer", "to_s")).to eq("String")
        expect(inferencer.send(:infer_from_receiver, "Float", "to_i")).to eq("Integer")
      end
    end

    describe "#infer_operator_result" do
      it "returns Boolean for comparison" do
        result = inferencer.send(:infer_operator_result, "a == b", "==", "Boolean")
        expect(result.type).to eq("Boolean")
      end

      it "returns Integer for bitwise" do
        result = inferencer.send(:infer_operator_result, "a & b", "&", "Integer")
        expect(result.type).to eq("Integer")
      end

      it "returns Numeric for arithmetic" do
        result = inferencer.send(:infer_operator_result, "a - b", "-", :numeric)
        expect(result.type).to eq("Numeric")
      end

      it "returns mixed type for ambiguous" do
        result = inferencer.send(:infer_operator_result, "a + b", "+", :numeric_or_string)
        expect(result.type).to include("Numeric")
      end

      it "returns nil for propagate type" do
        result = inferencer.send(:infer_operator_result, "a && b", "&&", :propagate)
        expect(result).to be_nil
      end
    end

    describe "#infer_array_type" do
      it "infers empty array" do
        result = inferencer.send(:infer_array_type, "[]")
        expect(result.type).to eq("Array")
      end

      it "infers homogeneous array" do
        result = inferencer.send(:infer_array_type, "[1, 2, 3]")
        expect(result.type).to eq("Array<Integer>")
      end

      it "infers string array" do
        result = inferencer.send(:infer_array_type, '["a", "b"]')
        expect(result.type).to eq("Array<String>")
      end
    end

    describe "#split_array_elements" do
      it "splits simple elements" do
        result = inferencer.send(:split_array_elements, "1, 2, 3")
        expect(result).to eq(%w[1 2 3])
      end

      it "handles whitespace" do
        result = inferencer.send(:split_array_elements, "  a  ,  b  ")
        expect(result).to eq(%w[a b])
      end
    end

    describe "#infer_from_usages" do
      it "returns nil for empty usages" do
        result = inferencer.send(:infer_from_usages, [])
        expect(result).to be_nil
      end

      it "infers from arithmetic usage" do
        usages = [{ type: :arithmetic, line: 1 }]
        result = inferencer.send(:infer_from_usages, usages)
        expect(result.type).to eq("Numeric")
      end

      it "infers from method call usage" do
        usages = [{ type: :method_call, method: "upcase", line: 1 }]
        result = inferencer.send(:infer_from_usages, usages)
        expect(result.type).to eq("String")
      end
    end
  end
end
`,
  "spec/t_ruby/union_type_parser_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::UnionTypeParser do
  describe "#parse" do
    it "parses simple type" do
      parser = described_class.new("String")
      result = parser.parse
      expect(result[:type]).to eq(:simple)
      expect(result[:value]).to eq("String")
    end

    it "parses union with two types" do
      parser = described_class.new("String | Integer")
      result = parser.parse
      expect(result[:type]).to eq(:union)
      expect(result[:members]).to eq(%w[String Integer])
    end

    it "parses union with multiple types" do
      parser = described_class.new("String | Integer | Boolean | nil")
      result = parser.parse
      expect(result[:type]).to eq(:union)
      expect(result[:members]).to eq(%w[String Integer Boolean nil])
    end

    it "detects duplicates" do
      parser = described_class.new("String | Integer | String")
      result = parser.parse
      expect(result[:has_duplicates]).to be true
      expect(result[:unique_members]).to eq(%w[String Integer])
    end

    it "reports no duplicates when none exist" do
      parser = described_class.new("String | Integer")
      result = parser.parse
      expect(result[:has_duplicates]).to be false
    end

    it "strips whitespace" do
      parser = described_class.new("  String  |  Integer  ")
      result = parser.parse
      expect(result[:members]).to eq(%w[String Integer])
    end

    it "handles nil type" do
      parser = described_class.new("String | nil")
      result = parser.parse
      expect(result[:members]).to include("nil")
    end
  end
end
`,
  "spec/t_ruby/union_type_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::UnionTypeParser do
  describe "parsing union types" do
    it "parses simple union types with pipe separator" do
      parser = TRuby::UnionTypeParser.new("String | Integer")
      result = parser.parse

      expect(result[:type]).to eq(:union)
      expect(result[:members]).to eq(%w[String Integer])
    end

    it "parses union with three or more types" do
      parser = TRuby::UnionTypeParser.new("String | Integer | Boolean")
      result = parser.parse

      expect(result[:members].length).to eq(3)
      expect(result[:members]).to include("String", "Integer", "Boolean")
    end

    it "parses union with nil" do
      parser = TRuby::UnionTypeParser.new("String | nil")
      result = parser.parse

      expect(result[:members]).to include("String", "nil")
    end

    it "handles whitespace around pipes" do
      parser = TRuby::UnionTypeParser.new("String  |  Integer  |  Boolean")
      result = parser.parse

      expect(result[:members]).to eq(%w[String Integer Boolean])
    end

    it "identifies single types as non-union" do
      parser = TRuby::UnionTypeParser.new("String")
      result = parser.parse

      expect(result[:type]).to eq(:simple)
      expect(result[:value]).to eq("String")
    end
  end

  describe "union type validation" do
    it "detects duplicate types in union" do
      parser = TRuby::UnionTypeParser.new("String | String | Integer")
      result = parser.parse

      expect(result[:has_duplicates]).to be true
    end

    it "normalizes duplicate types" do
      parser = TRuby::UnionTypeParser.new("String | Integer | String")
      result = parser.parse

      expect(result[:unique_members]).to eq(%w[String Integer])
    end
  end
end

describe TRuby::Parser do
  describe "parsing function with union type parameters" do
    it "parses function with union parameter type" do
      source = "def process(value: String | Integer): Boolean\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:params][0][:type]).to eq("String | Integer")
    end

    it "parses function with union return type" do
      source = "def get_value(): String | nil\\nend"
      parser = TRuby::Parser.new(source)

      result = parser.parse
      expect(result[:functions][0][:return_type]).to eq("String | nil")
    end
  end
end

describe TRuby::ErrorHandler do
  describe "union type validation" do
    it "accepts valid union types" do
      source = "def test(x: String | Integer): Boolean\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end

    it "validates that union members are recognized types" do
      source = "def test(): String | Integer\\nend"
      handler = TRuby::ErrorHandler.new(source)

      errors = handler.check
      expect(errors).to be_empty
    end
  end
end
`,
  "spec/t_ruby/version_checker_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::VersionChecker do
  describe "GEM_NAME" do
    it "is t-ruby" do
      expect(described_class::GEM_NAME).to eq("t-ruby")
    end
  end

  describe "RUBYGEMS_API" do
    it "points to rubygems.org" do
      expect(described_class::RUBYGEMS_API).to include("rubygems.org")
      expect(described_class::RUBYGEMS_API).to include("t-ruby")
    end
  end

  describe ".check" do
    it "creates instance and calls check" do
      instance = instance_double(described_class)
      allow(described_class).to receive(:new).and_return(instance)
      allow(instance).to receive(:check).and_return(nil)

      described_class.check

      expect(instance).to have_received(:check)
    end
  end

  describe ".update" do
    it "creates instance and calls update" do
      instance = instance_double(described_class)
      allow(described_class).to receive(:new).and_return(instance)
      allow(instance).to receive(:update).and_return(true)

      described_class.update

      expect(instance).to have_received(:update)
    end
  end

  describe "#check" do
    let(:checker) { described_class.new }

    context "when latest version is higher" do
      before do
        allow(checker).to receive(:fetch_latest_version).and_return("999.0.0")
      end

      it "returns hash with current and latest versions" do
        result = checker.check
        expect(result).to be_a(Hash)
        expect(result).to have_key(:current)
        expect(result).to have_key(:latest)
        expect(result[:latest]).to eq("999.0.0")
      end
    end

    context "when current version is up to date" do
      before do
        allow(checker).to receive(:fetch_latest_version).and_return(TRuby::VERSION)
      end

      it "returns nil" do
        result = checker.check
        expect(result).to be_nil
      end
    end

    context "when fetch fails" do
      before do
        allow(checker).to receive(:fetch_latest_version).and_return(nil)
      end

      it "returns nil" do
        result = checker.check
        expect(result).to be_nil
      end
    end
  end

  describe "#update" do
    let(:checker) { described_class.new }

    it "runs gem install command" do
      allow(checker).to receive(:system).with("gem install t-ruby").and_return(true)

      result = checker.update

      expect(checker).to have_received(:system).with("gem install t-ruby")
      expect(result).to be true
    end
  end

  describe "#fetch_latest_version (private)" do
    let(:checker) { described_class.new }

    context "when API returns success" do
      it "parses version from JSON response" do
        response_body = '{"version": "1.2.3"}'
        response = instance_double(Net::HTTPSuccess, body: response_body)
        allow(response).to receive(:is_a?).with(Net::HTTPSuccess).and_return(true)

        http = instance_double(Net::HTTP)
        allow(Net::HTTP).to receive(:new).and_return(http)
        allow(http).to receive(:use_ssl=)
        allow(http).to receive(:verify_mode=)
        allow(http).to receive(:verify_callback=)
        allow(http).to receive(:open_timeout=)
        allow(http).to receive(:read_timeout=)
        allow(http).to receive(:request).and_return(response)

        result = checker.send(:fetch_latest_version)
        expect(result).to eq("1.2.3")
      end
    end

    context "when API returns error" do
      it "returns nil" do
        response = instance_double(Net::HTTPNotFound)
        allow(response).to receive(:is_a?).with(Net::HTTPSuccess).and_return(false)

        http = instance_double(Net::HTTP)
        allow(Net::HTTP).to receive(:new).and_return(http)
        allow(http).to receive(:use_ssl=)
        allow(http).to receive(:verify_mode=)
        allow(http).to receive(:verify_callback=)
        allow(http).to receive(:open_timeout=)
        allow(http).to receive(:read_timeout=)
        allow(http).to receive(:request).and_return(response)

        result = checker.send(:fetch_latest_version)
        expect(result).to be_nil
      end
    end

    context "when network error occurs" do
      it "returns nil" do
        allow(Net::HTTP).to receive(:new).and_raise(SocketError.new("Network error"))

        result = checker.send(:fetch_latest_version)
        expect(result).to be_nil
      end
    end

    context "when timeout occurs" do
      it "returns nil" do
        allow(Net::HTTP).to receive(:new).and_raise(Net::OpenTimeout.new("Timeout"))

        result = checker.send(:fetch_latest_version)
        expect(result).to be_nil
      end
    end
  end
end
`,
  "spec/t_ruby/version_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby do
  describe "VERSION" do
    it "is defined" do
      expect(TRuby::VERSION).to be_a(String)
    end

    it "is in semantic versioning format" do
      expect(TRuby::VERSION).to match(/^\\d+\\.\\d+\\.\\d+$/)
    end
  end
end
`,
  "spec/t_ruby/watcher_spec.rb": `# frozen_string_literal: true

require "spec_helper"

describe TRuby::Watcher do
  describe "#initialize" do
    it "initializes with default path" do
      watcher = TRuby::Watcher.new
      expect(watcher).to be_a(TRuby::Watcher)
    end

    it "accepts custom paths" do
      watcher = TRuby::Watcher.new(paths: ["src/", "lib/"])
      expect(watcher).to be_a(TRuby::Watcher)
    end

    it "accepts custom config" do
      config = TRuby::Config.new
      watcher = TRuby::Watcher.new(config: config)
      expect(watcher).to be_a(TRuby::Watcher)
    end
  end

  describe "COLORS constant" do
    it "defines ANSI color codes" do
      expect(TRuby::Watcher::COLORS).to include(:reset, :red, :green, :cyan)
    end
  end

  describe "TypeScript-style output" do
    let(:watcher) { TRuby::Watcher.new }

    describe "#timestamp" do
      it "returns time in [HH:MM:SS AM/PM] format" do
        timestamp = watcher.send(:timestamp)
        expect(timestamp).to match(/\\[\\d{2}:\\d{2}:\\d{2} [AP]M\\]/)
      end
    end

    describe "#relative_path" do
      it "converts absolute path to relative" do
        absolute_path = "#{Dir.pwd}/src/test.trb"
        relative = watcher.send(:relative_path, absolute_path)
        expect(relative).to eq("src/test.trb")
      end

      it "returns unchanged if not in current directory" do
        other_path = "/other/path/test.trb"
        relative = watcher.send(:relative_path, other_path)
        expect(relative).to eq(other_path)
      end
    end

    describe "#colorize" do
      context "when output is not a TTY" do
        before do
          allow($stdout).to receive(:tty?).and_return(false)
        end

        it "returns plain text without ANSI codes" do
          watcher_no_color = TRuby::Watcher.new
          result = watcher_no_color.send(:colorize, :red, "error")
          expect(result).to eq("error")
          expect(result).not_to include("\\e[")
        end
      end
    end

    describe "#create_generic_diagnostic" do
      it "returns Diagnostic with file, line, column, and message" do
        diagnostic = watcher.send(:create_generic_diagnostic, "test.trb", "syntax error")

        expect(diagnostic).to be_a(TRuby::Diagnostic)
        expect(diagnostic.file).to eq("test.trb")
        expect(diagnostic.line).to eq(1)
        expect(diagnostic.column).to eq(1)
        expect(diagnostic.message).to eq("syntax error")
      end

      it "extracts line number from error message if available" do
        diagnostic = watcher.send(:create_generic_diagnostic, "test.trb", "error on line 42")
        expect(diagnostic.line).to eq(42)
      end

      it "includes error code TR0001" do
        diagnostic = watcher.send(:create_generic_diagnostic, "test.trb", "syntax error")
        expect(diagnostic.code).to eq("TR0001")
      end
    end
  end

  describe "file discovery" do
    describe "#find_trb_files" do
      it "finds .trb files in specified directories" do
        Dir.mktmpdir do |tmpdir|
          # Create test files
          File.write(File.join(tmpdir, "test1.trb"), "# test1")
          File.write(File.join(tmpdir, "test2.trb"), "# test2")
          File.write(File.join(tmpdir, "ignore.rb"), "# ignore")

          watcher = TRuby::Watcher.new(paths: [tmpdir])
          files = watcher.send(:find_trb_files)

          expect(files.length).to eq(2)
          expect(files.all? { |f| f.end_with?(".trb") }).to be true
        end
      end

      it "finds .trb files in subdirectories" do
        Dir.mktmpdir do |tmpdir|
          subdir = File.join(tmpdir, "sub")
          FileUtils.mkdir_p(subdir)
          File.write(File.join(subdir, "nested.trb"), "# nested")

          watcher = TRuby::Watcher.new(paths: [tmpdir])
          files = watcher.send(:find_trb_files)

          expect(files.length).to eq(1)
          expect(files.first).to include("nested.trb")
        end
      end

      it "handles single file path" do
        Dir.mktmpdir do |tmpdir|
          file_path = File.join(tmpdir, "single.trb")
          File.write(file_path, "# single")

          watcher = TRuby::Watcher.new(paths: [file_path])
          files = watcher.send(:find_trb_files)

          expect(files).to eq([file_path])
        end
      end
    end
  end

  describe "compilation" do
    describe "#compile_file" do
      it "returns success result for valid file" do
        Dir.mktmpdir do |tmpdir|
          input_file = File.join(tmpdir, "valid.trb")
          File.write(input_file, "def hello: void\\n  puts 'hi'\\nend")

          config = TRuby::Config.new
          allow(config).to receive(:out_dir).and_return(tmpdir)

          watcher = TRuby::Watcher.new(paths: [tmpdir], config: config)
          result = watcher.send(:compile_file, input_file)

          expect(result[:success]).to be true
          expect(result[:diagnostics]).to be_empty
        end
      end

      it "returns error result for non-existent file" do
        watcher = TRuby::Watcher.new(paths: ["."])
        result = watcher.send(:compile_file, "/nonexistent/file.trb")

        expect(result[:success]).to be false
        expect(result[:diagnostics]).not_to be_empty
      end
    end
  end

  describe "CLI integration" do
    it "help text includes watch option" do
      help = TRuby::CLI::HELP_TEXT
      expect(help).to include("--watch")
      expect(help).to include("-w")
    end

    it "help text includes watch examples" do
      help = TRuby::CLI::HELP_TEXT
      expect(help).to include("trc -w")
      expect(help).to include("Watch")
    end
  end

  describe "initialization options" do
    it "accepts incremental option" do
      watcher = TRuby::Watcher.new(incremental: true)
      expect(watcher.incremental_compiler).not_to be_nil
    end

    it "disables incremental compiler when incremental is false" do
      watcher = TRuby::Watcher.new(incremental: false)
      expect(watcher.incremental_compiler).to be_nil
    end

    it "initializes stats" do
      watcher = TRuby::Watcher.new
      expect(watcher.stats).to include(:total_compilations, :incremental_hits, :total_time)
    end
  end

  describe "#watch_directory" do
    let(:watcher) { TRuby::Watcher.new }

    it "returns directory as-is when path is directory" do
      Dir.mktmpdir do |tmpdir|
        result = watcher.send(:watch_directory, tmpdir)
        expect(result).to eq(tmpdir)
      end
    end

    it "returns dirname when path is file" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "# test")
        result = watcher.send(:watch_directory, file_path)
        expect(result).to eq(tmpdir)
      end
    end
  end

  describe "#find_rb_files" do
    it "finds .rb files in specified directories" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "test.rb"), "# test")
        File.write(File.join(tmpdir, "test.trb"), "# ignore")

        watcher = TRuby::Watcher.new(paths: [tmpdir])
        files = watcher.send(:find_rb_files)

        expect(files.length).to eq(1)
        expect(files.first).to end_with(".rb")
      end
    end
  end

  describe "#find_source_files_by_extension" do
    it "finds files with specified extension" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "test.trb"), "# trb")
        File.write(File.join(tmpdir, "test.rb"), "# rb")

        watcher = TRuby::Watcher.new(paths: [tmpdir])
        trb_files = watcher.send(:find_source_files_by_extension, ".trb")
        rb_files = watcher.send(:find_source_files_by_extension, ".rb")

        expect(trb_files.length).to eq(1)
        expect(rb_files.length).to eq(1)
      end
    end

    it "returns unique files" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "test.trb"), "# test")

        watcher = TRuby::Watcher.new(paths: [tmpdir, tmpdir])
        files = watcher.send(:find_source_files_by_extension, ".trb")

        expect(files.uniq).to eq(files)
      end
    end
  end

  describe "#compile_file_with_ir" do
    it "compiles file and updates incremental compiler" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        File.write(input_file, "def hello: void\\n  puts 'hi'\\nend")

        config = TRuby::Config.new
        allow(config).to receive(:out_dir).and_return(tmpdir)

        watcher = TRuby::Watcher.new(paths: [tmpdir], config: config, incremental: true)
        result = watcher.send(:compile_file_with_ir, input_file)

        expect(result).to have_key(:file)
        expect(result).to have_key(:diagnostics)
        expect(result).to have_key(:success)
      end
    end
  end

  describe "#create_diagnostic_from_cross_file_error" do
    let(:watcher) { TRuby::Watcher.new }

    it "creates diagnostic from cross file error" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")
        File.write(file_path, "def test: void\\nend")

        error = { file: file_path, message: "Undefined type" }
        diagnostic = watcher.send(:create_diagnostic_from_cross_file_error, error)

        expect(diagnostic).to be_a(TRuby::Diagnostic)
        expect(diagnostic.message).to eq("Undefined type")
      end
    end
  end

  describe "statistics" do
    it "tracks total compilations" do
      Dir.mktmpdir do |tmpdir|
        input_file = File.join(tmpdir, "test.trb")
        File.write(input_file, "def hello: void\\n  puts 'hi'\\nend")

        config = TRuby::Config.new
        allow(config).to receive(:out_dir).and_return(tmpdir)

        watcher = TRuby::Watcher.new(paths: [tmpdir], config: config)
        initial_count = watcher.stats[:total_compilations]
        watcher.send(:compile_file, input_file)

        expect(watcher.stats[:total_compilations]).to eq(initial_count + 1)
      end
    end
  end

  describe "#print_errors" do
    let(:watcher) { TRuby::Watcher.new }

    it "does nothing when diagnostics are empty" do
      expect { watcher.send(:print_errors, []) }.not_to output.to_stdout
    end

    it "prints formatted diagnostics when present" do
      diagnostic = TRuby::Diagnostic.new(
        code: "TR0001",
        message: "Test error",
        file: "test.trb",
        line: 1,
        column: 1,
        source_line: "def test"
      )

      output = capture_stdout { watcher.send(:print_errors, [diagnostic]) }
      expect(output).to include("Test error")
    end
  end

  describe "#print_start_message" do
    let(:watcher) { TRuby::Watcher.new }

    it "prints starting message with timestamp" do
      output = capture_stdout { watcher.send(:print_start_message) }
      expect(output).to include("Starting compilation in watch mode")
      expect(output).to match(/\\[\\d{2}:\\d{2}:\\d{2} [AP]M\\]/)
    end
  end

  describe "#print_file_change_message" do
    let(:watcher) { TRuby::Watcher.new }

    it "prints file change message" do
      output = capture_stdout { watcher.send(:print_file_change_message) }
      expect(output).to include("File change detected")
      expect(output).to include("incremental compilation")
    end
  end

  describe "#print_summary" do
    it "prints zero errors when no errors" do
      watcher = TRuby::Watcher.new
      watcher.instance_variable_set(:@error_count, 0)

      output = capture_stdout { watcher.send(:print_summary) }
      expect(output).to include("0 errors")
    end

    it "prints error count when errors exist" do
      watcher = TRuby::Watcher.new
      watcher.instance_variable_set(:@error_count, 5)

      output = capture_stdout { watcher.send(:print_summary) }
      expect(output).to include("5 errors")
    end

    it "uses singular 'error' for one error" do
      watcher = TRuby::Watcher.new
      watcher.instance_variable_set(:@error_count, 1)

      output = capture_stdout { watcher.send(:print_summary) }
      expect(output).to include("1 error")
    end
  end

  describe "#print_stats" do
    it "prints compilation statistics" do
      watcher = TRuby::Watcher.new
      watcher.stats[:total_compilations] = 10
      watcher.stats[:incremental_hits] = 5
      watcher.stats[:total_time] = 2.5

      output = capture_stdout { watcher.send(:print_stats) }
      expect(output).to include("Watch Mode Statistics")
      expect(output).to include("Total compilations: 10")
      expect(output).to include("Incremental cache hits: 5")
      # hit_rate = incremental_hits / (total_compilations + incremental_hits) = 5 / 15 = 33.3%
      expect(output).to include("33.3%")
      expect(output).to include("2.5s")
    end

    it "handles zero compilations" do
      watcher = TRuby::Watcher.new
      watcher.stats[:total_compilations] = 0
      watcher.stats[:incremental_hits] = 0
      watcher.stats[:total_time] = 0.0

      output = capture_stdout { watcher.send(:print_stats) }
      expect(output).to include("0%")
    end
  end

  describe "#colorize" do
    context "when output is TTY" do
      it "applies ANSI codes" do
        watcher = TRuby::Watcher.new
        watcher.instance_variable_set(:@use_colors, true)

        result = watcher.send(:colorize, :red, "error")
        expect(result).to include("\\e[31m")
        expect(result).to include("\\e[0m")
      end
    end

    it "returns plain text for unknown color" do
      watcher = TRuby::Watcher.new
      watcher.instance_variable_set(:@use_colors, true)

      result = watcher.send(:colorize, :unknown_color, "text")
      expect(result).to eq("text")
    end
  end

  describe "#watch_directories" do
    it "returns source_include directories when default path" do
      config = TRuby::Config.new
      allow(config).to receive(:source_include).and_return(["src/", "lib/"])

      watcher = TRuby::Watcher.new(paths: ["."], config: config)
      dirs = watcher.send(:watch_directories)

      expect(dirs).to be_an(Array)
    end

    it "returns specific paths when provided" do
      Dir.mktmpdir do |tmpdir|
        watcher = TRuby::Watcher.new(paths: [tmpdir])
        dirs = watcher.send(:watch_directories)

        expect(dirs).to include(tmpdir)
      end
    end
  end

  describe "#handle_changes" do
    it "skips when no relevant files changed" do
      watcher = TRuby::Watcher.new
      expect { watcher.send(:handle_changes, [], [], []) }.not_to output.to_stdout
    end

    it "handles removed files" do
      Dir.mktmpdir do |tmpdir|
        file_path = File.join(tmpdir, "test.trb")

        config = TRuby::Config.new
        allow(config).to receive(:out_dir).and_return(tmpdir)

        watcher = TRuby::Watcher.new(paths: [tmpdir], config: config)
        watcher.instance_variable_set(:@file_diagnostics, {})

        output = capture_stdout { watcher.send(:handle_changes, [], [], [file_path]) }
        expect(output).to include("File removed")
      end
    end
  end

  describe "#compile_all" do
    it "compiles all trb and rb files" do
      Dir.mktmpdir do |tmpdir|
        File.write(File.join(tmpdir, "test.trb"), "def hello: void\\nend")

        config = TRuby::Config.new
        allow(config).to receive(:out_dir).and_return(tmpdir)
        allow(config).to receive(:source_include).and_return([tmpdir])
        allow(config).to receive(:excluded?).and_return(false)

        watcher = TRuby::Watcher.new(paths: [tmpdir], config: config)

        capture_stdout { watcher.send(:compile_all) }

        expect(watcher.stats[:total_compilations]).to be >= 1
      end
    end
  end

  describe "#compile_files_incremental" do
    context "with incremental mode" do
      it "skips unchanged files" do
        Dir.mktmpdir do |tmpdir|
          file_path = File.join(tmpdir, "test.trb")
          File.write(file_path, "def hello: void\\nend")

          config = TRuby::Config.new
          allow(config).to receive(:out_dir).and_return(tmpdir)

          watcher = TRuby::Watcher.new(paths: [tmpdir], config: config, incremental: true)
          watcher.instance_variable_set(:@file_diagnostics, {})

          # First compile
          capture_stdout { watcher.send(:compile_files_incremental, [file_path]) }

          # Second compile (should skip)
          output = capture_stdout { watcher.send(:compile_files_incremental, [file_path]) }
          expect(output).to include("Skipping unchanged")
        end
      end
    end

    context "without incremental mode" do
      it "compiles all files" do
        Dir.mktmpdir do |tmpdir|
          file_path = File.join(tmpdir, "test.trb")
          File.write(file_path, "def hello: void\\nend")

          config = TRuby::Config.new
          allow(config).to receive(:out_dir).and_return(tmpdir)

          watcher = TRuby::Watcher.new(paths: [tmpdir], config: config, incremental: false)
          watcher.instance_variable_set(:@file_diagnostics, {})

          capture_stdout { watcher.send(:compile_files_incremental, [file_path]) }

          expect(watcher.stats[:total_compilations]).to be >= 1
        end
      end
    end
  end

  describe "LISTEN_AVAILABLE constant" do
    it "is defined" do
      expect(defined?(LISTEN_AVAILABLE)).to be_truthy
    end
  end

  describe "parallel processor" do
    it "initializes parallel processor when parallel is true" do
      watcher = TRuby::Watcher.new(parallel: true)
      expect(watcher.instance_variable_get(:@parallel_processor)).not_to be_nil
    end

    it "does not initialize parallel processor when parallel is false" do
      watcher = TRuby::Watcher.new(parallel: false)
      expect(watcher.instance_variable_get(:@parallel_processor)).to be_nil
    end
  end

  describe "cross file checking" do
    it "enables cross file check by default" do
      watcher = TRuby::Watcher.new
      expect(watcher.instance_variable_get(:@cross_file_check)).to be true
    end

    it "can disable cross file check" do
      watcher = TRuby::Watcher.new(cross_file_check: false)
      expect(watcher.instance_variable_get(:@cross_file_check)).to be false
    end
  end

  private

  def capture_stdout
    original_stdout = $stdout
    $stdout = StringIO.new
    yield
    $stdout.string
  ensure
    $stdout = original_stdout
  end
end
`,
};

/** Flag indicating if real T-Ruby is bundled */
export const HAS_T_RUBY_BUNDLE = true;
